<div class="container-fluid">
	<h1>container-fluid</h1>
	<dt>描述</dt>
	<dd>Angular可以将组件样式与组件捆绑在一起，从而实现比常规样式表更多的模块化设计</dd>
	<a href="https://angular.io/generated/live-examples/component-styles/eplnkr.html"
		target="_blank">在线实例 |</a>
	<a href="https://angular.io/generated/zips/component-styles/component-styles.zip"
		target="_blank">实例下载</a>

	
	<h3>Using component styles</h3>
	<dt>描述</dt>
	<dd>一种方法是在组件元数据中设置styles属性</dd>
	<pre>
		@Component(&#123;
			selector: 'app-root',
			template: `
				&#60;h1>Tour of Heroes&#60;/h1>
				&#60;app-hero-main [hero]="hero">&#60;/app-hero-main>
			`,
			styles: ['h1 &#123; font-weight: normal; }']
		})
		export class HeroAppComponent &#123;
		  /* . . . */
		}
	</pre>

	<h4>Style scope</h4>
	<dt>重点：</dt>
	<dd>在@Component元数据中指定的样式仅适用于该组件的模板中</dd>

	<dd>类名称和选择器是组件本地的，不会与应用程序中其他位置使用的类和选择器相冲突</dd>
	<dd>对应用程序中其他位置样式的更改不会影响组件的样式</dd>

	<h4>Special selectors(特殊选择器)</h4>
	<dt>描述</dt>
	
	<h5>:host</h5>
	<dt>描述</dt>
	<dd>使用：host伪类选择器来定位承载组件的元素中的样式</dd>
	<dd>注意：而不是定位组件模板中的元素</dd>
	
	<pre>
		:host &#123;
			display: block;
			border: 1px solid black;
		}
	</pre>
	<dt>描述</dt>
	<dd>:host选择器是定位主机元素的唯一方法。</dd>
	<dd>不能使用其他选择器从组件内部访问主机元素，因为它不是组件自己的模板的一部分</dd>
	<dd>主机元素位于父组件的模板中</dd>
	<dd>使用函数形式通过在host之后包含括号中的其他选择器来有条件地应用主机样式</dd>
	<pre>
		:host(.active) &#123;
			border-width: 3px;
		}
	</pre>

	<h5>:host-context</h5>
	<dt>实例</dt>
	<dd>可以将一个CSS主题类应用于文档<body>元素，并且想要根据该元素更改组件的外观</dd>
	<dt>描述</dt>
	<dd>：host-context（）伪类选择器，它的作用就像host（）的函数形式</dd>
	<dd>：host-context（）选择器在组件主机元素的任何祖先中查找CSS类，直到文档根</dd>
	<pre>
		:host-context(.theme-light) h2 &#123;
			background-color: #eef;
		}
	</pre>

	<h5>(deprecated) /deep/, #62;#62;#62;, and ::ng-deep(已弃用)</h5>
	<dt>描述</dt>
	<dd>组件样式通常仅适用于组件自己的模板中的HTM</dd>
	<dd>使用/ deep / shadow-piercing后代组合子将一个样式向下强制到子组件树中的所有子组件视图</dd>
	<dd>/ deep / combinator适用于任何嵌套组件的深度，它适用于组件的视图子代和内容子代</dd>
	<pre>
		:host /deep/ h3 &#123;
			font-style: italic;
		}
	</pre>
	<dt>描述</dt>
	<dd>将所有<h3>元素作为目标，从主元素向下到这个组件到它的所有子元素</dd>
	<dd>仅在模拟视图封装时使用/deep/, #62;#62;#62; 和 ::ng-deep</dd>

	<h5>Loading component styles(加载组件样式)</h5>
	<dt>描述</dt>
	<ul>
		<li>通过设置样式或styleUrls元数据</li>
		<li>内嵌在模板HTML中</li>
		<li>用CSS导入</li>
	</ul>

	<h5>Styles in component metadata(组件元数据中的样式)</h5>
	<dt>描述</dt>
	<dd>可以将样式数组属性添加到@Component装饰器</dd>
	<pre>
		@Component(&#123;
			selector: 'app-root',
			template: `
				&#60;h1>Tour of Heroes&#60;/h1>
				&#60;app-hero-main [hero]="hero">&#60;/app-hero-main>
			`,
			styles: ['h1 &#123; font-weight: normal; }']
		})
		export class HeroAppComponent &#123;
		  /* . . . */
		}
	</pre>
	<dt>注意</dt>
	<dd>这些样式仅适用于此组件</dd>
	<dd>它们不会被嵌套在模板中的任何组件继承，也不会被投影到组件中的任何内容继承</dd>

	<dt>注意</dt>
	<dd>当使用--inline-styles标志创建组件时，CLI将定义一个空的样式数组</dd>
	<pre>
		ng generate component hero-app --inline-style
	</pre>

	<h5>Style files in component metadata(在组件元数据中调用文件)</h5>
	<dt>描述</dt>
	<dd>可以通过将styleUrls属性添加到组件的@Component装饰器来从外部CSS文件加载样式</dd>
	<dd>样式文件中的样式仅适用于此组件</dd>
	<dd>它们不会被嵌套在模板中的任何组件继承，也不会被投影到组件中的任何内容继承</dd>

	<dt>描述</dt>
	<dd>CLI默认为您创建一个空的样式文件，并在组件生成的styleUrls中引用该文件</dd>
	<pre>
		ng generate component hero-app
	</pre>

	<h5>Template inline styles(模板内联样式)</h5>
	<pre>
		@Component(&#123;
			selector: 'app-hero-controls',
			template: `
				&#60;style>
				button &#123;
				  background-color: white;
				  border: 1px solid #777;
				}
				&#60;/style>
				&#60;h3>Controls&#60;/h3>
				&#60;button (click)="activate()">Activate&#60;/button>
			`
		})
	</pre>

	<h5>Template link tags(模板链接标签)</h5>
	<dt>描述</dt>
	<dd>也可以在组件的HTML模板中写入&#60;link>标签</dd>
	<pre>
		@Component(&#123;
			selector: 'app-hero-team',
			template: `
				&#60;link rel="stylesheet" href="assets/hero-team.component.css">
				&#60;h3>Team&#60;/h3>
				&#60;ul>
					&#60;li *ngFor="let member of hero.team">
				  		&#123; &#123;member}}
					&#60;/li>
				&#60;/ul>`
		})
	</pre>
	<dt>注意:</dt>
	<dd>链接标记的href网址必须相对于应用程序根目录，而不是相对于组件文件</dd>

	<h5>CSS @imports</h5>
	<dt>描述</dt>
	<dd>还可以使用标准的CSS @import规则将CSS文件导入到CSS文件中</dd>
	<pre>
		@import 'hero-details-box.css';
	</pre>

	<h5>External and global style files(外部和全局样式文件)</h5>
	<dt>描述</dt>
	<dd>在样式部分注册全局样式文件，默认情况下，样式部分预先配置全局styles.css文件。</dd>

	<h5>Non-CSS style files</h5>
	<dt>描述</dt>
	<dd>如果使用CLI构建，则可以使用sass，less或stylus编写样式文件，并使用适当的扩展名</dd>
	<pre>
		@Component(&#123;
			selector: 'app-root',
			templateUrl: './app.component.html',
			styleUrls: ['./app.component.scss']
		})
		  ...
	</pre>
	<dt>描述</dt>
	<dd>CLI构建过程运行相关的CSS预处理器。
		使用ng generate组件生成组件文件时，CLI会默认发出一个空的CSS样式文件（.css）。</dd>
	<dt>注意</dt>
	<dd>添加到@ Component.styles数组中的样式字符串必须用CSS编写，因为CLI不能将预处理器应用于内联样式</dd>

	<h5>View encapsulation(查看封装)</h5>
	<dt>描述</dt>
	<dd>组件CSS样式被封装到组件的视图中，不会影响应用程序的其余部分。</dd>
	<dd>要控制每个组件的封装方式，可以在组件元数据中设置视图封装模式</dd>
	<dd>本地视图封装使用浏览器的本机影子DOM实现</dd>
	<dd>将影子DOM附加到组件的主机元素，然后将组件视图放入该影子DOM中。</dd>
	<dd>组件的样式包含在阴影DOM中。
		模拟视图封装（默认）通过预处理（和重命名）CSS代码来有效地将CSS范围扩展到组件视图，来模拟影子DOM的行为。</dd>
</div>