<div class="container-fluid">
    <h2 class="text-center">Template Syntax</h2>

    <h3>HTML in templates</h3>

    <dt>描述</dt>
    <dd>HTML是Angular模板的语言</dd>
    
    <dt>注意</dt>
    <!-- <dd>&#60;‘script’&#62;元素是一个值得注意的例外</dd> -->

    <!-- <h4>‘Interpolation’ &#40; &#123;&#123;...&#125;&#125; &#41;</h4> -->
    <dt>描述</dt>
    <!-- <pre>
      &#60;p>My current hero is &#123;&#123;currentHero.name&#125;&#125;&#60;/p>
      <h3>
        &#123;&#123;title&#125;&#125;
        <img src="&#123;&#123;heroImageUrl&#125;&#125;" style="height:30px">
      </h3>
    </pre> -->
    <dd>
      可以使用插值将计算的字符串编织到HTML元素标记之间和属性赋值之间的文本中
    </dd>
    <dt>实现原理</dt>
    <dd>大括号之间的文本通常是组件属性的名称</dd>
    <dd>Angular使用相应组件属性的字符串值替换该名称</dd>
    <dd>
      大括号之间的文本是Angular首先评估并转换为字符串的模板表达式
    </dd>
    <pre>
      <!-- The sum of 1 + 1 is not &#123;&#123;1 + 1 + 'getVal'&#40;&#41;&#125;&#125; -->
    </pre>
    <dd>
        Angular评估双花括号中的所有表达式，将表达式结果转换为字符串，
      并将它们与相邻的文字字符串进行链接
    </dd>
    <dd>
        最后，将这个复合插值结果赋值给一个元素或指令属性
    </dd>
    <dd>
        插值是Angular转换成属性绑定的特殊语法
    </dd>

    <h4>Template expressions&#40;表达式&#41;</h4>
    <dt>禁止一些有其他作用的运算符在绑值表达式中</dt>
    <dd>assignments &#40;=, +=, -=, ...&#41;</dd>
    <dd>new</dd>
    <dd>chaining expressions with &#40;链接表达式&#41;：or</dd>
    <dd>增量和减量运算符（++ 和 --）</dd>
    <dd>no support for the bitwise operators&#40;不支持按位运算符&#41; | and &</dd>
    <dd>new template expression operators&#40;新的模板表达式运算符等&#41;, such as |. ?. and !.</dd>

    <dt>上下文的概念</dt>
    <pre>
      <div *ngFor="let hero of heroes">&#123;&#123;hero.name&#125;&#125;</div>
      <input #heroInput> &#123;&#123;heroInput.value&#125;&#125;
    </pre>
    <dt>描述</dt>
    <dd>
        表达式中术语的上下文是模板变量，指令的上下文对象（如果有的话）和组件的成员的混合
    </dd>
    <dd>
        如果引用属于多个这些名称空间的名称，则模板变量名称优先，
        后跟指令上下文中的名称，最后是组件的成员名称
    </dd>
    <dd>
      <!-- &#123;&#123;hero.name&#125;&#125;中的hero是指模板输入变量，而不是组件的属性 -->
    </dd>

    <h4>Expression guidelines &#40;表达准则&#41;</h4>

    <dt>No visible side effects</dt>
    <dd>模板表达式不应该改变目标属性的值以外的任何应用程序状态</dd>
    <dd>这个规则对Angular的“单向数据流”策略是必不可少的</dd>

    <dt>Quick execution&#40;快速执行&#41;</dt>
    <dd>Angular在每个更改检测周期后执行模板表达式</dd>
    <dd>更改检测周期由许多异步活动（如promise解析，http结果，计时器事件，按键和鼠标移动）触发</dd>
    <dd>表达式应该很快完成，否则用户体验可能会拖慢，特别是在较慢的设备上</dd>
    <dt>解决方法</dt>
    <dd>当他们的计算成本很高时，考虑缓存值</dd>

    <dt>Simplicity</dt>
    <dd>虽然可以编写相当复杂的模板表达式，但是应该避免使用它们</dd>
    <dd>属性名称或方法调用应该是标准。偶尔的布尔否定（！）是可以的</dd>
    <dd>否则，将应用程序和业务逻辑限制在组件本身，在那里更容易开发和测试</dd>

    <h3>Template statements</h3>
    <dt>事件绑定</dt>
    <pre>
      &#60;button &#40;click&#41;="deleteHero&#40;&#41;">Delete hero&#60;/button>
    </pre>
    <dd>模板上下文名称优先于组件上下文名称</dd>

    <h3>Binding syntax: An overview</h3>
    <dt>描述</dt>
    <dd>数据绑定是一种协调用户看到的应用程序数据值的机制</dd>
    <dd>
        虽然可以将值从HTML推入并拉出，
        但如果将这些杂事转换为绑定框架，则应用程序更易于编写，读取和维护
    </dd>
    <dd>
        只需声明绑定源和目标HTML元素之间的绑定，然后让框架完成工作。
        Angular提供了多种数据绑定
    </dd>
    <dd>
        绑定类型可以按照数据流的方向分为三类：\
        从源到视图，
        从视图到源，
        以及双向顺序：视图到源到视图
    </dd>
    <table class="table table-hover table-bordered">
        <tr>
          <td>Data direction&#40;方向&#41;</td>
          <td>Syntax&#40;句法&#41;</td>
          <td>Type</td>
        </tr>
        <tr>
          <td>
              <p>One-way</p>
              <p>from data source to view target</p>
          </td>
          <td>
              <pre>
                  &#123;&#123;expression&#125;&#125;
                  &#91;target&#93;="expression"
                  bind-target="expression"
              </pre>
          </td>
          <td>
            <p>Interpolation&#40;插值&#41;</p>
            <p>Property</p>
            <p>Attribute</p>
            <p>Class</p>
            <p>style</p>
          </td>
        </tr>
        <tr>
            <td>
                <p>One-way</p>
                <p>from view target to data source</p>
            </td>
            <td>
                <pre>
                    &#40;target&#41;="statement"
                    on-target="statement"
                </pre>
            </td>
            <td>
                Event
            </td>
            
        </tr>
        <tr>
            <td>Two-way</td>
            <td>
                <pre>
                    &#91;&#40;target&#41;&#93;="expression"
                    bindon-target="expression"
                </pre>
            </td>
            <td>
                Two-way
            </td>
        </tr>
    </table>
    <dt>注意：html属性和dom属性</dt>

    <h3>HTML attribute vs. DOM property</h3>
    <dt>描述</dt>
    <dd>
        属性由HTML定义。
        属性由DOM（文档对象模型）定义
    </dd>
    <ul>
        <li>
            一些HTML属性映射到属性1：1。
            id是一个例子
        </li>
        <li>
            一些HTML属性没有相应的属性。
            colspan就是一个例子
        </li>
        <li>
            一些DOM属性没有相应的属性。
            textContent就是一个例子
        </li>
        <li>许多HTML属性似乎映射到属性</li>
    </ul>

    <dt>html 与 dom 的渲染关系</dt>
    <dd>html属性初始化DOM属性，然后完成</dd>
    <dd>页面展示的dom属性是根据页面更改而更改但不会更改到html属性</dd>
    <dd>但是如果绑定的是html的属性时则会根据html属性的变化对dom产生影响</dd>

    <h4>Binding targets</h4>
    <table class="table table-hover table-bordered">
        <tr>
            <td>type</td>
            <td>target&#40;目标&#41;</td>
            <td>Examples</td>
        </tr>
        <tr>
            <td>Property</td>
            <td>
                <p>Element property</p>
                <p>Component property</p>
                <p>Directive property</p>
            </td>
            <td>
                <pre>
                    <&#60;img &#91;src&#93;="heroImageUrl">
                    &#60;app-hero-detail &#91;hero&#93;="currentHero">&#60;/app-hero-detail>
                    &#60;div &#91;ngClass&#93;="&#123;'special': isSpecial&#125;">&#60;/div>
                </pre>
            </td>
        </tr>
        <tr>
            <td>Event</td>
            <td>
                <p>Element event</p>
                <p>Component event</p>
                <p>Directive event</p>
            </td>
            <td>
                <pre>
                    <&#60;button &#40;click&#41;="onSave&#40;&#41;">Save<&#60;/button>
                    <&#60;app-hero-detail &#40;deleteRequest&#41;="deleteHero&#40;&#41;"><&#60;/app-hero-detail>
                    <&#60;div &#40;myClick&#41;="clicked=$event" clickable>click me<&#60;/div>
                </pre>
            </td>
        </tr>
        <tr>
            <td>
                Two-way
            </td>
            <td>
                Event and property
            </td>
            <td>
                <pre>
                    &#60;input &#91;&#40;ngModel&#41;&#93;="name">
                </pre>
            </td>
        </tr>
        <tr>
            <td>Attribute</td>
            <td>Attribute</td>
            <td>
                <pre>
                    &#60;button &#91;attr.aria-label&#93;="help">help&#60;/button>
                </pre>
            </td>
        </tr>
        <tr>
            <td>Class</td>
            <td>class property</td>
            <td>
                <pre>
                    &#60;div &#91;class.special&#93;="isSpecial">Special&#60;/div>
                </pre>
            </td>
        </tr>
        <tr>
            <td>Style</td>
            <td>style property</td>
            <td>
                <pre>
                    &#60;button &#91;style.color&#93;="isSpecial ? 'red' : 'green'"&#62;
                </pre>
            </td>
        </tr>
    </table>

    <h4>Property&#40;属性&#41; binding</h4>
    <pre>
        `
        &#60;img &#91;src&#93;="heroImageUrl">
        &#60;img bind-src="heroImageUrl">
        &#60;button &#91;disabled&#93;="isUnchanged">Cancel is disabled&#60;/button>
        &#60;div &#91;ngClass&#93;="classes">&#91;ngClass&#93; binding to the classes property&#60;/div>
        &#60;app-hero-detail &#91;hero&#93;="currentHero">&#60;/app-hero-detail>
        `
    </pre>

    <dt>Return the proper&#40;正确&#41; type</dt>
    <dd>模板表达式应计算为目标属性所期望的值的类型</dd>

    <dt>One-time string initialization&#40;初始化&#41;</dt>
    <dt>满足以下所有条件时，应该省略括号</dt>
    <dd>目标属性接受一个字符串值</dd>
    <dd>该字符串是一个固定的值</dd>
    <dd>这个初始值永远不会改变</dd>

    <h4>Property binding or interpolation</h4>
    <dt>描述</dt>
    <dd>在许多情况下插值是一种方便的替代属性绑定的方法</dd>
    <dd>将元素属性设置为非字符串数据值时，必须使用属性绑定</dd>
    <pre>
        <p>&#60;img src="&#123;&#123;heroImageUrl&#125;&#125;"> is the <i>interpolated</i> image.</p>
        <p>&#60;img &#91;src&#93;="heroImageUrl"> is the <i>property bound</i> image.</p>

        <p>&#60;span>"&#123;&#123;title&#125;&#125;" is the <i>interpolated</i> title.&#60;/span></p>
        <p>"&#60;span &#91;innerHTML&#93;="title">&#60;/span>" is the <i>property bound</i> title.</p>
    </pre>

    <h4>Content security &#40;angular 安全机制&#41;</h4>
    <pre>
        evilTitle = 'Template &#60;script>alert&#40;"evil never sleeps"&#41;&#60;/script>Syntax';
        &#60;p>&#60;span>"&#123;&#123;evilTitle&#125;&#125;" is the &#60;i>interpolated&#60;/i> evil title.&#60;/span>&#60;/p>
        &#60;p>"&#60;span &#91;innerHTML&#93;="evilTitle">&#60;/span>" is the &#60;i>property bound&#60;/i> evil title.&#60;/p>
    </pre>

    <h4>Attribute, class, and style bindings</h4>
    <dt>Attribute binding</dt>
    <dd>可以直接使用属性绑定来设置属性的值</dd>
    <dt>注意:</dt>
    <dd>使用属性绑定设置元素属性始终优先于使用字符串设置属性</dd>
    <dd>当没有要绑定的元素属性时，必须使用属性绑定</dd>
    <pre>
        &#60;tr&#62;
            &#60;td colspan="&#123;&#123;1 + 1&#125;&#125;"&#62;Three-Four&#60;/td&#62;
        &#60;/tr&#62;
    </pre>
    <dt>描述：</dt>
    <pre>
        Template parse errors(模板解析错误):
        Can't bind to 'colspan' since it isn't a known native property
        不能绑定到“colspan”，因为它不是已知的本地属性
    </pre>
    <dd>它具有“colspan”属性，但是插值和属性绑定只能设置Dom属性，而不能设置html属性</dd>
    <dd>需要 attribute bindings来创建和绑定到这些 attributes.</dd>
    <dd>html属性绑定语法类似于dom属性绑定</dd>
    <dt>将[attr.colspan]绑定到计算值</dt>
    <pre>
        <table border=1>
            <!--  expression calculates colspan=2 -->
            <tr><td [attr.colspan]="1 + 1">One-Two</td></tr>
          
            <!-- ERROR: There is no `colspan` property to set!
              <tr><td colspan="{{1 + 1}}">Three-Four</td></tr>
            -->
          
            <tr><td>Five</td><td>Six</td></tr>
        </table>
    </pre>

    <h4>Class binding</h4>
    <dt>描述</dt>
    <dd>可以使用类绑定从元素的类属性添加和删除CSS类名称</dd>
    <dd>类绑定语法类似于属性绑定</dd>
    <dd>
        不是括号内的元素属性，从前缀类开始，可选地跟一个点（。）
        和一个CSS类的名字：[class.class-name]
    </dd>
    <pre>
        standard class attribute setting 
        &#60;div class="bad curly special">Bad curly special&#60;/div>
    </pre>
    <dt>描述</dt>
    <dd>可以用一个绑定到所需类名的字符串来替换它</dd>
    <dd>这是一个全或无，替代绑定</dd>
    <pre>
        reset/override all class names with a binding 
        &#60;div class="bad curly special"
            [class]="badCurly">Bad curly&#60;/div>
    </pre>
    <dt>可以绑定到一个特定的类名</dt>
    <pre>
        toggle the "special" class on/off with a property
        &#60;div [class.special]="isSpecial">The class binding is special&#60;/div>

        binding to `class.special` trumps the class attribute
        &#60;div class="special"
            [class.special]="!isSpecial">This one is not so special&#60;/div>
    </pre>
    <dd>特定class的绑定的优先级比较高</dd>
    <dt>注意:</dt>
    <dd>但是在同时管理多个类名时通常首选NgClass指令</dd>

    <h4>Style binding</h4>
    <dt>描述</dt>
    <dd>可以使用样式绑定来设置内联样式</dd>
    <dd>样式绑定语法类似于属性绑定</dd>
    <dd>
        不是括号内的元素属性，
        从前缀样式开始，后跟一个点（。）和一个CSS样式属性的名称：
        [style.style-property]
    </dd>
    <pre>
        &#60;button [style.color]="isSpecial ? 'red': 'green'">Red&#60;/button>
        &#60;button [style.background-color]="canSave ? 'cyan': 'grey'" >Save&#60;/button>
    </pre>
    <dt>一些样式绑定样式有一个单位扩展名</dt>
    <pre>
        &#60;button [style.font-size.em]="isSpecial ? 3 : 1" >Big&#60;/button>
        &#60;button [style.font-size.%]="!isSpecial ? 150 : 50" >Small&#60;/button>
    </pre>
    <dt>注意</dt>
    <dd>虽然这是设置单个样式的好方法，但是在同时设置多个内联样式时，通常首选NgStyle指令</dd>
    <dd>请注意，样式属性名称可以使用破折号（如上所示）或camelCase（如fontSize）编写</dd>

    <h4>Event binding ( (event) )事件绑定</h4>
    <dt>描述</dt>
    <dd>所遇到的绑定指令可以在一个方向上流动数据：从一个组件到一个元素</dd>
    <dd>用户操作可能导致数据流向相反的方向：从元素到组件</dd>
    <dd>事件绑定语法由等号左边括号内的目标事件名称和右边带引号的模板语句组成</dd>
    <pre>
        &#60;button (click)="onSave()">Save&#60;/button>
    </pre>

    <h4>Target event</h4>
    <dt>描述</dt>
    <dd>圆括号之间的名称 - 例如（点击） - 标识目标事件</dd>
    <pre>
        &#60;button (click)="onSave()">Save&#60;/button>
        使用前缀替代方法
        &#60;button on-click="onSave()">On Save&#60;/button>
    </pre>
    <dd>
        元素事件可能是更常见的目标，
        但Angular首先查看名称是否与已知指令的事件属性匹配
    </dd>
    <pre>
        `myClick` is an event on the custom `ClickDirective`
        `myClick`是自定义`ClickDirective`上的一个事件
        &#60;div (myClick)="clickMessage=$event" clickable>click with myClick&#60;/div>
    </pre>
    <dd>
        如果名称未能匹配已知指令的元素事件或输出属性，则Angular会报告“未知指令”错误
    </dd>

    <h4>$event and event handling statements(事件处理语句)</h4>
    <dt>描述</dt>
    <dd>在事件绑定中，Angular为目标事件设置了一个事件处理程序</dd>
    <dd>事件发生时，处理程序执行模板语句</dd>
    <dd>
        模板语句通常包含一个接收器，
        它响应事件执行一个动作，例如将HTML控件的值存储到模型中
    </dd>
    <dd>
        绑定通过一个名为$ event的事件对象来传递关于该事件的信息，包括数据值
    </dd>
    <dd>
        事件对象的形状由目标事件决定。
        如果目标事件是本地DOM元素事件，则$ event是一个DOM事件对象，
        具有target和target.value等属性
    </dd>
    <pre>
        &#60;input [value]="currentHero.name"
            (input)="currentHero.name=$event.target.value" >
    </pre>
    <dt>描述</dt>
    <dd>此代码通过绑定到name属性来设置输入框值属性</dd>
    <dd>要监听值的更改，代码会绑定到输入框的输入事件</dd>
    <dd>
        当用户进行更改时，将引发输入事件，绑定在包含DOM事件对象$ event的上下文中执行语句。
        要更新name属性，可以通过路径$ event.target.value来检索已更改的文本
    </dd>
    <dd>
        如果事件属于指令（回想组件是指令），则$ event具有指令决定产生的任何形状
    </dd>

    <h4>Custom events with EventEmitter (自定义事件)</h4>
    <dt>描述</dt>
    <dd>指令通常使用Angular EventEmitter来引发自定义事件</dd>
    <dd>该指令创建一个EventEmitter并将其作为一个属性公开</dd>
    <dd>
        该指令调用EventEmitter.emit（有效载荷）来触发一个事件，
        传递一个消息有效载荷，可以是任何东西。
        父指令通过绑定到此属性并通过$ event对象访问有效内容来侦听事件。</dd>
    <pre>
        template: `
            &#60;div>
            &#60;img src="&#123; &#123;heroImageUrl&#125;&#125;">
            &#60;span [style.text-decoration]="lineThrough">
                &#123; &#123;prefix&#125;&#125; &#123; &#123;hero?.name&#125;&#125;
            &#60;/span>
            &#60;button (click)="delete()">Delete&#60;/button>
            &#60;/div>`
        
        // This component makes a request but it can't actually delete a hero.
        deleteRequest = new EventEmitter&#60;Hero>();

        delete() &#123;
            this.deleteRequest.emit(this.hero);
        }
    </pre>
    <dt>描述</dt>
    <dd>该组件定义了一个返回EventEmitter的deleteRequest属性</dd>
    <dd>当用户点击删除时，组件调用delete（）方法，告诉EventEmitter发出一个Hero对象</dd>
    <dd>一个托管的父组件绑定到HeroDetailComponent的deleteRequest事件</dd>
    <pre>
        &#60;app-hero-detail (deleteRequest)="deleteHero($event)" [hero]="currentHero">
        &#60;/app-hero-detail>
    </pre>
    <dd>
        当触发deleteRequest事件时，
        Angular调用父组件的deleteHero方法，
        传递$ event变量中的hero-to-delete（由HeroDetail发出）
    </dd>
    <dt>Template statements have side effects</dt>
    <dt>描述</dt>
    <dd>删除更新模型，可能会触发其他更改，包括查询并保存到远程服务器</dd>

    <h4>Two-way binding ( [(...)] )</h4>
    <dt>描述</dt>
    <dd>希望显示数据属性，并在用户进行更改时更新该属性。</dd>
    <dd>在设置特定元素属性和监听元素更改事件的组合元素一侧。</dd>
    <dt>
        一个盒子里形象化一个香蕉
        圆括号在方括号内
    </dt>
    <pre>
        <!-- import { Component, EventEmitter, Input, Output } from '@angular/core';
        
        @Component({
            selector: 'app-sizer',
            template: `
            <div>
            <button (click)="dec()" title="smaller">-</button>
            <button (click)="inc()" title="bigger">+</button>
            <label [style.font-size.px]="size">FontSize: {{size}}px</label>
            </div>`
        })
        export class SizerComponent {
            @Input()  size: number | string;
            @Output() sizeChange = new EventEmitter<number>();
        
            dec() { this.resize(-1); }
            inc() { this.resize(+1); }
        
            resize(delta: number) {
            this.size = Math.min(40, Math.max(8, +this.size + delta));
            this.sizeChange.emit(this.size);
            }
        } -->
        import &#123; Component, EventEmitter, Input, Output } from '@angular/core';
        
        @Component(&#123;
            selector: 'app-sizer',
            template: `
            &#60;div>
            &#60;button (click)="dec()" title="smaller">-&#60;/button>
            &#60;button (click)="inc()" title="bigger">+&#60;/button>
            &#60;label [style.font-size.px]="size">FontSize: {{size}}px&#60;/label>
            &#60;/div>`
        })
        export class SizerComponent &#123;
            @Input()  size: number | string;
            @Output() sizeChange = new EventEmitter&#60;number>();
        
            dec() &#123; this.resize(-1); }
            inc() &#123; this.resize(+1); }
        
            resize(delta: number) &#123;
                this.size = Math.min(40, Math.max(8, +this.size + delta));
                this.sizeChange.emit(this.size);
            }
        }
    </pre>
    <dt>描述</dt>
    <dd>初始大小是来自属性绑定的输入值。</dd>
    <dd>
        单击按钮可在最小/最大值限制内增加或减小大小，
        然后用调整的大小提高（发出）sizeChange事件。
    </dd>
    <dt>AppComponent.fontSizePx是双向绑定到SizerComponent的</dt>
    <pre>
        &#60;app-sizer [(size)]="fontSizePx">&#60;/app-sizer>
        &#60;div [style.font-size.px]="fontSizePx">Resizable Text&#60;/div>
        &#60;app-sizer [size]="fontSizePx" (sizeChange)="fontSizePx=$event">&#60;/app-sizer>
    </pre>
    <dt>描述</dt>
    <dd>$ event变量包含SizerComponent.sizeChange事件的有效负载</dd>
    <dd>当用户单击按钮时，Angular将$事件值分配给AppComponent.fontSizePx</dd>
    <dd>Angular NgModel指令是一个使双向绑定形成元素的桥​​梁</dd>

    <h3>Built-in directives(内置指令)</h3>
    <dt>归类为属性指令或结构指令</dt>

    <h4>Built-in attribute directives</h4>
    <dt>描述</dt>
    <dd>属性指令侦听并修改其他HTML元素，属性，属性和组件的行为</dd>
    <dd>通常应用于元素，就好像它们是HTML属性一样，因此也就是名称</dd>
    <ul>
        <li>
            <label>NgClass</label>
            ——添加和删​​除一组CSS类
        </li>
        <li>
            <label>NgStyle</label>
            ——添加和删​​除一组HTML样式
        </li>
        <li>
            <label>NgModel</label>
            ——双向数据绑定到HTML表单元素
        </li>
    </ul>

    <h4>NgClass</h4>
    <dt>描述</dt>
    <dd>通常通过动态添加和删除CSS类来控制元素的显示方式</dd>
    <dd>可以绑定到ngClass来同时添加或删除几个类</dd>
    <dd>类绑定是添加或删除单个类的好方法</dd>
    <pre>
        <!-- toggle the "special" class on/off with a property -->
        &#60;div [class.special]="isSpecial">The class binding is special&#60;/div>
    </pre>
    <dd>
        对象的每个键都是一个CSS类的名字;
        如果应该添加类，则其值为真，如果应该删除则为false。
    </dd>
    <pre>
        currentClasses: &#123;};
        setCurrentClasses() &#123;
            // CSS classes: added/removed per current state of component properties
            this.currentClasses =  &#123;
            'saveable': this.canSave,
            'modified': !this.isUnchanged,
            'special':  this.isSpecial
            };
        }
    </pre>
    <dt>另一种用法</dt>
    <dd>将ngClass属性绑定添加到currentClasses，相应地设置元素的类</dd>
    <pre>
        &#60;div [ngClass]="currentClasses">
            This div is initially saveable, unchanged, and special
        &#60;/div>
    </pre>

    <h4>NgStyle</h4>
    <dt>描述</dt>
    <dd>可以根据组件的状态动态设置内联样式</dd>
    <dd>使用NgStyle，您可以同时设置许多内联样式</dd>
    <pre>
        &#60;div [style.font-size]="isSpecial ? 'x-large' : 'smaller'" >
            This div is x-large or smaller.
        &#60;/div>

        currentStyles: &#123;};
        setCurrentStyles() &#123;
          // CSS styles: set per current state of component properties
          this.currentStyles = &#123;
            'font-style':  this.canSave      ? 'italic' : 'normal',
            'font-weight': !this.isUnchanged ? 'bold'   : 'normal',
            'font-size':   this.isSpecial    ? '24px'   : '12px'
          };
        }
    </pre>
    <dd>添加ngStyle属性绑定到currentStyles将相应地设置元素的样式</dd>
    <pre>
        &#60;div [ngStyle]="currentStyles">
            This div is initially italic, normal weight, and extra large (24px).
        &#60;/div>
    </pre>

    <h4>NgModel - Two-way binding to form elements with [(ngModel)]</h4>
    <dt>描述</dt>
    <dd>
        在开发数据输入表单时，通常都会显示数据属性，并在用户进行更改时更新该属性
    </dd>
    <pre>
        &#60;input [(ngModel)]="currentHero.name">
    </pre>

    <dt>FormsModule is required to use ngModel</dt>
    <dd>
        在双向数据绑定中使用ngModel指令之前，
        必须导入FormsModule并将其添加到NgModule的导入列表中。
    </dd>
    <pre>
        import &#123; NgModule } from '@angular/core';
        import &#123; BrowserModule }  from '@angular/platform-browser';
        import &#123; FormsModule } from '@angular/forms'; // <--- JavaScript import from Angular
        
        /* Other imports */
        
        @NgModule(&#123;
            imports: [
            BrowserModule,
            FormsModule  // <--- import into the NgModule
            ],
            /* Other module metadata */
        })
        export class AppModule &#123; &#125;
    </pre>

    <dt>Inside [(ngModel)]</dt>
    <dd>可以用单独的绑定到&#60;input>元素的value属性和输入事件获得相同的结果</dd>
    <pre>
        &#60;input [value]="currentHero.name"
            (input)="currentHero.name=$event.target.value" >
    </pre>
    <dd>
        该ngModel指令隐藏了自己的ngModel输入和ngModelChange输出属性背后的这些繁重的细节
    </dd>
    <pre>
        &#60;input
            [ngModel]="currentHero.name"
            (ngModelChange)="currentHero.name=$event">
    </pre>
    <dd>
        ngModel data属性设置元素的value属性，
        ngModelChange事件属性监听元素值的变化。
    </dd>
    <dd>单独的ngModel绑定是对绑定到元素本地属性的改进</dd>
    <pre>
        &#60;input [(ngModel)]="currentHero.name">
    </pre>

    <h4>Built-in structural(结构) directives</h4>
    <dt>描述</dt>
    <dd>结构指令负责HTML布局</dd>
    <dd>通过添加，删除和操作它们所连接的主机元素来对DOM的结构进行整形或重塑</dd>
    <dt>有关结构指令的深入细节</dt>
    <ul>
        <li>
            <a href="https://angular.io/guide/structural-directives#asterisk" target="_blank">
                为什么用星号（*）加前缀指令名称？
            </a>
        </li>
        <li>
            <a href="https://angular.io/guide/structural-directives#ngcontainer" target="_blank">
                如果指令没有合适的主机元素，则使用&#60;ng-container>对元素进行分组。
            </a>
        </li>
        <li>
            如何编写自己的结构指令
        </li>
        <li>
            <a href="https://angular.io/guide/structural-directives#one-per-element" target="_blank">
                只能将一个结构指令应用于元素
            </a>
        </li>
    </ul>

    <dt>常见的结构指令</dt>
    <ul>
        <li>
            <label>NgIf</label>
            ——有条件地添加或从DOM中删除一个元素
        </li>
        <li>
            <label>NgSwitch</label>
            ——一组在不同视图之间切换的指令
        </li>
        <li>
            <label>NgForOf</label>
            ——为列表中的每个项目重复一个模板
        </li>
    </ul>

    <dt>NgIf</dt>
    <dd>
        可以通过向该元素（称为主机元素）应用NgIf指令来添加或删除DOM中的元素
    </dd>
    <pre>
        &#60;app-hero-detail *ngIf="isActive">&#60;/app-hero-detail>
    </pre>
    <dt>注意:不要忘记ngIf前面的星号（*）。</dt>
    <dd>
        当isActive表达式返回真值时，NgIf将HeroDetailComponent添加到DOM
        当表达式是虚假的，NgIf从DOM中删除HeroDetailComponent，销毁该组件及其所有子组件
    </dd>

    <dt>Show/hide is not the same thing (显示和隐藏)</dt>
    <dd>可以使用类或样式绑定来控制元素的可见性</dd>
    <pre>
        isSpecial is true
        &#60;div [class.hidden]="!isSpecial">Show with class&#60;/div>
        &#60;div [class.hidden]="isSpecial">Hide with class&#60;/div>

        HeroDetail is in the DOM but hidden
        &#60;app-hero-detail [class.hidden]="isSpecial">&#60;/app-hero-detail>

        &#60;div [style.display]="isSpecial ? 'block' : 'none'">Show with style&#60;/div>
        &#60;div [style.display]="isSpecial ? 'none'  : 'block'">Hide with style&#60;/div>
    </pre>
    <dd>隐藏一个元素与用NgIf去除一个元素是完全不同的</dd>
    <dd>
        这些元素的所有组件都保留在内存中，Angular可能会继续检查更改。
        对于用户看不到的东西，可能会占用相当可观的计算资源并降低性能。
        当NgIf为false时，Angular从DOM中删除元素及其后代。
    </dd>
    <dd>
        它摧毁了他们的组件，潜在地释放了大量的资源，从而带来了更加快速的用户体验
    </dd>
    <pre>
        &#60;div *ngIf="currentHero">Hello, &#123; &#123;currentHero.name&#125;&#125;&#60;/div>
        &#60;div *ngIf="nullHero">Hello, &#123; &#123;nullHero.name&#125;&#125;&#60;/div>
    </pre>

    <dt>NgForOf</dt>
    <dd>
        NgForOf是一个重复指令 - 一种呈现项目列表的方式
    </dd>
    <pre>
        &#60;div *ngFor="let hero of heroes">&#123; &#123;hero.name&#125;&#125;&#60;/div>
    </pre>
    <dd>也可以将NgForOf应用于组件元素</dd>
    <pre>
        &#60;app-hero-detail *ngFor="let hero of heroes" [hero]="hero">&#60;/app-hero-detail>
    </pre>
    <dt>注意:不要忘记ngFor前面的星号（*）。</dt>
    <dt>分配给* ngFor的字符串不是模板表达式</dt>
    <dd>
        heroes数组中的每个heroe，将其存储在本地heroe循环变量中，
        并使其可用于每次迭代的模板HTML
    </dd>
    <dd>
        Angular把这个指令翻译成宿主元素周围的&#60;ng-template>，
        然后重复使用这个模板为列表中的每个英雄创建一组新的元素和绑定。
    </dd>

    <dt>Template input variables(模板输入变量)</dt>
    <dd>
        hero之前的let关键字创建一个名为hero的模板输入变量。
        NgForOf指令遍历父组件的heroes属性返回的heroes数组，
            并在每次迭代期间将hero设置为数组中的当前项。
        在NgForOf宿主元素（及其后代）内引用英雄输入变量来访问英雄的属性
    </dd>
    <pre>
        &#60;div *ngFor="let hero of heroes">&#123; &#123;hero.name&#125;&#125;&#60;/div>
        &#60;app-hero-detail *ngFor="let hero of heroes" [hero]="hero">&#60;/app-hero-detail>
    </pre>

    <dt>*ngFor with index</dt>
    <dd>
        NgForOf指令上下文的index属性返回每个迭代中项目从零开始的索引。
    </dd>
    <dd>
        可以捕获模板输入变量中的索引，并在模板中使用它
    </dd>
    <pre>
        &#60;div *ngFor="let hero of heroes; let i=index">
            &#123; &#123;i + 1&#125;&#125; - &#123; &#123;hero.name&#125;&#125;
        &#60;/div>
    </pre>
    <dt>
        <a href="https://angular.io/api/common/NgForOf" target="_blank">
            NgFor是由NgForOf指令实现的
        </a>
    </dt>

    <dt>*ngFor with trackBy</dt>
    <dd>NgForOf指令可能表现不佳，尤其是对于大型列表</dd>
    <dd>对一个项目，删除项目或添加项目的小改动可以触发DOM操作的级联</dd>
    <dt>性能问题</dt>
    <dd>
        Angular只能看到新的对象引用列表。
        别无选择，只能拆除旧的DOM元素并插入所有新的DOM元素.
    </dd>
    <dt>解决方法</dt>
    <dd>
        Angular可以通过trackBy避免这种流失
        向返回值NgForOf应跟踪的组件添加一个方法
        在这种情况下，这个值就是英雄的ID
    </dd>
    <pre>
        trackByHeroes(index: number, hero: Hero): number &#123; return hero.id; }

        &#60;div *ngFor="let hero of heroes; trackBy: trackByHeroes">
            (&#123; &#123;hero.id&#125;&#125;) &#123; &#123;hero.name&#125;&#125;
        &#60;/div>
    </pre>
    <dt>trackBy 的优点</dt>
    <dd>
        没有trackBy，这两个按钮都会触发完整的DOM元素替换。
        有了trackBy，只需更改id触发器元素替换。
    </dd>

    <h4>The NgSwitch directives</h4>
    <dt>描述</dt>
    <dd>NgSwitch就像JavaScript开关语句</dd>
    <dd>可以根据切换条件从几个可能的元素中显示一个元素</dd>
    <dd>NgSwitch实际上是一组三个协作指令：NgSwitch，NgSwitchCase和NgSwitchDefault</dd>
    <pre>
        &#60;div [ngSwitch]="currentHero.emotion">
            &#60;app-happy-hero    *ngSwitchCase="'happy'"    [hero]="currentHero">&#60;/app-happy-hero>
            &#60;app-sad-hero      *ngSwitchCase="'sad'"      [hero]="currentHero">&#60;/app-sad-hero>
            &#60;app-confused-hero *ngSwitchCase="'confused'" [hero]="currentHero">&#60;/app-confused-hero>
            &#60;app-unknown-hero  *ngSwitchDefault           [hero]="currentHero">&#60;/app-unknown-hero>
        &#60;/div>
    </pre>
    <dd>
        NgSwitch是控制器指令。
        将其绑定到返回开关值的表达式。
    </dd>
    <dd>
        它不直接改变DOM。
        绑定到* ngSwitchCase和* ngSwitchDefault。
        NgSwitchCase和NgSwitchDefault指令是结构指令，因为它们添加或删除DOM中的元素。
    </dd>
    <dt>NgSwitchCase</dt>
    <dd>当其绑定值等于开关值时，将其元素添加到DOM</dd>
    <dt>NgSwitchDefault</dt>
    <dd>当没有选定的NgSwitchCase时，将其元素添加到DOM</dd>

    <dt>使用场景</dt>
    <dd>switch指令对于添加和删除组件元素特别有用。</dd>
    <pre>
        &#60;div *ngSwitchCase="'confused'">Are you as confused as &#123; &#123;currentHero.name&#125;&#125;?&#60;/div>
    </pre>

    <h4>Template reference variables ( #var )（模版引用变量）</h4>
    <dt>描述</dt>
    <dd>
        模板引用变量通常是对模板内DOM元素的引用。
        它也可以是对Angular组件或指令或Web组件的引用。
    </dd>
    <pre>
        &#60;input #phone placeholder="phone number">

        lots of other elements

        phone refers to the input element; pass its `value` to an event handler
        &#60;button (click)="callPhone(phone.value)">Call&#60;/button>
    </pre>

    <h4>How a reference variable gets its value (获取变量的值)</h4>
    <dt>描述</dt>
    <dd>在大多数情况下，Angular将引用变量的值设置为声明的元素。</dd>
    <dd>
        一个指令可以改变这种行为，并将其值设置为其他值，比如本身。
        NgForm指令这样做。
    </dd>
    <pre>
        &#60;form (ngSubmit)="onSubmit(heroForm)" #heroForm="ngForm">
            &#60;div class="form-group">
                &#60;label for="name">Name
                    &#60;input class="form-control" name="name" required [(ngModel)]="hero.name">
                &#60;/label>
            &#60;/div>
            &#60;button type="submit" [disabled]="!heroForm.form.valid">Submit&#60;/button>
            &#60;/form>
            &#60;div [hidden]="!heroForm.form.valid">
            &#123; &#123;submitMessage&#125;&#125;
        &#60;/div>
    </pre>
    <dd>
        如果Angular在导入FormsModule时没有考虑到它，那就是HTMLFormElement
        <br>
        NgForm指令的引用，能够跟踪表单中每个控件的值和有效性。
        <br>
        本地&#60;form>元素没有表单属性。但是NgForm指令的确如此，
        它解释了如果heroForm.form.valid无效并且将整个表单控件树传递给父组件的onSubmit方法，
        可以禁用提交按钮。
    </dd>

    <h4>Template reference variable warning notes(模板引用变量警告说明)</h4>
    <dt>描述</dt>
    <dd>
        引用变量的范围是整个模板。
        不要在同一模板中多次定义相同的变量名称。
    </dd>
    <dd>
        可以使用ref-前缀替代#
    </dd>
    <pre>
        &#60;input ref-fax placeholder="fax number">
        &#60;button (click)="callFax(fax.value)">Fax&#60;/button>
    </pre>

    <h4>Input and Output properties(输入输出属性)</h4>
    <dt>描述</dt>
    <dd>Input属性是一个用@Input装饰器注解的settable属性。</dd>
    <dd>
        当数据绑定到属性绑定时，值将流入属性中
        Output属性是一个用@Output装饰器注释的可观察属性。
    </dd>
    <dd>
        EventEmitter。
        作为事件绑定的事件，值从组件流出。
        只能通过其输入和输出属性绑定到另一个组件或指令。
    </dd>
    <dt>Remember that all components are directives.</dt>

    <h3>模版内与模板间的绑值</h3>
    <h4>Discussion (神他妈的讨论 其实就是模版内的绑值)</h4>
    <pre>
        &#60;img [src]="iconUrl"/>
        &#60;button (click)="onSave()">Save&#60;/button>
    </pre>
    <dt>描述</dt>
    <dd>iconUrl和onSave是AppComponent类的成员。</dd>
    <dd>没有用@Input（）或@Output装饰</dd>
    <dd>始终可以在自己的模板中绑定到组件的公共属性</dd>
    <dd>
        它不一定是一个输入或输出属性
        组件的类和模板紧密结合。
        他们都是同一件事的一部分。
        他们一起是组件。
        组件类和模板之间的交换是内部实现细节。
    </dd>

    <h4>Binding to a different component(绑定到不同的组件)</h4>
    <pre>
        &#60;app-hero-detail [hero]="currentHero" (deleteRequest)="deleteHero($event)">
        &#60;/app-hero-detail>

        可能会报错
        Uncaught Error: Template parse errors:
        Can't bind to 'hero' since it isn't a known property of 'app-hero-detail'
        因为它不是“app-hero-detail”的已知属性

        Angular编译器拒绝承认它们。
        除非是Input或Output属性，否则Angular编译器不会绑定到其他组件的属性。

        一个组件绑定到它自己的属性是可以的。
        组件作者完全控制这些绑定。
        但其他组件不应该有这种不受限制的访问。

        如果任何人都可以绑定到它的任何属性，那么你将很难支持你的组件。
        外部组件应该只能绑定到组件的公共绑定API。
        Angular要求你明确这个API。
        由决定哪些属性可供外部组件绑定。
    </pre>
    <dd>不能使用TypeScript公共和私人访问修饰符来塑造组件的公共绑定API。</dd>
    <dd>
        所有数据绑定属性必须是TypeScript公共属性。
        Angular从不绑定到TypeScript私有属性。
    </dd>
    <dd>Angular需要其他一些方法来识别外部组件允许绑定的属性。</dd>
    <dd>另一种方法是@Input（）和@Output（）装饰器。</dd>

    <h4>Declaring Input and Output properties(声明输入和输出属性)</h4>
    <dt>描述</dt>
    <dd>
        绑定到HeroDetailComponent不会失败，
        因为数据绑定属性使用@Input（）和@Output（）装饰器进行注释
    </dd>
    <pre>
        @Input()  hero: Hero;
        @Output() deleteRequest = new EventEmitter&#60;Hero>();

        Alternatively, you can identify members in the inputs 
        and outputs arrays of the directive metadata, as in this example:
        也可以标识指令元数据的输入和输出数组中的成员

        @Component(&#123;
            inputs: ['hero'],
            outputs: ['deleteRequest'],
        &#125;)
    </pre>

    <dt>Input or output?</dt>
    <pre>
        &#60;hero-detail [hero]="currentHero" (deleteRequest)="deleteHero($event)" >&#60;/hero-detail>

        [hero]="currentHero" —— Input
        因为数据从模板绑定表达式流入该属性

        (deleteRequest)="deleteHero($event)" —— output
        输出属性，因为在模板绑定语句中，事件流出该属性并处理该处理程序
    </pre>

    <h4>Aliasing input/output properties(别名输入/输出属性)</h4>
    <dt>描述</dt>
    <dd>
        有时输入/输出属性的公共名称应与内部名称不同。
        属性指令通常是这种情况。
    </dd>
    <pre>
        &#60;div (myClick)="clickMessage=$event" clickable>click with myClick&#60;/div>
    </pre>
    <dd>
        但是，指令名称通常是指令类中属性名称的一个糟糕的选择。
        指令名很少描述属性的作用。
    </dd>
    <dd>
        也可以通过将属性名称传递到输入/输出装饰器来指定别名
    </dd>
    <pre>
        @Output('myClick') clicks = new EventEmitter&#60;string>(); //  @Output(alias) propertyName = ...
    </pre>
    <dt>详细描述</dt>
    <dd>也可以在输入和输出数组中别名属性名称</dd>
    <dd>写一个冒号分隔的（:)字符串，左边是指令属性名称，右边是公有别名</dd>
    <pre>
        @Directive(&#123;
            outputs: ['clicks:myClick']  // propertyName:alias
        &#125;)
    </pre>

    <h4>Template expression operators(模板表达式运算符)</h4>
    <dt>描述</dt>
    <dd>
        模板表达式语言使用JavaScript语法的一个子集，辅以几个特定的​​运算符用于特定的场景
    </dd>
    <dd>pipe and safe navigation operator.</dd>

    <h4>The pipe operator ( | )过滤器</h4>
    <dt>描述</dt>
    <dd>在准备在绑定中使用它之前，表达式的结果可能需要进行一些转换。</dd>
    <pre>
        &#60;div>Title through uppercase pipe: {{title | uppercase}}&#60;/div>

        可以通过多个管道链接表达式

        Pipe chaining: convert title to uppercase, then to lowercase
        &#60;div>
            Title through a pipe chain:
            {{title | uppercase | lowercase}}
        &#60;/div>

        pipe with configuration argument => "February 25, 1970"
        &#60;div>Birthdate: {{currentHero?.birthdate | date:'longDate'}}&#60;/div>

        json过滤器特别有助于调试绑定
        &#60;div>{{currentHero | json}}&#60;/div>

        生成的输出看起来像这样
        &#123; "id": 0, "name": "Hercules", "emotion": "happy",
        "birthdate": "1970-02-25T08:00:00.000Z",
        "url": "http://www.imdb.com/title/tt0065832/",
        "rate": 325 &#125;
    </pre>

    <h4>The safe navigation operator ( ?. ) and null property paths(安全导航运算符（？。）和空属性路径)</h4>
    <dt>描述</dt>
    <dd>
        Angular安全导航运算符（？。）是一种防止属性路径中的null和undefined值的流畅方便的方法。
        在这里，如果currentHero为空，则防止视图呈现失败。
    </dd>
    <pre>
        The title is &#123; &#123;title&#125;&#125;
        The null hero's name is &#123; &#123;nullHero.name&#125;&#125;

        JavaScript会引发一个空引用错误，Angular也会引发这个错误
        TypeError: Cannot read property 'name' of null in [null].
    </pre>
    <dt>影响结果</dt>
    <dd>
        整个视图消失
        可以用* ngIf来解决这个问题
    </dd>
    <pre>
        No hero, div not displayed, no error
        &#60;div *ngIf="nullHero">The null hero's name is &#123; &#123;nullHero.name&#125;&#125;&#60;/div>

        <!-- The null hero's name is {{nullHero && nullHero.name}} -->

        No hero, no problem!
        The null hero's name is &#123; &#123;nullHero?.name&#125;&#125;

        It works perfectly with long property paths such as a?.b?.c?.d.
        它适用于很长的属性路径，如a?.b?.c?.d.
    </pre>

    <h4>The non-null assertion operator ( ! ) (非空断言运算符（！）)</h4>
    <dt>描述</dt>
    <dd>可以使用--strictNullChecks标志强制执行严格的空检查。</dd>
    <dd>然后TypeScript确保没有变量是无意的空或未定义的。</dd>
    <dd>在这种模式下，输入的变量默认情况下不允许null和undefined.</dd>
    <dd>
        类型检查器将抛出一个错误，
        如果你留下一个变量未分配或试图分配null或undefined到一个变量的类型不允许为null和未定义。
        类型检查器如果在运行时无法确定变量是否为空或未定义，则也会引发错误。
    </dd>
    <dd>
        Angular非null断言运算符（！）在Angular模板中起到相同的作用。
    </dd>
    <pre>
        No hero, no text
        &#60;div *ngIf="hero">
            The hero's name is &#123; &#123;hero!.name&#125;&#125;
        &#60;/div>

        当Angular编译器将您的模板转换为TypeScript代码时，
        它会阻止TypeScript报告hero.name可能为null或未定义。

        与安全导航运算符不同，非空断言运算符不防范null或未定义。
        而是告诉TypeScript类型检查器暂停对特定属性表达式进行严格的空检查。

        当打开严格的空检查时，将需要此模板运算符。
    </pre>
</div>