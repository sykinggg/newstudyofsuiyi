<div class="container-fluid">
    <h4>依赖注入模式</h4>
    <p class="f-c-999">依赖注入</p>

    <h5>这是一种编码模式，在这种模式下，
      一个类从外部接收它的依赖，而不是自己创建它们</h5>
    
    <pre>
		import &#123; Engine, Tires, Car &#125; from './car';
			
		// BAD pattern!
		export class CarFactory &#123;
			createCar() &#123;
			let car = new Car(this.createEngine(), this.createTires());
			car.description = 'Factory';
			return car;
			&#125;
		
			createEngine() &#123;
			return new Engine();
			&#125;
		
			createTires() &#123;
			return new Tires();
			&#125;
		&#125;	
	</pre>
	
	<h4>依賴注入的模式</h4>
	<p>let car = injector.get(Car);</p>

	<h4>总结</h4>
	<p>模块的松耦合性无论是注入还是被注入都是依赖注入的模式</p>

	<h4>Angular Dependency Injection</h4>
	<dt>描述</dt>
	<dd>依赖注入（DI）是一种创建依赖于其他对象的对象的方法</dd>
	<dd>依赖注入系统在创建对象实例时提供依赖对象（称为依赖关系）</dd>

	<dt>service provider</dt>
	<dd>一个服务只是Angular中的一个类，直到您使用Angular dependency注入器注册它</dd>
	<dd>Angular在执行应用程序时为您创建注入器，从引导过程中创建的根注入器开始</dd>
	<dd>在注射器可以创建该服务之前，您必须向注射器注册注射器</dd>
	<dd>提供者告诉注射器如何创建服务</dd>
	<dd>没有提供者，注入者不知道它是负责注入服务，也不能创建服务</dd>

	<dt>实例</dt>

	<dd>@Component providers</dd>
	<pre>
		import { Component } from '@angular/core';
		import { HeroService } from './hero.service';

		@Component({
		selector: 'app-heroes',
		providers: [ HeroService ],
		template: `
			<h2>Heroes</h2>
			<app-hero-list></app-hero-list>
		`
		})
		export class HeroesComponent { }
	</pre>

	<dd>@NgModule providers</dd>
	<pre>
		providers: [
			UserService,
			{ provide: APP_CONFIG, useValue: HERO_DI_CONFIG }
		],
	</pre>

	<dt>比较描述</dt>
	<dd>@Component注入相对于@NgModule注入优先级更高 类似于css中的style位置</dd>
	<dd>确切地说，除非模块被延迟加载，否则Angular模块提供程序将在根注入器中注册</dd>
	<dd>请注意，组件提供的服务可能具有有限的生命周期</dd>
	<dd>组件的每个新实例都获得自己的服务实例，当组件实例被销毁时，该服务实例也是如此</dd>
	<pre>
		constructor(heroService: HeroService)
	</pre>

	<h4>Singleton services</h4>
	<dt>描述</dt>
	<dd>服务在注入器范围内是单例的</dd>
	<dd>在给定的注射器中最多只有一个服务实例。</dd>
	<dd>只有一个根注射器，用户服务注册到该注射器。</dd>
	<dd>因此，整个应用程序中只能有一个UserService实例，并且每个注入UserService的类都将获得此服务实例。</dd>
	<dd>
		然而，Angular DI是一个分层注入系统，这意味着嵌套的注入器可以创建自己的服务实例。
	</dd>

	<h4>Component child injectors</h4>
	<dt>描述</dt>
	<dd>
		当Angular创建一个具有@Component.providers的组件的新实例时，它也为该实例创建一个新的子注入器。
	</dd>
	<dd>
		组件注入器是相互独立的，每个组件都创建它自己的组件提供服务的实例。
	</dd>
	<dd>
		当Angular销毁其中一个组件实例时，它也会销毁组件的注入器和注入器的服务实例。
	</dd>
	<dd>
		由于注入器继承，您仍然可以将应用程序范围的服务注入到这些组件中。
		组件的注入器是其父组件的注入器的子组件，并且是其父组件的注入器的后代，等等一直回到应用程序的根注入器。
	</dd>

	<h4>@Injectable()</h4>
	<dt>描述</dt>
	<dd>@Injectable（）装饰器标识可能需要注入依赖的服务类ye</dd>
	<dt>总是用圆括号写@Injectable（），而不仅仅是@Injectable。</dt>
	<dd>
		当Angular创建一个构造函数具有参数的类时，
		它会查找有关这些参数的类型和注入元数据，以便它可以注入正确的服务。
	</dd>

	<h5>装饰器的由来</h5>
	<dt>描述</dt>
	<dd>装饰器的要求是由TypeScript强加的。</dd>
	<dd>当它将代码转换成JavaScript时，TypeScript通常会丢弃参数类型信息。</dd>
	<dd>
		如果类有一个装饰器，
		并且在TypeScript的tsconfig.json配置文件中将emitDecoratorMetadata编译器选项设置为true，
		它会保留这些信息。
	</dd>
	<dd>@Injectable（）装饰器进行注释，不管它是否具有构造函数和依赖关系。</dd>
	<dd>@Injectable（）是服务所需的编码风格。</dd>
	<dd>实际上是使用具有两个属性的提供者对象字面值的提供者注册的简写表达式</dd>
	<pre>
		providers: [Logger]
		[{ provide: Logger, useClass: Logger }]
	</pre>
</div>