<h3 class="text-center mar-t-10 mar-b-10">Cheat Sheet</h3>
<table class="table table-bordered mar-b-20">
    <tr>
        <th>Bootstrapping</th>
        <th>import &#123; platformBrowserDynamic &#125; from '@angular/platform-browser-dynamic';</th>
    </tr>
    <tr>
        <td>platformBrowserDynamic().bootstrapModule(AppModule);</td>
        <td>
            <dt>Bootstraps the app, using the root component from the specified NgModule.</dt>
            <dd>使用指定的ngmodule中的根组件引导应用程序。</dd>
        </td>
    </tr>
</table>
<table class="table table-hover table-bordered mar-b-20">
    <tr>
        <th>NgModules</th>
        <th>import &#123; NgModule &#125; from '@angular/core';</th>
    </tr>
    <tr>
        <td>
            @NgModule(&#123; declarations: ..., imports: ..., exports: ..., providers: ..., bootstrap: ...&#125;) class MyModule &#123;&#125;
        </td>
        <td>
            <dd>Defines a module that contains components, directives, pipes, and providers.</dd>
            <dd>定义了一个包含组件，指令，管道和提供者的模块。</dd>
        </td>
    </tr>
    <tr>
        <td>
            declarations: [MyRedComponent, MyBlueComponent, MyDatePipe]
        </td>
        <td>
            <dd>List of components, directives, and pipes that belong to this module.</dd>
            <dd>属于此模块的组件，指令和管道列表。</dd>
        </td>
    </tr>
    <tr>
        <td>
            imports: [BrowserModule, SomeOtherModule]
        </td>
        <td>
            <dd>List of modules to import into this module. Everything from the imported modules is available to declarations
                of this module.</dd>
            <dd>要导入到此模块的模块列表。</dd>
            <dd>来自导入模块的所有内容都可用于此模块的声明。</dd>
        </td>
    </tr>
    <tr>
        <td>
            exports: [MyRedComponent, MyDatePipe]
        </td>
        <td>
            <dd>List of components, directives, and pipes visible to modules that import this module.</dd>
            <dd>导入此模块的模块可见的组件，指令和管道列表。</dd>
        </td>
    </tr>
    <tr>
        <td>
            providers: [MyService, &#123; provide: ... &#125;]
        </td>
        <td>
            <dd>List of dependency injection providers visible both to the contents of this module and to importers of this module.</dd>
            <dd>依赖注入提供者列表对于本模块的内容和对这个模块的导入者都是可见的。</dd>
        </td>
    </tr>
    <tr>
        <td>
            bootstrap: [MyAppComponent]
        </td>
        <td>
            <dd>List of components to bootstrap when this module is bootstrapped.</dd>
            <dd>在引导模块时引导组件的列表。</dd>
        </td>
    </tr>
</table>
<table class="table table-bordered mar-b-20">
    <tr>
        <th>Template syntax(语法)</th>
        <th></th>
    </tr>
    <tr>
        <td>
            &#60;input [value]="firstName">
        </td>
        <td>
            <dd>Binds property value to the result of expression firstName.</dd>
            <dd>将属性值绑定到表达式名字的结果。</dd>
        </td>
    </tr>
    <tr>
        <td>
            &#60;div [attr.role]="myAriaRole">
        </td>
        <td>
            <dd>Binds attribute role to the result of expression myAriaRole.</dd>
            <dd>将属性角色绑定到表达式myariarole的结果。</dd>
        </td>
    </tr>
    <tr>
        <td>
            &#60;div [class.extra-sparkle]="isDelightful">
        </td>
        <td>
            <dd>Binds the presence of the CSS class extra-sparkle on the element to the truthiness of the expression isDelightful.</dd>
            <dd>将元素的css类的存在绑定到表达式的布尔值。</dd>
        </td>
    </tr>
    <tr>
        <td>
            &#60;div [style.width.px]="mySize">
        </td>
        <td>
            <dd>Binds style property width to the result of expression mySize in pixels. Units are optional.</dd>
            <dd>将样式属性宽度绑定到像素中的表达式mysize的结果。</dd>
            <dd>单位是可选的。</dd>
        </td>
    </tr>
    <tr>
        <td>
            &#60;button (click)="readRainbow($event)">
        </td>
        <td>
            <dd>Calls method readRainbow when a click event is triggered on this button element (or its children) and passes
                in the event object.</dd>
            <dd>在此按钮元素（或其子元素）上触发单击事件并传入事件对象时调用方法readrainbow。</dd>
        </td>
    </tr>
    <tr>
        <td>
            &#60;div title="Hello &#123; &#123;ponyName&#125; &#125;">
        </td>
        <td>
            <dd>Binds a property to an interpolated string, for example, "Hello Seabiscuit".</dd>
            <dd>Equivalent to: &#60;div [title]="'Hello ' + ponyName"></dd>
            <dd>将属性绑定到插入的字符串，例如“hello seabiscuit”。</dd>
            <dd>相当于：&#60;div [title] =“'hello'+ ponyname”></dd>
        </td>
    </tr>
    <tr>
        <td>
            &#60;p>Hello &#123; &#123;ponyName&#125; &#125;&#60;/p>
        </td>
        <td>
            <dd>Binds text content to an interpolated string, for example, "Hello Seabiscuit".</dd>
            <dd>将文本内容绑定到插入的字符串，例如“hello seabiscuit”。</dd>
        </td>
    </tr>
    <tr>
        <td>
            &#60;my-cmp [(title)]="name">
        </td>
        <td>
            <dd>Sets up two-way data binding. Equivalent to: &#60;my-cmp [title]="name" (titleChange)="name=$event"></dd>
            <dd>设置双向数据绑定。</dd>
            <dd>相当于：&#60;my-cmp [title] =“name”（titlechange）=“name = $ event”></dd>
        </td>
    </tr>
    <tr>
        <td>
            <dd>&#60;video #movieplayer ...></dd>
            <dd>&#60;button (click)="movieplayer.play()"></dd>
            <dd>&#60;/video></dd>
        </td>
        <td>
            <dd>Creates a local variable movieplayer that provides access to the video element instance in data-binding and event-binding
                expressions in the current template.</dd>
            <dd>创建一个局部变量movieplayer，它提供对当前模板中数据绑定和事件绑定表达式中视频元素实例的访问。</dd>
        </td>
    </tr>
    <tr>
        <td>
            &#60;p *myUnless="myExpression">...&#60;/p>
        </td>
        <td>
            <dd>The * symbol turns the current element into an embedded template. </dd>
            <dd>Equivalent to: &#60;ng-template [myUnless]="myExpression">&#60;p>...&#60;/p>&#60;/ng-template></dd>
            <dd>*符号将当前元素转换为嵌入模板。</dd>
            <dd>相当于：&#60;ng-template [myunless] =“myexpression”> &#60;p> ... &#60;/p> &#60;/ng-template></dd>
        </td>
    </tr>
    <tr>
        <td>
            &#60;p>Card No.: &#123; &#123;cardNumber | myCardNumberFormatter&#125; &#125;&#60;/p>
        </td>
        <td>
            <dd>Transforms the current value of expression cardNumber via the pipe called myCardNumberFormatter.</dd>
            <dd>通过称为mycardnumberformatter的管道转换的管道名称。</dd>
        </td>
    </tr>
    <tr>
        <td>
            &#60;p>Employer: &#123; &#123;employer?.companyName&#125; &#125;&#60;/p>
        </td>
        <td>
            <dd>The safe navigation operator (?) means that the employer field is optional and if undefined, the rest of the
                expression should be ignored.</dd>
            <dd>安全导航操作符（？）表示雇主字段是可选的，如果未定义，则应忽略表达式的其余部分。</dd>
        </td>
    </tr>
    <tr>
        <td>
            &#60;svg:rect x="0" y="0" width="100" height="100"/>
        </td>
        <td>
            <dd>An SVG snippet template needs an svg: prefix on its root element to disambiguate the SVG element from an HTML
                component.
            </dd>
            <dd>一个svg片段模板需要在它的根元素上使用svg：前缀来消除html组件中的svg元素。</dd>
        </td>
    </tr>
    <tr>
        <td>
            <dd>&#60;svg></dd>
            <dd>&#60;rect x="0" y="0" width="100" height="100"/></dd>
            <dd>&#60;/svg></dd>
        </td>
        <td>
            <dd>An &#60;svg> root element is detected as an SVG element automatically, without the prefix.</dd>
            <dd>一个&#60;svg>根元素被自动检测为一个svg元素，没有前缀。</dd>
        </td>
    </tr>
</table>
<table class="table table-bordered mar-b-20">
    <tr>
        <th>Built-in directives(内置指令)</th>
        <th>import &#123; CommonModule &#125; from '@angular/common';</th>
    </tr>
    <tr>
        <td>
            &#60;section *ngIf="showSection">
        </td>
        <td>
            <dd>Removes or recreates a portion of the DOM tree based on the showSection expression.</dd>
            <dd>基于showsection表达式删除或重新创建dom树的一部分。</dd>
        </td>
    </tr>
    <tr>
        <td>
            &#60;li *ngFor="let item of list">
        </td>
        <td>
            <dd>Turns the li element and its contents into a template, and uses that to instantiate a view for each item in list.</dd>
            <dd>将li元素及其内容转换为模板，并使用它来实例化列表中每个项目的视图。</dd>
        </td>
    </tr>
    <tr>
        <td>
            <dd>&#60;div [ngSwitch]="conditionExpression"></dd>
            <dd> &#60;ng-template [ngSwitchCase]="case1Exp">...&#60;/ng-template></dd>
            <dd> &#60;ng-template ngSwitchCase="case2LiteralString">...&#60;/ng-template></dd>
            <dd> &#60;ng-template ngSwitchDefault>...&#60;/ng-template></dd>
            <dd>&#60;/div></dd>
        </td>
        <td>
            <dd>Conditionally swaps the contents of the div by selecting one of the embedded templates based on the current value
                of conditionExpression.</dd>
            <dd>通过根据condition表达式的当前值选择一个嵌入模板来有条件地交换div的内容。</dd>
        </td>
    </tr>
    <tr>
        <td>
            &#60;div [ngClass]="&#123;'active': isActive, 'disabled': isDisabled&#125;">
        </td>
        <td>
            <dd>Binds the presence of CSS classes on the element to the truthiness of the associated map values</dd>
            <dd>The right-hand expression should return &#123;class-name: true/false&#125; map.</dd>
            <dd>将元素上的CSS类的存在绑定到相关映射值的真实性。</dd>
            <dd>右边的表达式应该返回&#123;class-name：true / false&#125;。</dd>
        </td>
    </tr>
</table>
<table class="table table-bordered mar-b-20">
    <tr>
        <th>Forms</th>
        <th>import &#123; FormsModule &#125; from '@angular/forms';</th>
    </tr>
    <tr>
        <td>
            &#60;input [(ngModel)]="userName">
        </td>
        <td>
            <dd>Provides two-way data-binding, parsing, and validation for form controls.</dd>
            <dd>为表单控件提供了双向的数据绑定，解析和验证。</dd>
        </td>
    </tr>
</table>
<table class="table table-bordered mar-b-20">
    <tr>
        <th>Class decorators(类装饰器)</th>
        <th>import &#123; Directive, ... &#125; from '@angular/core';</th>
    </tr>
    <tr>
        <td>
            <dd>@Component(&#123;...&#125;)</dd>
            <dd>class MyComponent() &#123;&#125;</dd>
        </td>
        <td>
            <dd>Declares that a class is a component and provides metadata about the component.</dd>
            <dd>声明一个类是一个组件，并提供有关该组件的元数据。</dd>
        </td>
    </tr>
    <tr>
        <td>
            <dd>@Directive(&#123;...&#125;)</dd>
            <dd>class MyDirective() &#123;&#125;</dd>
        </td>
        <td>
            <dd>Declares that a class is a directive and provides metadata about the directive.</dd>
            <dd>声明一个类是一个指令，并提供有关该指令的元数据。</dd>
        </td>
    </tr>
    <tr>
        <td>
            <dd>@Pipe(&#123;...&#125;)</dd>
            <dd>class MyPipe() &#123;&#125;</dd>
        </td>
        <td>
            <dd>Declares that a class is a pipe and provides metadata about the pipe.</dd>
            <dd>声明一个类是一个管道，并提供有关管道的元数据。</dd>
        </td>
    </tr>
    <tr>
        <td>
            <dd>@Injectable()</dd>
            <dd>class MyService() &#123;&#125;</dd>
        </td>
        <td>
            <dd>Declares that a class has dependencies that should be injected into the constructor when the dependency injector is creating an instance of this class.</dd>
            <dd>声明一个类具有依赖关系，当依赖注入器创建这个类的一个实例时，该依赖关系应该被注入到构造函数中。</dd>
        </td>
    </tr>
</table>
<table class="table table-bordered mar-b-20">
    <tr>
        <th>Directive configuration(指令配置)</th>
        <th>@Directive(&#123; property1: value1, ... &#125;)</th>
    </tr>
    <tr>
        <td>selector: '.cool-button:not(a)'</td>
        <td>
            <dd>Specifies a CSS selector that identifies this directive within a template.</dd>
            <dd>Supported selectors include element, [attribute], .class, and :not().</dd>
            <dd>Does not support parent-child relationship selectors.</dd>
            <dd>指定一个在模板中标识这个指令的css选择器。</dd>
            <dd>支持的选择器包括元素，[attribute]，.class和：not（）。</dd>
            <dd>不支持亲子关系选择器。</dd>
        </td>
    </tr>
    <tr>
        <td>providers: [MyService, &#123; provide: ... &#125;]</td>
        <td>
            <dd>List of dependency injection providers for this directive and its children.</dd>
            <dd>此指令及其子项的依赖注入提供程序列表。</dd>
        </td>
    </tr>
</table>
<table class="table table-bordered mar-b-20">
    <tr>
        <th>Component configuration(组件配置)</th>
        <th>
            <dd>@Component extends @Directive, so the @Directive configuration applies to components as well</dd>
            <dd>@component扩展了@directive，所以@directive配置也适用于组件</dd>
        </th>
    </tr>
    <tr>
        <td>moduleId: module.id</td>
        <td>
            <dd>If set, the templateUrl and styleUrl are resolved relative to the component.</dd>
            <dd>如果设置，templateurl和styleurl相对于组件解析。</dd>
        </td>
    </tr>
    <tr>
        <td>viewProviders: [MyService, &#123; provide: ... &#125;]</td>
        <td>
            <dd>List of dependency injection providers scoped to this component's view.</dd>
            <dd>依赖注入提供程序的列表限定在此组件的视图中。</dd>
        </td>
    </tr>
    <tr>
        <td>
            <dd>template: 'Hello &#123;&#123;name&#125;&#125;'</dd>
            <dd>templateUrl: 'my-component.html'</dd>
        </td>
        <td>
            <dd>Inline template or external template URL of the component's view.</dd>
            <dd>内联模板或组件视图的外部模板url。</dd>
        </td>
    </tr>
    <tr>
        <td>
            <dd>styles: ['.primary &#123;color: red&#125;']</dd>
            <dd>styleUrls: ['my-component.css']</dd>
        </td>
        <td>
            <dd>List of inline CSS styles or external stylesheet URLs for styling the component’s view.</dd>
            <dd>内联css样式列表或外部样式表url用于样式化组件的视图。</dd>
        </td>
    </tr>
</table>
<table class="table table-bordered mar-b-20">
    <tr>
        <th>Class field decorators for directives and components(用于指令和组件的类字段装饰器)</th>
        <th>import &#123; Input, ... &#125; from '@angular/core';</th>
    </tr>
    <tr>
        <td>@Input() myProperty;</td>
        <td>
            <dd>Declares an input property that you can update via property binding (example: &#60;my-cmp [myProperty]="someExpression">).</dd>
            <dd>声明一个可以通过属性绑定更新的输入属性（例如：&#60;my-cmp [myproperty] =“someexpression”>）。</dd>
        </td>
    </tr>
    <tr>
        <td>@Output() myEvent = new EventEmitter();</td>
        <td>
            <dd>Declares an output property that fires events that you can subscribe to with an event binding (example: &#60;my-cmp (myEvent)="doSomething()">).</dd>
            <dd>声明一个输出属性，用于触发事件绑定的事件（例如：&#60;my-cmp（myevent）=“dosomething（）”>）。</dd>
        </td>
    </tr>
    <tr>
        <td>@HostBinding('class.valid') isValid;</td>
        <td>
            <dd>Binds a host element property (here, the CSS class valid) to a directive/component property (isValid).</dd>
            <dd>将主机元素属性（这里是有效的css类）绑定到指令/组件属性（isvalid）。</dd>
        </td>
    </tr>
    <tr>
        <td>@HostListener('click', ['$event']) onClick(e) &#123;...&#125;</td>
        <td>
            <dd>Subscribes to a host element event (click) with a directive/component method (onClick), optionally passing an argument ($event).</dd>
            <dd>使用指令/组件方法（onclick）订阅主机元素事件（单击），可选地传递参数（$ event）。</dd>
        </td>
    </tr>
    <tr>
        <td>@ContentChild(myPredicate) myChildComponent;</td>
        <td>
            <dd>Binds the first result of the component content query (myPredicate) to a property (myChildComponent) of the class.</dd>
            <dd>将组件内容查询（mypredicate）的第一个结果绑定到类的属性（mychildcomponent）。</dd>
        </td>
    </tr>
    <tr>
        <td>@ContentChildren(myPredicate) myChildComponents;</td>
        <td>
            <dd>Binds the results of the component content query (myPredicate) to a property (myChildComponents) of the class.</dd>
            <dd>将组件内容查询（mypredicate）的结果绑定到类的属性（mychildcomponents）。</dd>
        </td>
    </tr>
    <tr>
        <td>@ViewChild(myPredicate) myChildComponent;</td>
        <td>
            <dd>Binds the first result of the component view query (myPredicate) to a property (myChildComponent) of the class. Not available for directives.</dd>
            <dd>将组件视图查询（mypredicate）的第一个结果绑定到类的属性（mychildcomponent）。不适用于指令。</dd>
        </td>
    </tr>
    <tr>
        <td>@ViewChildren(myPredicate) myChildComponents;</td>
        <td>
            <dd>Binds the results of the component view query (myPredicate) to a property (myChildComponents) of the class. Not available for directives.</dd>
            <dd>将组件视图查询（mypredicate）的结果绑定到类的属性（myChildcomponents）。不适用于指令。</dd>
        </td>
    </tr>
</table>
<table class="table table-bordered mar-b-20">
    <tr>
        <th>
            <dd>Directive and component change detection and lifecycle hooks</dd>
            <dd>指令和组件更改检测和生命周期挂钩</dd>
        </th>
        <th>(implemented as class methods)（作为类方法实现）</th>
    </tr>
    <tr>
        <td>constructor(myService: MyService, ...) &#123; ... &#125;</td>
        <td>
            <dd>Called before any other lifecycle hook. Use it to inject dependencies, but avoid any serious work here.</dd>
            <dd>在任何其他生命周期挂钩之前调用。用它来注入依赖关系，但在这里避免任何严重的工作。</dd>
        </td>
    </tr>
    <tr>
        <td>ngOnChanges(changeRecord) &#123; ... &#125;</td>
        <td>
            <dd>Called after every change to input properties and before processing content or child views.</dd>
            <dd>在每次更改输入属性之后以及在处理内容或子视图之前调用。</dd>
        </td>
    </tr>
    <tr>
        <td>ngOnInit() &#123; ... &#125;</td>
        <td>
            <dd>Called after the constructor, initializing input properties, and the first call to ngOnChanges.</dd>
            <dd>在构造函数之后调用，初始化输入属性，以及第一次调用ngonchanges。</dd>
        </td>
    </tr>
    <tr>
        <td>ngDoCheck() &#123; ... &#125;</td>
        <td>
            <dd>Called every time that the input properties of a component or a directive are checked. </dd>
            <dd>Use it to extend change detection by performing a custom check.</dd>
            <dd>每次调用组件或指令的输入属性时都会调用它。</dd>
            <dd>使用它通过执行自定义检查来扩展变更检测。</dd>
        </td>
    </tr>
    <tr>
        <td>ngAfterContentInit() &#123; ... &#125;</td>
        <td>
            <dd>Called after ngOnInit when the component's or directive's content has been initialized.</dd>
            <dd>在组件或指令的内容被初始化后，在ngoninit之后调用。</dd>
        </td>
    </tr>
    <tr>
        <td>ngAfterContentChecked() &#123; ... &#125;</td>
        <td>
            <dd>Called after every check of the component's or directive's content.</dd>
            <dd>在每次检查组件或指令内容后调用。</dd>
        </td>
    </tr>
    <tr>
        <td>ngAfterViewInit() &#123; ... &#125;</td>
        <td>
            <dd>Called after ngAfterContentInit when the component's view has been initialized. Applies to components only.</dd>
            <dd>当组件的视图被初始化后，在ngaftercontentinit之后调用。仅适用于组件。</dd>
        </td>
    </tr>
    <tr>
        <td>ngAfterViewChecked() &#123; ... &#125;</td>
        <td>
            <dd>Called after every check of the component's view. Applies to components only.</dd>
            <dd>在每次检查组件的视图之后调用。仅适用于组件。</dd>
        </td>
    </tr>
    <tr>
        <td>ngOnDestroy() &#123; ... &#125;</td>
        <td>
            <dd>Called once, before the instance is destroyed.</dd>
            <dd>在实例被销毁之前调用一次。</dd>
        </td>
    </tr>
</table>
<table class="table table-bordered mar-b-20">
    <tr>
        <th>Dependency injection configuration(依赖注入配置)</th>
        <th></th>
    </tr>
    <tr>
        <td>&#123; provide: MyService, useClass: MyMockService &#125;</td>
        <td>
            <dd>Sets or overrides the provider for MyService to the MyMockService class.</dd>
            <dd>将myservice的提供者设置或覆盖到mymockservice类。</dd>
        </td>
    </tr>
    <tr>
        <td>&#123; provide: MyService, useFactory: myFactory &#125;</td>
        <td>
            <dd>Sets or overrides the provider for MyService to the myFactory factory function.</dd>
            <dd>将myservice的提供者设置或覆盖myfactory工厂函数。</dd>
        </td>
    </tr>
    <tr>
        <td>&#123; provide: MyValue, useValue: 41 &#125;</td>
        <td>
            <dd>Sets or overrides the provider for MyValue to the value 41.</dd>
            <dd>将myvalue的提供者设置或覆盖为值41。</dd>
        </td>
    </tr>
</table>
<table class="table table-bordered mar-b-20">
    <tr>
        <th>Routing and navigation(路由和导航)</th>
        <th>import &#123; Routes, RouterModule, ... &#125; from '@angular/router';</th>
    </tr>
    <tr>
        <td>
            <pre>
const routes: Routes = [
    &#123; path: '', component: HomeComponent &#125;,
    &#123; path: 'path/:routeParam', component: MyComponent &#125;,
    &#123; path: 'staticPath', component: ... &#125;,
    &#123; path: '**', component: ... &#125;,
    &#123; path: 'oldPath', redirectTo: '/staticPath' &#125;,
    &#123; path: ..., component: ..., data: &#123; message: 'Custom' &#125; &#125;
]);
const routing = RouterModule.forRoot(routes);
            </pre>
        </td>
        <td>
            <dd>Configures routes for the application. </dd>
            <dd>Supports static, parameterized, redirect, and wildcard routes.</dd>
            <dd>Also supports custom route data and resolve.</dd>
            <dd>配置应用程序的路由。</dd>
            <dd>支持静态，参数化，重定向和通配符路由。</dd>
            <dd>还支持自定义路由数据并解析。</dd>
        </td>
    </tr>
    <tr>
        <td>
            <pre>
&#60;router-outlet>&#60;/router-outlet>
&#60;router-outlet name="aux">&#60;/router-outlet>
            </pre>
        </td>
        <td>
            <dd>Marks the location to load the component of the active route.</dd>
            <dd>标记加载活动路由组件的位置。</dd>
        </td>
    </tr>
    <tr>
        <td>
            <pre>
&#60;a routerLink="/path">
&#60;a [routerLink]="[ '/path', routeParam ]">
&#60;a [routerLink]="[ '/path', &#123; matrixParam: 'value' &#125; ]">
&#60;a [routerLink]="[ '/path' ]" [queryParams]="&#123; page: 1 &#125;">
&#60;a [routerLink]="[ '/path' ]" fragment="anchor">
            </pre>
        </td>
        <td>
            <dd>Creates a link to a different view based on a route instruction consisting of a route path, required and optional parameters, query parameters, and a fragment.</dd>
            <dd>To navigate to a root route, use the / prefix; for a child route, use the ./prefix; for a sibling or parent, use the ../ prefix.</dd>
            <dd>基于由路径路径，必需参数和可选参数，查询参数和片段组成的路线指令创建到不同视图的链接。</dd>
            <dd>导航到根路由，使用/前缀;对于子路由，使用./prefix;对于兄弟姐妹或父母，请使用../前缀。</dd>
        </td>
    </tr>
    <tr>
        <td>&#60;a [routerLink]="[ '/path' ]" routerLinkActive="active">&#60;/a></td>
        <td>
            <dd>The provided classes are added to the element when the routerLink becomes the current active route.</dd>
            <dd>当routerlink成为当前活动路由时，提供的类将被添加到元素中。</dd>
        </td>
    </tr>
    <tr>
        <td>
            <pre>
                class CanActivateGuard implements CanActivate &#123;
                    canActivate(
                    route: ActivatedRouteSnapshot,
                    state: RouterStateSnapshot
                    ): Observable&#60;boolean>|Promise&#60;boolean>|boolean &#123; ... &#125;
                &#125;
                
                &#123; path: ..., canActivate: [CanActivateGuard] &#125;
            </pre>
        </td>
        <td>
            <dd>An interface for defining a class that the router should call first to determine if it should activate this component.</dd>
            <dd>Should return a boolean or an Observable/Promise that resolves to a boolean.</dd>
            <dd>用于定义路由器应首先调用的类的接口，以确定是否应激活此组件。</dd>
            <dd>应该返回一个布尔值或一个observable / promise来解析为一个布尔值。</dd>
        </td>
    </tr>
    <tr>
        <td>
            <pre>
class CanDeactivateGuard implements CanDeactivate&#60;T> &#123;
    canDeactivate(
    component: T,
    route: ActivatedRouteSnapshot,
    state: RouterStateSnapshot
    ): Observable &#60;boolean> |Promise &#60;boolean> |boolean &#123; ... &#125;
&#125;

&#123; path: ..., canDeactivate: [CanDeactivateGuard] &#125;
            </pre>
        </td>
        <td>
            <dd>An interface for defining a class that the router should call first to determine if it should deactivate this component after a navigation.</dd>
            <dd>Should return a boolean or an Observable/Promise that resolves to a boolean.</dd>
            <dd>用于定义路由器应该首先调用的类的接口，以确定在导航之后是否应该停用该组件。</dd>
            <dd>应该返回一个布尔值或一个observable / promise来解析为一个布尔值。</dd>
        </td>
    </tr>
    <tr>
        <td>
            <pre>
class CanActivateChildGuard implements CanActivateChild &#123;
    canActivateChild(
    route: ActivatedRouteSnapshot,
    state: RouterStateSnapshot
    ): Observable &#60;boolean>|Promise &#60;boolean>|boolean &#123; ... &#125;
&#125;

&#123; path: ..., canActivateChild: [CanActivateGuard],
children: ... &#125;
            </pre>
        </td>
        <td>
            <dd>An interface for defining a class that the router should call first to determine if it should activate the child route. </dd>
            <dd>Should return a boolean or an Observable/Promise that resolves to a boolean.</dd>
            <dd>一个用于定义路由器应该首先调用的类的接口，以确定是否应该激活子路由。</dd>
            <dd>应该返回一个布尔值或一个observable / promise来解析为一个布尔值。</dd>
        </td>
    </tr>
    <tr>
        <td>
            <pre>
class ResolveGuard implements Resolve&#60;T> &#123;
    resolve(
    route: ActivatedRouteSnapshot,
    state: RouterStateSnapshot
    ): Observable&#60;any>|Promise&#60;any>|any &#123; ... &#125;
&#125;

&#123; path: ..., resolve: [ResolveGuard] &#125;
            </pre>
        </td>
        <td>
            <dd>An interface for defining a class that the router should call first to resolve route data before rendering the route.</dd>
            <dd>Should return a value or an Observable/Promise that resolves to a value.</dd>
            <dd>一个接口，用于定义一个路由器应该首先调用的类，以便在渲染路由之前解析路由数据。</dd>
            <dd>应该返回一个值或一个可以解析为一个值的可观察/承诺。</dd>
        </td>
    </tr>
    <tr>
        <td>
            <pre>
class CanLoadGuard implements CanLoad &#123;
    canLoad(
    route: Route
    ): Observable&#60;boolean>|Promise&#60;boolean>|boolean &#123; ... &#125;
&#125;

&#123; path: ..., canLoad: [CanLoadGuard], loadChildren: ... &#125;
            </pre>
        </td>
        <td>
            <dd>An interface for defining a class that the router should call first to check if the lazy loaded module should be loaded. </dd>
            <dd> Should return a boolean or an Observable/Promise that resolves to a boolean.</dd>
            <dd>一个用于定义路由器应该首先调用的类的接口，以检查是否应该加载延迟加载的模块。</dd>
            <dd>应该返回一个布尔值或一个observable / promise来解析为一个布尔值。</dd>
        </td>
    </tr>
</table>