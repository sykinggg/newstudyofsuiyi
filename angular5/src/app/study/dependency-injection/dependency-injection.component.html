<div class="container-fluid">
    <h4 class="text-center">依赖注入模式</h4>
    <p class="f-c-999">依赖注入</p>

    <h5>这是一种编码模式，在这种模式下，
      一个类从外部接收它的依赖，而不是自己创建它们</h5>
    
    <pre>
		import &#123; Engine, Tires, Car &#125; from './car';
			
		// BAD pattern!
		export class CarFactory &#123;
			createCar() &#123;
			let car = new Car(this.createEngine(), this.createTires());
			car.description = 'Factory';
			return car;
			&#125;
		
			createEngine() &#123;
			return new Engine();
			&#125;
		
			createTires() &#123;
			return new Tires();
			&#125;
		&#125;	
	</pre>
	
	<h4>依賴注入的模式</h4>
	<p>let car = injector.get(Car);</p>

	<h4>总结</h4>
	<p>模块的松耦合性无论是注入还是被注入都是依赖注入的模式</p>

	<h4>Angular Dependency Injection</h4>
	<dt>描述</dt>
	<dd>依赖注入（DI）是一种创建依赖于其他对象的对象的方法</dd>
	<dd>依赖注入系统在创建对象实例时提供依赖对象（称为依赖关系）</dd>

	<dt>service provider</dt>
	<dd>一个服务只是Angular中的一个类，直到您使用Angular dependency注入器注册它</dd>
	<dd>Angular在执行应用程序时为您创建注入器，从引导过程中创建的根注入器开始</dd>
	<dd>在注射器可以创建该服务之前，您必须向注射器注册注射器</dd>
	<dd>提供者告诉注射器如何创建服务</dd>
	<dd>没有提供者，注入者不知道它是负责注入服务，也不能创建服务</dd>

	<dt>实例</dt>

	<dd>@Component providers</dd>
	<pre>
		import &#123; Component &#125; from '@angular/core';
		import &#123; HeroService &#125; from './hero.service';

		@Component(&#123;
		selector: 'app-heroes',
		providers: [ HeroService ],
		template: `
			<h2>Heroes</h2>
			&#60;app-hero-list&#62;&#60;/app-hero-list&#62;
		`
		&#125;)
		export class HeroesComponent &#123; &#125;
	</pre>

	<dd>@NgModule providers</dd>
	<pre>
		providers: [
			UserService,
			&#123; provide: APP_CONFIG, useValue: HERO_DI_CONFIG &#125;
		],
	</pre>

	<dt>比较描述</dt>
	<dd>@Component注入相对于@NgModule注入优先级更高 类似于css中的style位置</dd>
	<dd>确切地说，除非模块被延迟加载，否则Angular模块提供程序将在根注入器中注册</dd>
	<dd>请注意，组件提供的服务可能具有有限的生命周期</dd>
	<dd>组件的每个新实例都获得自己的服务实例，当组件实例被销毁时，该服务实例也是如此</dd>
	<pre>
		constructor(heroService: HeroService)
	</pre>

	<h4>Singleton services</h4>
	<dt>描述</dt>
	<dd>服务在注入器范围内是单例的</dd>
	<dd>在给定的注射器中最多只有一个服务实例。</dd>
	<dd>只有一个根注射器，用户服务注册到该注射器。</dd>
	<dd>因此，整个应用程序中只能有一个UserService实例，并且每个注入UserService的类都将获得此服务实例。</dd>
	<dd>
		然而，Angular DI是一个分层注入系统，这意味着嵌套的注入器可以创建自己的服务实例。
	</dd>

	<h4>Component child injectors</h4>
	<dt>描述</dt>
	<dd>
		当Angular创建一个具有@Component.providers的组件的新实例时，它也为该实例创建一个新的子注入器。
	</dd>
	<dd>
		组件注入器是相互独立的，每个组件都创建它自己的组件提供服务的实例。
	</dd>
	<dd>
		当Angular销毁其中一个组件实例时，它也会销毁组件的注入器和注入器的服务实例。
	</dd>
	<dd>
		由于注入器继承，您仍然可以将应用程序范围的服务注入到这些组件中。
		组件的注入器是其父组件的注入器的子组件，并且是其父组件的注入器的后代，等等一直回到应用程序的根注入器。
	</dd>

	<h4>When the service needs a service</h4>
	<dt>解决方法</dt>
	<dd>@Injectable()</dd>

	<h4>@Injectable()</h4>
	<dt>描述</dt>
	<dd>@Injectable（）装饰器标识可能需要注入依赖的服务类ye</dd>
	<dt>总是用圆括号写@Injectable（），而不仅仅是@Injectable。</dt>
	<dd>
		当Angular创建一个构造函数具有参数的类时，
		它会查找有关这些参数的类型和注入元数据，以便它可以注入正确的服务。
	</dd>

	<h5>装饰器的由来</h5>
	<dt>描述</dt>
	<dd>装饰器的要求是由TypeScript强加的。</dd>
	<dd>当它将代码转换成JavaScript时，TypeScript通常会丢弃参数类型信息。</dd>
	<dd>
		如果类有一个装饰器，
		并且在TypeScript的tsconfig.json配置文件中将emitDecoratorMetadata编译器选项设置为true，
		它会保留这些信息。
	</dd>
	<dd>@Injectable（）装饰器进行注释，不管它是否具有构造函数和依赖关系。</dd>
	<dd>@Injectable（）是服务所需的编码风格。</dd>
	<dd>实际上是使用具有两个属性的提供者对象字面值的提供者注册的简写表达式</dd>
	<pre>
		providers: [Logger]
		[&#123; provide: Logger, useClass: Logger &#125;]
	</pre>
	<dt>替代提供者</dt>
	<dd>
		[&#123; provide: Logger, useClass: BetterLogger &#125;]
	</dd>

	<h4>Aliased(别名) class providers</h4>
	<dt>
		[&#123; provide: OldLogger, useClass: NewLogger&#125;]
	</dt>
	<dd>并不是别名而会实例化俩个class, 分别是NewLogger以及作为OldLogger名称的NewLogger</dd>

	<dt>
		[&#123; provide: OldLogger, useExisting: NewLogger&#125;]
	</dt>
	<dd>仅以别名的方式实例化一个NewLogger作为OldLogger的providers</dd>

	<h4>Value providers</h4>
	<dt>
		[&#123; provide: Logger, useValue: silentLogger &#125;]
	</dt>
	<dd>
		初始化注入器的值（我猜的）
	</dd>

	<h4>Factory providers</h4>
	<dt>描述</dt>
	<dd>
		需要动态地创建依赖的值
		也许信息在浏览器会话过程中反复改变
	</dd>
	<dd>
		假设注射服务没有独立访问这些信息的来源
	</dd>
	<dd>
		处理服务与服务之间依赖的干涉和影响
	</dd>

	<pre>
		let heroServiceFactory = (logger: Logger, userService: UserService) => &#123;
			return new HeroService(logger, userService.user.isAuthorized);
		&#125;
		export let heroServiceProvider =
		&#123; 	provide: HeroService,
		  	useFactory: heroServiceFactory,
		  	deps: [Logger, UserService]
		&#125;;
	</pre>
	<dt>描述</dt>
	<dd>useFactory字段告诉Angular提供者是一个工厂函数，其实现是heroServiceFactory</dd>
	<dd>deps属性是提供者令牌的数组。</dd>
	<dd>
		Logger和UserService类用作其自己的类提供程序的标记。
		将相应的服务注入匹配的工厂功能参数
	</dd>

	<h4>Dependency injection tokens</h4>
	<dt>描述</dt>
	<dd>
		当您使用注入器注册提供者时，您将该提供者与依赖注入令牌相关联。
	</dd>
	<dd>注入器维护一个内部的令牌提供者映射，当它被要求依赖的时候它会引用它</dd>
	<dd>令牌是地图的关键</dd>

	<dt>heroService: HeroService;</dt>
	<dd>通过提供HeroService类型作为令牌直接从注入器获得HeroService</dd>

	<dt>constructor(heroService: HeroService)</dt>
	<dd>使用HeroService类类型定义构造函数参数时，Angular知道注入与该HeroService类令牌关联的服务</dd>

	<h4>Non-class dependencies</h4>
	<dt>描述</dt>
	<dd>有时要注入的是一个字符串，函数或对象</dd>
	<pre>
		export const HERO_DI_CONFIG: AppConfig = &#123;
			apiEndpoint: 'api.heroes.com',
			title: 'Dependency Injection'
		&#125;;
	</pre>
	<dd>TypeScript接口不是有效的令牌</dd>
	<dt>
		[&#123; provide: AppConfig, useValue: HERO_DI_CONFIG &#125;]
	</dt>
	<dd>不能使用接口作为提供者令牌</dd>
	<dt>
		constructor(private config: AppConfig)&#123; &#125;
	</dt>
	<dd>不能使用接口作为参数类型注入</dd>
	<dd>习惯于强类型语言中的依赖注入，其中接口是首选的依赖关系查找键</dd>
	<dd>
		JavaScript没有接口。
		TypeScript接口从生成的JavaScript中消失
	</dd>

	<h4>Injection Token</h4>
	<dt>描述</dt>
	<dd>为非类依赖关系选择提供者标记的一个解决方案是定义和使用一个InjectionToken</dd>
	<dt>实例</dt>
	<pre>
		import &#123; InjectionToken &#125; from '@angular/core';

		export const APP_CONFIG = new InjectionToken&#60;AppConfig&#62;('app.config');
	</pre>
	<dt>描述</dt>
	<dd>
		类型参数（可选）将依赖类型传递给开发人员和工具
	</dd>
	<dd>
		使用InjectionToken对象注册依赖项提供程序
	</dd>
	<dt>使用非class的依赖注入</dt>
	<pre>
		providers: [&#123; provide: APP_CONFIG, useValue: HERO_DI_CONFIG &#125;]
	</pre>
	<dd>可以通过@Inject装饰器将配置对象注入到任何需要它的构造器中</dd>
	<pre>
		constructor(@Inject(APP_CONFIG) config: AppConfig) &#123;
			this.title = config.title;
		&#125;
	</pre>
	<dt>描述</dt>
	<dd>尽管AppConfig接口在依赖注入中没有任何作用，但它支持在类中输入配置对象</dd>
	<dd>可以在像AppModule这样的ngModule中提供并注入配置对象</dd>
	<pre>
		providers: [
			UserService,
			&#123; provide: APP_CONFIG, useValue: HERO_DI_CONFIG &#125;
		]
	</pre>

	<h4>Optional(可选) dependencies</h4>
	<dt>描述</dt>
	<dd>可以通过使用@Optional（）注释构造函数参数来告诉Angular依赖关系是可选的</dd>
	<pre>
		import &#123; Optional &#125; from '@angular/core';

		constructor(@Optional() private logger: Logger) &#123;
			if (this.logger) &#123;
			  this.logger.log(some_message);
			&#125;
		&#125;
	</pre>
	<dd>当使用@Optional（）时，代码必须为空值准备</dd>

	<h3>总结</h3>
	<h4>Appendix: Working with injectors directly</h4>
	<p>官网的这个例子要经常看</p>
	<a href="https://angular.io/guide/dependency-injection#injectable">
		angular 依赖注入的层级例子
	</a>
</div>