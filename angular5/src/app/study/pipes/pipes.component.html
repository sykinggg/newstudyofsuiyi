<h1 class="text-center">Pipes</h1>
<dt>描述</dt>
<dd>每个应用程序都是以一个简单的任务开始的：获取数据，转换它们，并将它们展示给用户</dd>
<dd>获取数据可以像创建一个局部变量一样简单，或者像通过websocket传输数据一样复杂</dd>
<dd>一旦数据到达，可以直接将其原始的tostring值推送到视图，但是这很少提供良好的用户体验</dd>
<dd>
    在大多数情况下，用户更喜欢用像1988年4月15日那样的简单格式来查看日期， 而不是原始字符串格式fri apr 15 1988 00:00:00 gmt-0700（太平洋白昼时间）
</dd>
<dd>需要在许多应用程序内部和之间反复进行许多相同的转换</dd>
<a href="{{onLineHref}}" target="{{targetType}}">在线实例</a>
<span>&#166;</span>
<a href="{{downloadHref}}" target="{{targetType}}">实例下载</a>

<h2>Using pipes</h2>
<dt>描述</dt>
<dd>过滤器将数据作为输入并将其转换为所需的输出</dd>

<pre>
    src/app/hero-birthday1.component.ts

    import &#123; Component &#125; from '@angular/core';
    
    @Component(&#123;
        selector: 'app-hero-birthday',
        template: `&#60;p>The hero's birthday is &#123; &#123; birthday &#166; date &#125; &#125;&#60;/p>`
    &#125;)
    export class HeroBirthdayComponent &#123;
        birthday = new Date(1988, 3, 15); // April 15, 1988
    &#125;

    组件的模板

    src/app/app.component.html

    &#60;p>The hero's birthday is &#123; &#123; birthday &#166; date &#125; &#125; &#60;/p>
</pre>
<dt>描述</dt>
<dd>在插值表达式中，通过过滤器运算符（&#166;）将组件的生日值传递给右侧的日期过滤器函数。</dd>
<dd>所有过滤器都是这样工作的</dd>

<h2>Built-in pipes</h2>
<dt>描述</dt>
<dd>DatePipe, UpperCasePipe, LowerCasePipe, CurrencyPipe, and PercentPipe</dd>

<h2>Parameterizing a pipe(参数化)</h2>
<dt>描述</dt>
<dd>过滤器可以接受任意数量的可选参数来微调其输出</dd>
<dd>要将参数添加到过滤器，请使用冒号（：）跟随过滤器名称，然后使用参数值（如currency：'eur'）</dd>
<dd>如果过滤器接受多个参数，请使用冒号分隔这些值（如slice：1：5）修改生日模板给日期过滤器一个格式参数</dd>
<pre>
    src/app/app.component.html

    &#60;p>The hero's birthday is &#123; &#123; birthday &#166; date:"MM/dd/yy" &#125; &#125; &#60;/p>
</pre>
<dt>描述</dt>
<dd>参数值可以是任何有效的模板表达式</dd>
<dd>例如字符串文字或组件属性</dd>
<dd>可以通过绑定来控制格式，就像通过绑定来控制生日值一样</dd>
<pre>
    src/app/hero-birthday2.component.ts (template)

    template: `
    &#60;p>The hero's birthday is &#123; &#123; birthday &#166; date:format &#125; &#125; &#60;/p>
    &#60;button (click)="toggleFormat()">Toggle Format&#60;/button>
    `
</pre>
<dt>描述</dt>
<dd>向模板添加了一个按钮，并将其单击事件绑定到组件的toggleformat（）方法。</dd>
<dd>该方法在短格式（“shortdate”）和较长格式（“fulldate”）之间切换组件的格式属性</dd>
<pre>
    src/app/hero-birthday2.component.ts (class)

    export class HeroBirthday2Component &#123;
        birthday = new Date(1988, 3, 15); // April 15, 1988
        toggle = true; // start with true == shortDate
        
        get format()   &#123; return this.toggle ? 'shortDate' : 'fullDate'; &#125;
        toggleFormat() &#123; this.toggle = !this.toggle; &#125;
    &#125;
</pre>

<h2>Chaining pipes(链接)</h2>
<dt>可以将过滤器链接在一起进行有用的组合</dt>
<pre>
    The chained hero's birthday is
    &#123; &#123; birthday &#166; date &#166; uppercase &#125; &#125;

    The chained hero's birthday is
    &#123; &#123; birthday &#166; date:'fullDate' &#166; uppercase &#125; &#125;
</pre>

<h2>Custom pipes</h2>
<dt>可以编写自己的自定义过滤器</dt>
<pre>
    import &#123; Pipe, PipeTransform &#125; from '@angular/core';
    /*
     * Raise the value exponentially
     * Takes an exponent argument that defaults to 1.
     * Usage:
     *   value &#166; exponentialStrength:exponent
     * Example:
     *   &#123; &#123; 2 &#166; exponentialStrength:10 &#125; &#125;
     *   formats to: 1024
    */
    @Pipe(&#123;name: 'exponentialStrength'&#125;)
    export class ExponentialStrengthPipe implements PipeTransform &#123;
        transform(value: number, exponent: string): number &#123;
            let exp = parseFloat(exponent);
            return Math.pow(value, isNaN(exp) ? 1 : exp);
        &#125;
    &#125;
</pre>
<dt>关键点</dt>
<ul>
    <li>过滤器是用过滤器元数据装饰的类</li>
    <li>pipe类实现了pipetransform接口的transform方法，该方法接受一个输入值，后跟可选参数，并返回转换后的值</li>
    <li>对于传递给过滤器的每个参数，将有一个额外的变量方法参数。你的过滤器有一个这样的参数：name。</li>
    <li>告诉angular这是一个过滤器，你应用@Pipe装饰器，从核心angular库导入。</li>
    <li>@Pipe修饰器允许你定义在模板表达式中使用的过滤器名称</li>
</ul>

<h4>The PipeTransform interface</h4>
<dd>变换方法对于过滤器是必不可少的。pipetransform接口定义了该方法</dd>

<pre>
    import &#123; Component &#125; from '@angular/core';
    
    @Component(&#123;
      selector: 'app-power-booster',
      template: `
        <h2>Power Booster</h2>
        <p>Super power boost: &#123; &#123; 2 &#166; exponentialStrength: 10 &#125; &#125;</p>
      `
    &#125;)
    export class PowerBoosterComponent &#123; &#125;
</pre>
<img src="https://angular.io/generated/images/guide/pipes/power-boost-calculator-anim.gif" alt="">
<dt>注意:</dt>
<ul>
    <li>可以像使用内置过滤器一样使用自定义过滤器</li>
    <li>必须将过滤器包含在appmodule的声明数组中</li>
</ul>
<dd>必须注册自定义过滤器。如果不这样做，angular报告一个错误。angular cli的发生器自动注册过滤器</dd>

<h2>Power Boost Calculator</h2>
<dt>描述</dt>
<dd>更新模板来测试自定义过滤器没有多大的意义</dd>

<pre>
    import &#123; Component &#125; from '@angular/core';
    
    @Component(&#123;
        selector: 'app-power-boost-calculator',
        template: `
        &#60;h2>Power Boost Calculator&#60;/h2>
        &#60;div>Normal power: &#60;input [(ngModel)]="power">&#60;/div>
        &#60;div>Boost factor: &#60;input [(ngModel)]="factor">&#60;/div>
        &#60;p>
            Super Hero Power: &#123; &#123; power &#166; exponentialStrength: factor &#125; &#125;
        &#60;/p>
        `
    &#125;)
    export class PowerBoostCalculatorComponent &#123;
        power = 5;
        factor = 1;
    &#125;
</pre>

<h2>Pipes and change detection(检测)</h2>
<dt>描述</dt>
<dd>angular通过在每个dom事件之后运行的更改检测过程查找数据绑定值的更改：每次按键，鼠标移动，计时器滴答和服务器响应。</dd>

<h4>No pipe</h4>
<dd>组件使用默认的主动变化检测策略来监视和更新数据阵列中每个数据的显示</dd>

<pre>
    src/app/flying-heroes.component.html (v1)

    New hero:
    &#60;input type="text" #box
            (keyup.enter)="addHero(box.value); box.value=''"
            placeholder="hero name">
    &#60;button (click)="reset()">Reset&#60;/button>
    &#60;div *ngFor="let hero of heroes">
        &#123; &#123; hero.name &#125; &#125;
    &#60;/div>

    伴随组件类提供数据，将数据添加到数组中，并可以重置数组

    src/app/flying-heroes.component.ts (v1)

    export class FlyingHeroesComponent &#123;
        heroes: any[] = [];
        canFly = true;
        constructor() &#123; this.reset(); &#125;
        
        addHero(name: string) &#123;
            name = name.trim();
            if (!name) &#123; return; &#125;
            let hero = &#123;name, canFly: this.canFly &#125;;
            this.heroes.push(hero);
        &#125;
        
        reset() &#123; this.heroes = HEROES.slice(); &#125;
    &#125;
</pre>
<dt>描述</dt>
<dd>可以添加数据和angular度更新显示</dd>
<dd>
    如果点击重置按钮，angular将用一个新的数据阵列替换数据并更新显示。 如果添加了移除或改变数据的能力，angular将会检测到这些改变并更新显示。
</dd>

<h4>FlyingHeroesPipe(对于组建的优化)</h4>
<dt>描述</dt>
<dd>添加一个flyingheroespipe到* ngfor转发器，将数据列表过滤到有改变的数据。</dd>

<pre>
    src/app/flying-heroes.component.html (flyers)

    &#60;div *ngFor="let hero of (heroes &#166; flyingHeroes)">
        &#123; &#123; hero.name &#125; &#125;
    &#60;/div>

    flyingheroespipe实现

    src/app/flying-heroes.pipe.ts

    import &#123; Pipe, PipeTransform &#125; from '@angular/core';
    
    import &#123; Flyer &#125; from './heroes';
    
    @Pipe(&#123; name: 'flyingHeroes' &#125;)
    export class FlyingHeroesPipe implements PipeTransform &#123;
        transform(allHeroes: Flyer[]) &#123;
            return allHeroes.filter(hero => hero.canFly);
        &#125;
    &#125;
</pre>
<dt>描述</dt>
<dd>使用不同的变更检测算法，忽略对列表或其任何项目的更改。</dd>
<dd>你添加数据到数据阵列。对数组的引用没有改变。这是相同的数组。这是所有的angular度关心。</dd>
<dd>从它的angular度看，相同的阵列，没有改变，没有显示更新。</dd>
<dd>解决这个问题，创建一个新的数据附加并分配给数据阵列。</dd>
<dd>这次angular度检测到数组引用已经改变。它会执行过滤器，并使用包含新改变数据的新阵列更新显示。</dd>
<dd>如果你改变数组，不调用过滤器，显示不更新;</dd>
<dd>如果替换数组，过滤器将执行并更新显示</dd>
<img src="https://angular.io/generated/images/guide/pipes/flying-heroes-anim.gif">

<h2>Pure and impure pipes</h2>
<dt>描述</dt>
<dd>通过将其设置为false来使过滤器不纯。</dd>
<pre>
    @Pipe(&#123;
        name: 'flyingHeroesImpure',
        pure: false
    &#125;)
</pre>

<h4>Pure pipes</h4>
<dt>描述</dt>
<dd>angular只有在检测到输入值的纯粹变化时才会执行纯过滤器</dd>
<dd>
    一个纯粹的改变是改变原始输入值 （字符串，数字，布尔，符号） 或改变的对象引用（日期，数组，函数，对象）
</dd>
<dd>
    angular忽略（复合）对象内的更改。 如果您更改输入月份，添加到输入数组或更新输入对象属性，它将不会调用纯过滤器。
</dd>
<dd>这可能看起来很严格，但速度也很快</dd>
<dd>对象引用检查的速度比深入检查差异要快得多，因此angular可以快速确定是否可以跳过过滤器执行和视图更新。</dd>
<dd>
    出于这个原因，当你能够接受变化检测策略的时候，一个纯粹的过滤器是最好的。 当你不能，你可以使用不纯的过滤器。
</dd>

<h4>Impure pipes</h4>
<dt>描述</dt>
<dd>angular在每个元件更换检测周期执行不纯过滤器</dd>
<dd>经常调用不纯的过滤器，就像每次按键或鼠标移动一样</dd>

<pre>
    FlyingHeroesImpurePipe

    @Pipe(&#123;
        name: 'flyingHeroesImpure',
        pure: false
    &#125;)
    export class FlyingHeroesImpurePipe extends FlyingHeroesPipe &#123;&#125;

    FlyingHeroesPipe

    import &#123; Pipe, PipeTransform &#125; from '@angular/core';
    
    import &#123; Flyer &#125; from './heroes';
    
    @Pipe(&#123; name: 'flyingHeroes' &#125;)
    export class FlyingHeroesPipe implements PipeTransform &#123;
        transform(allHeroes: Flyer[]) &#123;
            return allHeroes.filter(hero => hero.canFly);
        &#125;
    &#125;
</pre>
<dt>描述</dt>
<dd>对于不纯的过滤器来说这是一个很好的选择，因为这个转换函数是快速的</dd>

<h4>The impure AsyncPipe</h4>
<dt>描述</dt>
<dd>angular异步过滤器是不纯过滤器的一个有趣的例子</dd>
<dd>asyncpipe接受promise或observable作为输入并自动订阅输入，最终返回发出的值。</dd>
<dd>
    asyncpipe也是有状态的。 过滤器维护一个订阅输入的observable，并在它们到达时继续从这个observable传递值。
</dd>
<pre>
    import &#123; Component &#125; from '@angular/core';
    
    import &#123; Observable &#125; from 'rxjs/Observable';
    import 'rxjs/add/observable/interval';
    import 'rxjs/add/operator/map';
    import 'rxjs/add/operator/take';
    
    @Component(&#123;
        selector: 'app-hero-message',
        template: `
        &#60;h2>Async Hero Message and AsyncPipe&#60;/h2>
        &#60;p>Message: &#123; &#123; message$ &#166; async &#125; &#125;&#60;/p>
        &#60;button (click)="resend()">Resend&#60;/button>`,
    })
    export class HeroAsyncMessageComponent &#123;
        message$: Observable&#60;string>;
    
        private messages = [
        'You are my hero!',
        'You are the best hero!',
        'Will you be my hero?'
        ];
    
        constructor() &#123; this.resend(); &#125;
    
        resend() &#123;
            this.message$ = Observable.interval(500)
                .map(i => this.messages[i])
                .take(this.messages.length);
        &#125;
    &#125;
</pre>
<dt>描述</dt>
<dd>异步过滤器将组件代码中的样板文件保存起来</dd>
<dd>
    该组件不必订阅异步数据源，提取已解析的值并将其公开以进行绑定， 并且必须在其销毁时取消订阅（内存泄漏的有效来源）。
</dd>

<h4>An impure caching pipe(一个不纯的缓存过滤器)</h4>
<dt>描述</dt>
<dd>一个不纯的过滤器，一个做http请求的过滤器。</dd>
<dd>在下面的代码中，过滤器只会在请求url更改时调用服务器，并缓存服务器响应。</dd>
<dd>该代码使用angular http客户端来检索数据</dd>
<pre>
    import &#123; Pipe, PipeTransform &#125; from '@angular/core';
    import &#123; Http &#125;                from '@angular/http';
    
    import 'rxjs/add/operator/map';
    
    @Pipe(&#123;
        name: 'fetch',
        pure: false
    &#125;)
    export class FetchJsonPipe  implements PipeTransform &#123;
        private cachedData: any = null;
        private cachedUrl = '';
    
        constructor(private http: Http) &#123; &#125;
    
        transform(url: string): any &#123;
        if (url !== this.cachedUrl) &#123;
            this.cachedData = null;
            this.cachedUrl = url;
            this.http.get(url)
            .map( result => result.json() )
            .subscribe( result => this.cachedData = result );
        &#125;
    
        return this.cachedData;
        &#125;
    &#125;

    hero-list.component.ts

    import &#123; Component &#125; from '@angular/core';
    
    @Component(&#123;
      selector: 'app-hero-list',
      template: `
        &#60;h2>Heroes from JSON File&#60;/h2>
    
        &#60;div *ngFor="let hero of ('assets/heroes.json' &#166; fetch) ">
            &#123; &#123;hero.name &#125; &#125;
        &#60;/div>
    
        &#60;p>Heroes as JSON:
            &#123; &#123;'assets/heroes.json' &#166; fetch &#166; json &#125; &#125;
        &#60;/p>`
    &#125;)
    export class HeroListComponent &#123; &#125;
</pre>
<img src="https://angular.io/generated/images/guide/pipes/hero-list.png">
<dt>过滤器的数据请求上的断点显示以下内容</dt>
<ul>
    <li>每个绑定都有自己的过滤器实例</li>
    <li>每个过滤器实例缓存自己的url和数据</li>
    <li>每个过滤器实例只调用一次服务器</li>
</ul>

<h4>JsonPipe</h4>
<dt>描述</dt>
<dd>通过链接到内置的jsonpipe以json格式显示相同的英雄数据</dd>
<dd>jsonpipe提供了一种简单的方法来诊断一个神秘失败的数据绑定或检查未来绑定的对象。</dd>

<h4>Pure pipes and pure functions</h4>
<dt>描述</dt>
<dd>纯净的过滤器使用纯粹的功能</dd>
<dd>纯函数处理输入和返回值，没有可检测的副作用</dd>
<dd>给定相同的输入，他们应该总是返回相同的输出</dd>
<dd>内置的日期管是纯粹的功能实现的纯过滤器</dd>

<dd>过滤器是封装和共享常见的显示值转换的好方法</dd>
<dd>像样式一样使用它们，将它们放到模板表达式中，以丰富视图的吸引力和可用性</dd>

<h4>Appendix: No FilterPipe or OrderByPipe</h4>
<dt>描述</dt>
<dd>angular不提供用于过滤或排序列表的过滤器</dd>
<dd>熟悉angularjs的开发者知道这些是过滤器和orderby</dd>
<dd>filter和orderby都需要引用对象属性的参数</dd>
<dd>angular调用几乎在每个变化检测周期都不纯</dd>
<dd>过滤和特别是分类是昂贵的操作</dd>
<dd>过滤器和orderby经常被滥用在angularjs应用程序，导致抱怨angular本身是缓慢的</dd>
<pre>
    &#60;div *ngFor="let hero of heroes | orderBy:'name,planet'">&#60;/div>
</pre>
<dt>描述</dt>
<dd>通过文本字符串来识别排序字段，期望过滤器通过索引（例如hero ['name']）引用属性值</dd>