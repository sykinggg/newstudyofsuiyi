<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
	</head>
	<body>
		<h1>关键</h1>
		<ul>
			<li>
				<h2>Namespace 命名空间</h2>
				<p>允许开发人员在一个独特, 应用相关的名字的名称下捆绑所有功能的容器</p>
			</li>
			<li>
				<h2>Class 类</h2>
				<p>定义对象的特征。它是对象的属性和方法的模板定义</p>
			</li>
			<li>
				<h2>Object 对象</h2>
				<p>类的一个实例</p>
			</li>
			<li>
				<h2>Property 属性</h2>
				<p>对象的特征，比如颜色</p>
			</li>
			<li>
				<h2>Method 方法</h2>
				<p>对象的能力，比如行走</p>
			</li>
			<li>
				<h2>Constructor 构造函数</h2>
				<p>对象初始化的瞬间, 被调用的方法. 通常它的名字与包含它的类一致</p>
			</li>
			<li>
				<h2>Inheritance 继承</h2>
				<p>一个类可以继承另一个类的特征</p>
			</li>
			<li>
				<h2>Encapsulation 封装</h2>
				<p>一种把数据和相关的方法绑定在一起使用的方法</p>
			</li>
			<li>
				<h2>Abstraction 抽象</h2>
				<p>结合复杂的继承，方法，属性的对象能够模拟现实的模型</p>
			</li>
			<li>
				<h2>Polymorphism 多态</h2>
				<p>多意为‘许多’，态意为‘形态’。不同类可以定义相同的方法或属性</p>
			</li>
		</ul>










		<h1>JavaScript面向对象编程</h1>
		<h2>命名空间</h2>
		<p>在JavaScript中，命名空间只是另一个包含方法，属性，对象的对象</p>
		<script>
			// 全局命名空间
			var MYAPP = MYAPP || {};
		</script>
		<script>
			// 子命名空间
			MYAPP.event = {};
		</script>
		<script>
			/*用于创建命名空间和添加变量，函数和方法的代码写法*/
			// 给普通方法和属性创建一个叫做MYAPP.commonMethod的容器
			MYAPP.commonMethod = {
				regExForName: "", // 定义名字的正则验证
				regExForPhone: "", // 定义电话的正则验证
				validateName: function(name){
					// 对名字name做些操作，你可以通过使用“this.regExForname”
					// 访问regExForName变量
				},

				validatePhoneNo: function(phoneNo){
					// 对电话号码做操作
				}
			}

			// 对象和方法一起申明
			MYAPP.event = {
				addListener: function(el, type, fn) {
					//  代码
				},
				removeListener: function(el, type, fn) {
					// 代码
				},
				getEvent: function(e) {
					// 代码
				}

				// 还可以添加其他的属性和方法
			}

			//使用addListner方法的写法:
			MYAPP.event.addListener("yourel", "type", callback);
		</script>

		<h2>标准内置对象</h2>
		<p>JavaScript有包括在其核心的几个对象，例如，Math，Object，Array和String对象</p>
		<script>
			/*用Math对象的random()方法来获得一个随机数*/
			console.log(Math.random());
		</script>










		<h1>自定义对象</h1>

		<h2>类</h2>
		<p>JavaScript可用方法作类。定义一个类跟定义一个函数一样简单</p>
		<script>
			function Person() { }
			/*或者*/
			var Person = function() {  }
		</script>

		<h2>对象（类的实例）</h2>
		<p>使用 new obj 创建对象 obj 的新实例, 将结果（obj 类型）赋值给一个变量方便稍后调用</p>
		<script>
			function Person() {   }
			var person1 = new Person();
			var person2 = new Person();
		</script>

		<h2>构造器</h2>
		<p>实例化时构造器被调用 (也就是对象实例被创建时)。构造器是对象中的一个方法</p>
		<p>在JavaScript,中函数就可以作为构造器使用,因此不需要特别地定义一个构造器方法</p>
		<p>每个声明的函数都可以在实例化后被调用执行</p>
		<h3>注意</h3>
		<p>构造器常用于给对象的属性赋值或者为调用函数做准备</p>
		<script>
			/*Person类实例化时构造器调用一个 alert函数*/

			function Person() {
				alert("Person instantiated");
			}

			var person1 = new Person();
			var person2 = new Person();
		</script>

		<h2>属性 (对象属性)</h2>
		<p>属性就是 类中包含的变量;每一个对象实例有若干个属性</p>
		<p>为了正确的继承，属性应该被定义在类的原型属性 (函数)中</p>
		<h3>注意</h3>
		<p>可以使用 关键字 this调用类中的属性, this是对当前对象的引用</p>
		<script>
			function Person(firstName) {
				this.firstName = firstName;
				alert("person instantiated");
			}

			var person1 = new Person("Alice");
			var person2 = new Person("Bob");

			alert("person1 is" + person1.firstName);
			alert("person2 is" + person2.firstName);
		</script>

		<h2>方法（对象属性）</h2>
		<p>方法与属性很相似， 不同的是：一个是函数，另一个可以被定义为函数</p>
		<p>调用方法很像存取一个属性,  不同的是add () 在方法名后面很可能带着参数</p>
		<p>为定义一个方法, 需要将一个函数赋值给类的 prototype 属性</p>
		<p>这个赋值给函数的名称就是用来给对象在外部调用它使用的</p>
		<script>
			function Person(firstName) {
				this.firstName = firstName;
			}

			Person.prototype.sayHello = function() {
				alert("Hello, I`m" + this.firstName);
			};

			var person1 = new Person("Alice");
			var person2 = new Person("Bob");

			/*call the Person sayHello method*/
			person1.sayHello();
			person2.sayHello();
		</script>

		<p>在JavaScript中方法通常是一个绑定到对象中的普通函数, 这意味着方法可以在其所在context之外被调用</p>

		<script>
			function Person(firstName) {
				this.firstName = firstName;
			}

			Person.prototype.sayHello = function() {
				console.log("Hello, I`m" + this.firstName);
			};

			var person1 = new Person("Alice");
			var person2 = new Person("Bob");
			var helloFunction = person1.sayHello;

			person1.sayHello();
			/*Hello, I`mAlice*/
			person2.sayHello();
			/*Hello, I`mBob*/
			helloFunction();
			/*Hello, I`mundefined*/

			console.log(helloFunction === person1.sayHello);
			/*true*/
			console.log(helloFunction === Person.prototype.sayHello);
			/*true*/
			helloFunction.call(person1);
			/*Hello, I`mAlice*/
		</script>
		<h3>代码描述:</h3>
		<p>所有指向sayHello函数的引用 ，包括 person1, Person.prototype, 和 helloFunction 等， 均引用了相同的函数</p>

		<h3>注意:</h3>
		<p>在调用函数的过程中，this的值取决于我们怎么样调用函数</p>
		<p>我们通过一个表达式person1.sayHello()来调用函数</p>
		<span>即从一个对象的属性中得到所调用的函数</span>
		<p>此时this被设置为我们取得函数的对象（即person1）</p>
		<p>这就是为什么person1.sayHello() 使用了姓名“Alice”而person2.sayHello()使用了姓名“bob”的原因</p>



		<p>然而我们使用不同的调用方法时, this的值也就不同了</p>
		<p>当从变量 helloFunction()中调用的时候， this就被设置成了全局对象 (在浏览器中即window)</p>
		<p>由于该对象 (非常可能地) 没有firstName 属性, 我们得到的结果便是"Hello, I'm undefined"</p>
		<span>(这是松散模式下的结果， 在 严格模式中，结果将不同（此时会产生一个error）</span>

		<h2>继承</h2>
		<p>创建一个或多个类的专门版本类方式称为继承（Javascript只支持单继承）</p>
		<p>创建的专门版本的类通常叫做子类，另外的类通常叫做父类</p>
		<p>在Javascript中，继承通过赋予子类一个父类的实例并专门化子类来实现</p>
		<p>在现代浏览器中你可以使用 Object.create 实现继承</p>

		<h3>注意:</h3>
		<p>JavaScript 并不检测子类的 prototype.constructor, 所以我们必须手动申明它</p>
		<p>定义了 Student类作为 Person类的子类. 之后我们重定义了sayHello() 方法并添加了 sayGoodBye() 方法</p>
		<script>
			// 定义Person构造器
			function Person(firstName) {
				this.firstName = firstName;
			}

			// 在Person.prototype中加入方法
			Person.prototype.walk = function(){
				console.log("I am walking!");
			};
			Person.prototype.sayHello = function(){
				alert("Hello, I'm " + this.firstName);
			};

			// 定义Student构造器
			function Student(firstName, subject) {
				// 调用父类构造器, 确保(使用Function#call)"this" 在调用过程中设置正确
				Person.call(this, firstName);

				// 初始化Student类特有属性
				this.subject = subject;
			};

			// 建立一个由Person.prototype继承而来的Student.prototype对象.
			// 注意: 常见的错误是使用 "new Person()"来建立Student.prototype.
			// 这样做的错误之处有很多, 最重要的一点是我们在实例化时
			// 不能赋予Person类任何的FirstName参数
			// 调用Person的正确位置如下，我们从Student中来调用它
			Student.prototype = Object.create(Person.prototype); // See note below

			// 设置"constructor" 属性指向Student
			Student.prototype.constructor = Student;

			// 更换"sayHello" 方法
			Student.prototype.sayHello = function(){
				console.log("Hello, I'm " + this.firstName + ". I'm studying " + this.subject + ".");
			};

			// 加入"sayGoodBye" 方法
			Student.prototype.sayGoodBye = function(){
				console.log("Goodbye!");
			};

			// 测试实例:
			var student1 = new Student("Janet", "Applied Physics");
			student1.sayHello();   
			/*"Hello, I'm Janet. I'm studying Applied Physics."*/
			student1.walk();
			/*I am walking!*/
			student1.sayGoodBye(); 
			/*"Goodbye!"*/

			// Check that instanceof works correctly
			console.log(student1 instanceof Person);
			/*true*/
			console.log(student1 instanceof Student);
			/*true*/
		</script>

		<h2>封装</h2>
		<p>Student类虽然不需要知道Person类的walk()方法是如何实现的，但是仍然可以使用这个方法</p>
		<p>Student类不需要明确地定义这个方法，除非我们想改变它</p>
		<h2>封装，对于所有继承自父类的方法，只需要在子类中定义那些你想改变的即可</h2>

		<h2>抽象</h2>
		<p>抽象是允许模拟工作问题中通用部分的一种机制</p>
		<p>可以通过继承（具体化）或组合来实现</p>
		<p>JavaScript通过继承实现具体化，通过让类的实例是其他对象的属性值来实现组合</p>

		<p>JavaScript Function 类继承自Object类（这是典型的具体化）</p>
		<p>Function.prototype的属性是一个Object实例（这是典型的组合）</p>
		<script>
			var foo = function() {   };
			console.log('foo is a Function:' + (foo instanceof Function));
			/*foo is a Function:true*/
			console.log('foo.prototype is an Object:' + (foo.prototype instanceof Object));
			/*foo.prototype is an Object:true*/
		</script>

		<h2>多态</h2>
		<p>所有定义在原型属性内部的方法和属性一样，不同的类可以定义具有相同名称的方法</p>
		<p>方法是作用于所在的类中</p>
		<p>并且这仅在两个类不是父子关系时成立（继承链中，一个类不是继承自其他类）</p>
	</body>
</html>