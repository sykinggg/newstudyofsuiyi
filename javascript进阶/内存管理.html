<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<title>内存管理</title>
	</head>
	<body>
		<h1>内存管理</h1>
		<p>像 C 语言一样的低级语言拥有低级的内存管理基元，像malloc()，free()</p>

		<h2>垃圾回收机制</h2>
		<p>JavaScript 在变量（对象，字符串等等）创建时分配内存，然后在它们不再使用时“自动”释放</p>

		<h3>内存生命周期</h3>
		<ul>
			<li>分配你所需要的内存</li>
			<li>使用分配到的内存（读、写）</li>
			<li>不需要时将其释放\归还</li>
		</ul>
		<h3>描述</h3>
		<p>在所有语言中第一和第二部分都很清晰</p>
		<p>最后一步在低级语言中很清晰，但是在像JavaScript 等高级语言中，这一步是隐藏着的</p>










		<h1>JavaScript 的内存分配</h1>
		<p>值的初始化</p>
		<script>
			// 给数值变量分配内存
			var n = 123; 
			// 给字符串分配类型
			var s = "azerty"; 

			// 给对象及其包含的值分配内存
			var o = {
			  a: 1,
			  b: null
			}; 

			// 给数组及其包含的值分配内存（就像对象一样）
			var a = [1, null, "abra"]; 

			// 给函数（可调用的对象）分配内存
			function f(a){
			  return a + 2;
			} 

			// 函数表达式也能分配一个对象
			someElement.addEventListener('click', function(){
			  someElement.style.backgroundColor = 'blue';
			}, false);
		</script>
		<h3>描述,通过实例化一个对象赋值并给与内存空间</h3>

		<p>通过函数调用的内存分配</p>
		<script>
			var d = new Date();// 分配一个 Date 对象

			var e = document.createElement('div');// 分配一个 DOM 元素
		</script>

		<p>有些方法分配新变量或者新对象</p>
		<script>
			var s = "azerty";
			var s2 = s.substr(0, 3);// s2 是一个新的字符串
			// 因为字符串是不变量
			// JavaScript 可能没有分配内存
			// 但只是存储了 [0-3] 的范围

			var a = ["ouais ouais", "nan nan"];
			var a2 = ["generation", "nan nan"];
			var a3 = a.concat(a2);
			// 新数组有四个元素，是 a 连接 a2 的结果
		</script>


		<h2>值的使用</h2>
		<p>使用值的过程实际上是对分配内存进行读取与写入的操作</p>
		<p>读取与写入可能是写入一个变量或者一个对象的属性值，甚至传递函数的参数</p>


		<h2>当内存不再需要使用时释放</h2>
		<p>大多数内存管理的问题都在这个阶段</p>
		<p>在这里最艰难的任务是找到“所分配的内存确实已经不再需要了”</p>
		<p>开发人员来确定在程序中哪一块内存不再需要并且释放它</p>


		<h2>垃圾回收</h2>
		<p>因此，垃圾回收实现只能有限制的解决一般问题</p>


		<h2>引用</h2>
		<p>垃圾回收算法主要依赖于引用的概念</p>
		<p>在内存管理的环境中，一个对象如果有访问另一个对象的权限（隐式或者显式），叫做一个对象引用另一个对象</p>
		<h3>示例</h3>
		<p>一个Javascript对象具有对它 原型 的引用（隐式引用）和对它属性的引用（显式引用）</p>
		<h3>注意:补充说明</h3>
		<p>“对象”的概念不仅特指Javascript对象，还包括函数作用域（或者全局词法作用域）</p>



		<h2>引用计数垃圾收集</h2>
		<p>这是最简单的垃圾收集算法</p>
		<p>此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”</p>
		<p>如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收</p>

		<script>
			var o = {
				a: {
					b:2
				}
			};
			// 两个对象被创建，一个作为另一个的属性被引用，另一个被分配给变量o
			// 很显然，没有一个可以被垃圾收集

			var o2 = o;
			// o2变量是第二个对“这个对象”的引用

			o = 1;
			// 现在，“这个对象”的原始引用o被o2替换了

			var oa = o2.a;
			// 引用“这个对象”的a属性
			// 现在，“这个对象”有两个引用了，一个是o2，一个是oa

			o2 = "yo";
			// 最初的对象现在已经是零引用了
			// 他可以被垃圾回收了
			// 然而它的属性a的对象还在被oa引用，所以还不能回收

			oa = null;
			// a属性的那个对象现在也是零引用了
			// 它可以被垃圾回收了
		</script>
		<h3>缺点:限制：循环引用</h3>
		<p>如果一个对象引用另一个（形成了循环引用），他们可能“不再需要”了，但是他们不会被回收</p>
		<script>
			function f() {
				var o = {};
				var o2 = {};
				o.a = o2;// o 引用 o2
				o2.a = o;// o2 引用 o

				return "azerty";
			}

			f();
			console.log(f());
			// azerty
			// 两个对象被创建，并互相引用，形成了一个循环
			// 他们被调用之后不会离开函数作用域
			// 所以他们已经没有用了，可以被回收了
			// 然而，引用计数算法考虑到他们互相都有至少一次引用，所以他们不会被回收
		</script>


		<h3>实际例子</h3>
		<p>IE 6, 7 对DOM对象进行引用计数回收,一个常见问题就是内存泄露</p>
		<script>
			var div = document.createElement('div');
			div.onclick = function() {
				doSomething();
			};
			// div有了一个引用指向事件处理属性onclick
			// 事件处理也有一个对div的引用可以在函数作用域中被访问到
			// 这个循环引用会导致两个对象都不会被垃圾回收
		</script>



		<h2>标记-清除算法</h2>
		<p>这个算法把“对象是否不再需要”简化定义为“对象是否可以获得”</p>
		<h3>概念</h3>
		<p>这个算法假定设置一个叫做根的对象（在Javascript里，根是全局对象）</p>
		<p>定期的，垃圾回收器将从根开始，找所有从根开始引用的对象</p>
		<p>然后找这些对象引用的对象……从根开始，垃圾回收器将找到所有可以获得的对象和所有不能获得的对象</p>

		<p>这个算法比前一个要好，因为“有零引用的对象”总是不可获得的，但是相反却不一定，参考“循环引用”</p>
		<p>从2012年起，所有现代浏览器都使用了标记-清除垃圾回收算法</p>
	</body>
</html>