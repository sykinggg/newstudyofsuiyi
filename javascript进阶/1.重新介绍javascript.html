<!doctype html>
<html>
	<head>
		<meta charset="">
	</head>
	<body>
		<h1>概览</h1>
		<p>javascript中包含的类型</p>
		<ul>
			<li>Number（数字）</li>
			<li>String（字符串）</li>
			<li>Boolean（布尔）</li>
			<li>Symbol（符号）（第六版新增）</li>
			<li>
				Object（对象）
				<ul>
					<li>Function（函数）</li>
					<li>Array（数组）</li>
					<li>Date（日期）</li>
					<li>RegExp（正则表达式）</li>
				</ul>
			</li>
			<li>Null（空）</li>
			<li>Undefined（未定义）</li>
		</ul>
		<p>JavaScript 还有一种内置Error（错误）类型</p>










		<h1>数字</h1>
		<p>JavaScript 采用“IEEE 754 标准定义的双精度64位格式”（"double-precision 64-bit format IEEE 754 values"）表示数字</p>
		<p>JavaScript 不区分整数值和浮点数值</p>
		<script>
			// 0.1 + 0.2 = 0.3000000000004;
			/*Uncaught ReferenceError: Invalid left-hand side in assignment*/
			// 0.4 = 0.1 + 0.3;
			console.log(0.1 + 0.2);
			/*0.30000000000000004*/
		</script>
		<p>JavaScript 支持标准的算术运算符，包括加法、减法、取模（或取余）</p>
		<p>内置对象 Math（数学对象），用以处理更多的高级数学函数和常数</p>
		<script>
			Math.sin(3.5);
			console.log(Math.sin(3.5));
			/*-0.35078322768961984*/
			var r = 10;
			var d = Math.PI*(r + r);
			console.log(d);
			/*62.83185307179586*/
		</script>

		<h2>parseInt()</h2>
		<p>可以使用内置函数 parseInt() 将字符串转换为整型</p>
		<p>该函数的第二个参数表示字符串所表示数字的基（进制）</p>
		<script>
			parseInt('123', 10);
			console.log(parseInt('123', 10));
			/*123*/
			parseInt('010', 2);
			console.log(parseInt('010', 2));
			/*2*/
			parseInt('010', 10);
			console.log(parseInt('010', 10));
			/*10*/
		</script>
		<p>如果调用时没有提供第二个参数（字符串所表示数字的基）</p>
		<p>2013 年以前的 JavaScript 实现会返回一个意外的结果</p>
		<script>
			parseInt('010');
			console.log(parseInt('010'));
			/*10*/
			parseInt('0x10');
			console.log(parseInt('0x10'));
			/*16*/
		</script>
		<p>字符串以数字 0 开头，parseInt()函数会把这样的字符串视作八进制数字</p>
		<p>0x开头的字符串则视为十六进制数字</p>
		<p>把一个二进制数字字符串转换成整数值，只要把第二个参数设置为 2 就可以了</p>
		<script>
			parseInt('11', 2);
			console.log(parseInt('11', 2));
			/*3*/
		</script>

		<h2>parseFolat()</h2>
		<p>parseFloat()只应用于解析十进制数字</p>
		<p>单元运算符 + 也可以把数字字符串转换成数值</p>
		<script>
			console.log(+"42");
			/*42*/
			console.log(+"010");
			/*10*/
			console.log(+"0x10");
			/*16*/
		</script>
		<p>如果给定的字符串不存在数值形式，函数会返回一个特殊的值 NaN（Not a Number 的缩写）</p>
		<script>
			parseInt("hello", 10);
			console.log(parseInt("hello", 10));
			/*NaN*/
		</script>
		<h3>注意:</h3>
		<p>要小心NaN：如果把 NaN 作为参数进行任何数学运算，结果也会是 NaN</p>
		<script>
			console.log(NaN + 5);
			/*NaN*/
		</script>
		<h3>解决方法</h3>
		<p>可以使用内置函数 isNaN() 来判断一个变量是否为 NaN</p>
		<script>
			console.log(isNaN(NaN));
			/*true*/
		</script>
		<p>JavaScript 还有两个特殊值：Infinity（正无穷）和 -Infinity（负无穷）</p>
		<script>
			1 / 0;
			console.log(1/0);
			/*Infinity*/
			-1 / 0;
			console.log(-1/0);
			/*-Infinity*/
		</script>
		<p>可以使用内置函数 isFinite() 来判断一个变量是否为 Infinity, -Infinity 或 NaN</p>
		<script>
			isFinite(1/0);
			console.log(isFinite(1/0));
			/*false*/
			isFinite(-Infinity);
			console.log(isFinite(-Infinity));
			/*false*/
			isFinite(Infinity);
			console.log(isFinite(Infinity));
			/*false*/
			isFinite(NaN);
			console.log(isFinite(NaN));
			/*false*/
			isFinite(54);
			console.log(isFinite(54));
			/*true*/
		</script>
		<h3>注意:</h3>
		<p>parseInt()和parseFloat()函数会尝试逐个解析字符串中的字符，直到遇上一个无法被解析成数字的字符，然后返回该字符前所有数字字符组成的数字</p>
		<p>使用运算符 "+" 将字符串转换成数字，只要字符串中含有无法被解析成数字的字符，该字符串都将被转换成 NaN</p>
		<script>
			console.log(parseInt("10.2abc"));
			/*10*/
			console.log(+("10.2abc"));
			/*NaN*/
		</script>










		<h1>字符串</h1>
		<p>JavaScript 中的字符串是一串Unicode 字符序列</p>
		<p>是一串UTF-16编码单元的序列，每一个编码单元由一个 16 位二进制数表示</p>
		<p>每一个Unicode字符由一个或两个编码单元来表示</p>

		<p>如果想表示一个单独的字符，只需使用长度为 1 的字符串</p>

		<p>通过访问字符串的  长度（编码单元的个数）属性可以得到它的长度</p>
		<script>
			console.log("hello".length);
			/*5*/
		</script>
		<p>字符串也有methods（方法）能让你操作字符串和获取字符串的信息</p>
		<script>
			"hello".charAt(0);
			console.log("hello".charAt(0));
			/*h*/
			"hello, World".replace("hello", "goodbye");
			console.log("hello, World".replace("hello", "goodbye"));
			/*goodbye, World*/
			"hello".toUpperCase();
			console.log("hello".toUpperCase());
			/*HELLO*/
			console.log("hello");
		</script>










		<h1>其他类型</h1>
		<p>JavaScript 中 null 和 undefined 是不同的</p>
		<p>前者表示一个空值（non-value），必须使用null关键字才能访问</p>
		<p>后者是“undefined（未定义）”类型的对象，表示一个未初始化的值，也就是还没有被分配的值</p>
		<h3>注意:</h3>
		<p>JavaScript 允许声明变量但不对其赋值，一个未被赋值的变量就是 undefined 类型</p>
		<p>undefined 实际上是一个不允许修改的常量</p>

		<p>JavaScript 包含布尔类型，这个类型的变量有两个可能的值，分别是 true 和 false（两者都是关键字）</p>
		<ul>
			<li>false、0、空字符串("")、NaN、null 和 undefined 被转换为 false</li>
			<li>所有其他值被转换为 true</li>
		</ul>
		<p>可以使用 Boolean() 函数进行显式转换</p>
		<script>
			Boolean(false);
			console.log(Boolean(false));
			/*false*/
			Boolean(undefined);
			console.log(Boolean(undefined));
			/*false*/
			Boolean(null);
			console.log(Boolean(null));
			/*false*/
			Boolean(" ");
			console.log(Boolean(" "));
			/*true*/
			Boolean(234);
			console.log(Boolean(234));
			/*true*/
		</script>
		<p>因为 JavaScript 会在需要一个布尔变量时隐式完成这个转换操作（比如在 if 条件语句中）</p>
		<span>有时我们可以把转换成布尔值后的变量分别称为 真值（true values）——即值为 true  和 假值（false values）——即值为 false；也可以分别称为“真的”（truthy）和“假的”（falsy）</span>
		<p>JavaScript 支持包括 &&（逻辑与）、|| （逻辑或）和!（逻辑非）在内的逻辑运算符</p>










		<h1>变量</h1>
		<p>在 JavaScript 中声明一个新变量的方法是使用关键字 var</p>
		<script>
			var a;
			console.log(a);
			/*undefined*/
		</script>
		<p>如果声明了一个变量却没有对其赋值，那么这个变量的类型就是 undefined</p>
		<h3>注意:</h3>
		<p>JavaScript 与其他语言的（如 Java）的重要区别是在 JavaScript 中语句块（blocks）是没有作用域的，只有函数有作用域</p>
		<p>因此如果在一个复合语句中（如 if 控制结构中）使用 var 声明一个变量，那么它的作用域是整个函数（复合语句在函数中）</p>
		<p>从 ECMAScript Edition 6 开始将有所不同的， let 和 const 关键字允许你创建块作用域的变量</p>










		<h1>运算符</h1>
		<p>JavaScript的算术操作符包括 +、-、*、/ 和 % ——求余（与模运算不同）</p>
		<p>赋值使用 = 运算符，此外还有一些复合运算符，如 += 和 -=，它们等价于 x = x op y</p>
		<script>
			var x = 0;
			x += 5;
			x = x + 5;
		</script>
		<p>可以使用 ++ 和 -- 分别实现变量的自增和自减</p>
		<h3>注意:</h3>
		<p>两者都可以作为前缀或后缀操作符使用但执行顺序不同</p>

		<p>+ 操作符还可以用来连接字符串</p>
		<script>
			'hello' + ' world';
			console.log('hello' + ' world');
			// hello world
		</script>

		<p>用一个字符串加上一个数字（或其他值），那么操作数都会被首先转换为字符串</p>
		<script>
			'3' + 4 + 5;
			console.log('3' + 4 + 5);
			// 345
			3 + 4 + '5';
			console.log(3 + 4 + '5');
			// 75
		</script>
		<h3>注意:</h3>
		<p>一个实用的技巧——通过与空字符串相加，可以将某个变量快速转换成字符串类型</p>

		<p>JavaScript 中的比较操作使用 <、>、<= 和 >=，这些运算符对于数字和字符串都通用</p>
		<p>由两个“=（等号）”组成的相等运算符有类型自适应的功能</p>
		<script>
			123 == '123';
			console.log(123 == '123');
			// true
			1 == true;
			// true
			console.log(1 == true);
		</script>
		<p>如果在比较前不需要自动类型转换，应该使用由三个“=（等号）”组成的相等运算符</p>
		<script>
			1 === 123;
			console.log(1 === 123);
			// false
			'123' === 123;
			console.log('123' === 123);
			// false
			123 + '' === 123;
			console.log(123 + '' === 123);
			// false
		</script>
		<p>JavaScript 还支持 != 和 !== 两种不等运算符，具体区别与两种相等运算符的区别类似</p>
		<h3>注意:</h3>
		<p>JavaScript 还提供了 位操作符</p><span>完全看不懂</span>










		<h1>控制结构</h1>
		<p>JavaScript 的控制结构与其他类 C 语言类似</p>
		<p>使用 if 和 else 来定义条件语句，还可以连起来使用</p>
		<script>
			var name = "kittens";
			if (name == "puppies") {
				name += '!';
			} else if (name == "kittens") {
				name += "!!";
			} else {
				name = "!" + name;
			}
			name == "kittens!!";
			console.log(name == "kittens!!");
			// true
		</script>

		<p>JavaScript 支持 while 循环和 do-while 循环</p>
		<h3>注意:</h3>
		<p>前者适合常见的基本循环操作，如果需要循环体至少被执行一次则可以使用 do-while</p>
		<script>
			// while (true) {
			// 	// 一个无限循环！
			// }

			var input;
			do {
				input = get_input();
			} while (inputIsNotValid(input))
		</script>

		<p>JavaScript 的 for 循环与 C 和 Java 中的相同，使用时可以在一行代码中提供控制信息</p>
		<script>
			for (var i = 0; i < 5; i++) {
				// 将会执行五次
			}
		</script>

		<p>&& 和 || 运算符使用短路逻辑（short-circuit logic），是否会执行第二个语句（操作数）取决于第一个操作数的结果</p>
		<h3>注意:</h3>
		<p>在需要访问某个对象的属性时，使用这个特性可以事先检测该对象是否为空</p>
		<script>
			var name = o && o.getName();
		</script>
		<p>或运算可以用来设置默认值</p>
		<script>
			var name = otherName || 'default';
		</script>
		<p>JavaScript 也有一个用于条件表达式的三元操作符</p>
		<script>
			var allowed = (age > 18) ? "yes" : "no";
		</script>
		<p>需要多重分支时可以使用  基于一个数字或字符串的switch 语句</p>
		<script>
			switch(action) {
				case 'draw':
					drawIt();
					break;
				case 'eat':
					edtIt();
					break;
				default:
					doNothing();
			}
		</script>
		<h3>概念说明:</h3>
		<p>如果你不使用 break 语句，JavaScript 解释器将会执行之后 case 中的代码</p>
		<p>除非是为了调试，一般你并不需要这个特性，所以大多数时候不要忘了加上 break</p>
		<script>
			switch(a) {
				case 1: // 继续向下
				case 2:
					edtIt();
					break;
				default:
					doNothing();
			}
		</script>
		<h3>详细说明</h3>
		<p>default 语句是可选的</p>
		<p>switch 和 case 都可以使用需要运算才能得到结果的表达式</p>
		<p>在 switch 的表达式和 case 的表达式是使用 === 严格相等运算符进行比较的</p>
		<script>
			switch(1 + 3) {
				case 2 + 2:
					yay();
					break;
				default:
					neverhappens();
			}
		</script>










		<h1>对象</h1>
		<p>JavaScript 中的对象可以简单理解成“名称-值”对</p>
		<ul>
			<li>Python 中的字典</li>
			<li>Perl 和 Ruby 中的散列（哈希）</li>
			<li>C/C++ 中的散列表</li>
			<li>Java 中的 HashMap</li>
			<li>PHP 中的关联数组</li>
		</ul>
		<h2>javascript的优势</h2>
		<span>正因为 JavaScript 中的一切（除了核心类型，core object）都是对象，所有 JavaScript 程序必然与大量的散列表查找操作有着千丝万缕的联系，而散列表擅长的正是高速查找</span>
		<p>“名称”部分是一个 JavaScript 字符串，“值”部分可以是任何 JavaScript 的数据类型——包括对象</p>
		<p>有两种简单方法可以创建一个空对象</p>
		<script>
			var obj1 = new Object();
			console.log(obj1);
			// Object__proto__: Object
			var obj2 = {};
			console.log(obj2);
			// Object__proto__: Object
		</script>
		<h3>代码描述:</h3>
		<p>这两种方法在语义上是相同的</p>
		<p>第二种更方便的方法叫作“对象字面量（object literal）”法</p>
		<p>这种也是 JSON 格式的核心语法，一般我们优先选择第二种方法</p>

		<p>“对象字面量”也可以用来在对象实例中定义一个对象</p>
		<script>
			var obj = {
				name: "Carrot",
				"for": "Max",
				details: {
					color: "orange",
					size: 12
				}
			}
			console.log(obj);
			// Object {name: "Carrot", for: "Max", details: Object}
		</script>
		<p>对象的属性可以通过链式（chain）表示方法进行访问</p>
		<script>
			var obj = {
				name: "Carrot",
				"for": "Max",
				details: {
					color: "orange",
					size: 12
				}
			}
			obj.details.color;
			console.log(obj.details.color);
			// orange
			obj["details"]["size"];
			console.log(obj["details"]["size"]);
			// 12
		</script>
		<p>创建一个对象原型，Person，和这个原型的实例，You</p>
		<script>
			function Person(name, age) {
				this.name = name;
				this.age = age;
			}

			// 定义一个对象
			var You = new Person("You", 24);
			// 创建一个新的 Person，名称是 "You"
			// ("You" 是第一个参数, 24 是第二个参数..)
		</script>
		<p>完成创建后，对象属性可以通过如下两种方式进行赋值和访问</p>
		<script>
			obj.name = "Simon1";
			var name = obj.name;
			console.log(name);
			// Simon1

			obj["name"] = "Simon2";
			var name = obj["name"];
			console.log(name);
			// Simon2
		</script>
		<h3>注意:</h3>
		<p>这两种方法在语义上也是相同的</p>
		<p>第二种方法的优点在于属性的名称被看作一个字符串，这就意味着它可以在运行时被计算</p>
		<p>缺点在于这样的代码有可能无法在后期被解释器优化</p>
		<p>也可以被用来访问某些以预留关键字作为名称的属性的值</p>
		<script>
			obj.for = "Simon";
			// 应该是报错的:语法错误，因为 for 是一个预留关键字
			// 但是没有报错
			// obj["for"] = "Simon";
			console.log(obj);
			// Object {name: "Simon2", for: "Simon", details: Object}
		</script>
		<h3>注意:</h3>
		<p>从 EcmaScript 5 开始，预留关键字可以作为对象的属性名</p>
		<p>这意味着当定义对象字面量时不需要用双引号了</p>
		<h3>关于对象和原型的详情参见： Object.prototype</h3>











		<h1>数组</h1>
		<p>JavaScript 中的数组是一种特殊的对象</p>
		<p>它的工作原理与普通对象类似（以数字为属性名，但只能通过[] 来访问），但数组还有一个特殊的属性——length（长度）属性</p>
		<p>这个属性的值通常比数组最大索引大 1</p>

		<p>创建数组的传统方法</p>
		<script>
			var a = new Array();
			a[0] = "dog";
			a[1] = "cat";
			a[2] = "hen";
			console.log(a.length);
			// 3
			a[10] = "wangde";
			console.log(a.length);
			// 11
		</script>

		<p>使用数组字面量（array literal）法更加方便</p>
		<script>
			var a = ["dog", "cat", "hen"];
			console.log(a.length);
			// 3
			console.log(a);
			// ["dog", "cat", "hen"]
		</script>

		<h3>注意，Array.length 并不总是等于数组中元素的个数</h3>
		<script>
			var a = ["dog", "cat", "hen"];
			a[100] = "fox";
			console.log(a.length);
			// 101
			console.log(a);
			// ["dog", "cat", "hen", 100: "fox"]
		</script>
		<h3>记住：数组的长度是比数组最大索引值多一的数</h3>

		<p>如果试图访问一个不存在的数组索引，会得到 undefined</p>
		<script>
			var a = ["dog", "cat", "hen"];
			console.log(a[90]);
			// undefined
			typeof(a[90]);
			console.log(typeof(a[90]));
			// undefined
		</script>

		<p>可以通过如下方式遍历一个数组</p>
		<script>
			var a = ["dog", "cat", "hen"];

			for(var i = 0; i < a.length; i++){
				console.log(a[i]);
			}
		</script>
		<h3>注意:</h3>
		<p>这么做效率不太好，因为每循环一次都要计算一次长度</p>
		<p>改进的版本</p>
		<script>
			var a = ["dog", "cat", "hen"];

			for(var i = 0, len=a.length; i < len; i++) {
				console.log(a[i]);
			}
		</script>
		<p>还有一种更简洁但是有使用局限的写法</p>
		<script type="text/javascript">
			for (var i = 0, item; item = a[i++]; ) {
				// Do something with item
			}
		</script>
		<h3>注意:</h3>
		<p>使用了两个变量</p>
		<p>for 循环中间部分的赋值表达式同时也用来判断是否为真——如果为真，那么循环继续</p>
		<p>因为 i 每次递增 1，这个数组的元素会被逐个传递给 item 变量</p>
		<p>当遇到一个假值元素（如 undefined ）时，循环结束</p>

		<h3>注意:</h3>
		<p>注意这个技巧只能在你知道数组中不含假值（例如对象或DOM节点的数组）时才可以使用</p>
		<p>如果想要遍历可能包含 0 或空字符串的数组，应该使用 i, len 的写法</p>

		<p>遍历数组的另一种方法是使用 for...in 循环</p>
		<h3>注意，如果有人向 Array.prototype 添加了新的属性，使用这样的循环这些属性也同样会被遍历</h3>
		<p>所以并不推荐这种方法</p>
		<script>
			for (var i in a) {
				// Do something with a[i]
			}
		</script>

		<p>ECMAScript 5 增加了遍历数组的另一个方法 forEach()</p>
		<script>
			["dog", "cat", "hen"].forEach(function(currentValue, index, array) {
				// Do something with currentValue or array[index]
			})
		</script>

		<p>如果想在数组后追加元素，只需要</p>
		<script>
			a.push(item);
		</script>

		<p>Array（数组）类自带了许多方法</p>
		<table>
			<thead>
				<tr>
					<td>方法名称</td><td>描述</td>
				</tr>
			</thead>
			<tbody>
				<tr>
					<td>a.toString()</td>
					<td>返回一个包含数组中所有元素的字符串，每个元素通过逗号分隔</td>
					<script>
						var a = ["dog", "cat", "hen"];
						var b = ["dog1", "cat1", "hen1"];
						console.log(a.toString());
						// dog,cat,hen
						console.log(a.toString(1));
						// dog,cat,hen
						a.toString();
						console.log(a);
						// ["dog", "cat", "hen"]
					</script>
				</tr>
				<tr>
					<td>a.toLocaleString()</td>
					<td>根据宿主环境的区域设置，返回一个包含数组中所有元素的字符串，每个元素通过逗号分隔</td>
					<script>
						var a = ["dog", "cat", "hen"];
						var b = ["dog1", "cat1", "hen1"];
						console.log(a.toLocaleString());
						// dog,cat,hen
						console.log(a.toLocaleString(1));
						// dog,cat,hen
						a.toLocaleString();
						console.log(a);
						// ["dog", "cat", "hen"]
					</script>
				</tr>
				<tr>
					<td>a.concat(item[, item[, ...[, itemN]]])</td>
					<td>返回一个数组，这个数组包含原先 a 和 item1、item2、……、itemN 中的所有元素</td>
					<script>
						var a = ["dog", "cat", "hen"];
						var b = ["dog1", "cat1", "hen1"];
						console.log(a.concat());
						// ["dog", "cat", "hen"]
						console.log(a.concat("dog"));
						// ["dog", "cat", "hen", "dog"]
						console.log(a.concat("dog"["cat"]));
						// ["dog", "cat", "hen", undefined]
						a.concat("dog");
						console.log(a);
						// ["dog", "cat", "hen"]
					</script>
				</tr>
				<tr>
					<td>a.join(sep)</td>
					<td>返回一个包含数组中所有元素的字符串，每个元素通过指定的 sep 分隔</td>
					<script>
						var a = ["dog", "cat", "hen"];
						var b = ["dog1", "cat1", "hen1"];
						console.log(a);
						// ["dog", "cat", "hen"]
						a.join(b);
						console.log(a);
						// ["dog", "cat", "hen"]
						console.log(a.join(b));
						// dogdog1,cat1,hen1catdog1,cat1,hen1hen
					</script>
				</tr>
				<tr>
					<td>a.pop()</td>
					<td>删除并返回数组中的最后一个元素</td>
					<script>
						var a = ["dog", "cat", "hen"];
						var b = ["dog1", "cat1", "hen1"];
						console.log(a.pop());
						// hen
						console.log(a);
						// ["dog", "cat"]
					</script>
				</tr>
				<tr>
					<td>a.push(item1, ..., itemN)</td>
					<td>将 item1、item2、……、itemN 追加至数组 a</td>
					<script>
						var a = ["dog", "cat", "hen"];
						var b = ["dog1", "cat1", "hen1"];
						var c = "fox";
						var d = 1;
						console.log(a.push(b));
						// 4
						console.log(a.push(c));
						// 5
						console.log(a.push(d));
						// 6
						a.push(b);
						console.log(a);
						// ["dog", "cat", "hen", Array[3], "fox", 1, Array[3]]
						a.push(c);
						console.log(a);
						// ["dog", "cat", "hen", Array[3], "fox", 1, Array[3], "fox"]
						a.push(d);
						console.log(a);
						// ["dog", "cat", "hen", Array[3], "fox", 1, Array[3], "fox", 1]
					</script>
				</tr>
				<tr>
					<td>a.reverse()</td>
					<td>数组逆序（会更改原数组 a）</td>
					<script>
						var a = ["dog", "cat", "hen"];
						console.log(a.reverse());
						// ["hen", "cat", "dog"]
						console.log(a);
						// ["hen", "cat", "dog"]
						a.reverse();
						console.log(a);
						// ["dog", "cat", "hen"]
					</script>
				</tr>
				<tr>
					<td>a.shift()</td>
					<td>删除并返回数组中第一个元素</td>
					<script>
						var a = ["dog", "cat", "hen"];
						console.log(a.shift());
						// dog
						console.log(a);
						// ["cat", "hen"]
						a.shift();
						console.log(a);
						// ["hen"]
					</script>
				</tr>
				<tr>
					<td>a.slice(start, end)</td>
					<td>返回子数组，以 a[start] 开头，以 a[end] 前一个元素结尾</td>
					<script>
						var a = ["dog", "cat", "hen"];
						console.log(a.slice(0, 1));
						// ["dog"]
						console.log(a.slice(a[0], a[1]));
						// []
						console.log(a.slice("dog", "cat"));
						// []
						console.log(a);
						// ["dog", "cat", "hen"]
						a.slice(0, 1);
						console.log(a);
						// ["dog", "cat", "hen"]
					</script>
				</tr>
				<tr>
					<td>a.sort([cmpfn])</td>
					<td>依据 cmpfn 返回的结果进行排序，如果未指定比较函数则按字符顺序比较（即使元素是数字）</td>
					<script>
						var a = ["dog", "cat", "hen"];
						console.log(a.sort());
						// ["cat", "dog", "hen"]
						console.log(a);
						// ["cat", "dog", "hen"]
					</script>
				</tr>
				<tr>
					<td>a.splice(start, delcount[, item1[, ...[, itemN]]])</td>
					<td>从 start 开始，删除 delcount 个元素，然后插入所有的 item</td>
					<script>
						var a = ["dog", "cat", "hen"];
						var b = ["dog1", "cat1", "hen1"];
						console.log(a.splice(0, 2, b));
						// ["dog", "cat"]
						console.log(a.splice(0, 1, ["dog1", "cat1", "hen1"]));
						// [Array[3]]
						console.log(a);
						// [Array[3], "hen"]
					</script>
				</tr>
				<tr>
					<td>a.unshift([item])</td>
					<td>将 item 插入数组头部，返回数组新长度（考虑 undefined）</td>
					<script>
						var a = ["dog", "cat", "hen"];
						var b = ["dog1", "cat1", "hen1"];
						console.log(a.unshift(b));
						// 4
						console.log(a);
						// [Array[3], "dog", "cat", "hen"]
					</script>
				</tr>
			</tbody>
		</table>










		<h1>函数</h1>
		<p>最重要的就是要理解对象和函数两个部分</p>
		<p>最简单的函数就像下面这个这么简单</p>
		<script>
			function add(x, y) {
				var total = x + y;
				return total;
			}
		</script>
		<h3>代码描述</h3>
		<p>一个 JavaScript 函数可以包含 0 个或多个已命名的变量</p>
		<p>函数体中的表达式数量也没有限制</p>
		<p>你可以声明函数自己的局部变量</p>
		<p>return 语句在返回一个值并结束函数</p>
		<p>如果没有使用 return 语句，或者一个没有值的 return 语句，JavaScript 会返回 undefined</p>

		<p>已命名的参数更像是一个指示而没有其他作用</p>
		<p>如果调用函数时没有提供足够的参数，缺少的参数会被 undefined 替代</p>
		<script>
			add(); //NaN
			// 不能在 undefined 对象上进行加法操作
			console.log(add());
			// NaN
			var add = function(){}
			console.log(add());
			// undefined
		</script>

		<p>还可以传入多于函数本身需要参数个数的参数</p>
		<script>
			function add(x, y) {
				var total = +x + +y;
				return total;
			}
			add(2, 3, 4);
			console.log(add(2, 3, 4));
			// 5
		</script>
		<h3>代码解析</h3>
		<p>函数实际上是访问了函数体中一个名为 arguments 的内部对象</p>
		<p>这个对象就如同一个类似于数组的对象一样，包括了所有被传入的参数</p>
		<p>重写一下上面的函数，使它可以接收任意个数的参数</p>
		<script>
			function add() {
				var sum = 0;
				for(var i = 0, j = arguments.length; i < j; i++) {
					sum += +arguments[i];
				}
				return sum;
			}
			console.log(add(1, 2, 3, 4, 5, 6, 7, 8, 9));
			// 45
		</script>
		<p>跟直接写成 2 + 3 + 4 + 5 也没什么区别</p>

		<p>接下来创建一个求平均数的函数</p>
		<script>
			function avg() {
				var sum = 0;
				for(var i = 0, j = arguments.length; i < j; i++) {
					sum += +arguments[i];
				}
				return sum / arguments.length;
			}
			console.log(avg(1, 2, 3, 4, 5, 6, 7, 8, 9));
			// 5
		</script>
		<p>avg() 函数处理一个由逗号连接的变量串</p>

		<p>如果想得到一个数组的平均值</p>
		<script>
			function avgArray(arr) {
				var sum = 0;
				for(var i = 0, j = arr.length; i < j; i++) {
					sum += arr[i];
				}
				return sum / arr.length;
			}
			console.log(avgArray([2, 3, 4, 5, 6, 7, 8, 9]));
			// 5.5
		</script>

		<h3>注意:</h3>
		<p> JavaScript 允许使用任意函数对象的apply() 方法来调用该函数，并传递给它一个包含了参数的数组</p>
		<script>
			avg.apply(null, [2, 3, 4, 5]);
			console.log(avg.apply(null, [2, 3, 4, 5]));
			// 3.5
		</script>

		<p>JavaScript 允许创建匿名函数</p>
		<script>
			var avg = function() {
				var sum = 0;
				for (var i = 0, j = arguments.length; i < j; i++) {
					sum += +arguments[i];
				}
				return sum / arguments.length;
			}
		</script>
		<h3>代码描述:</h3>
		<p>这个函数在语义上与 function avg() 相同。你可以在代码中的任何地方定义这个函数，就像写普通的表达式一样</p>

		<p>基于这个特性，有人发明出一些有趣的技巧。与 C 中的块级作用域类似，下面这个例子隐藏了局部变量</p>
		<script>
			var a = 1;
			var b = 2;
			console.log(a);
			// 1
			console.log(b);
			// 2
			(function() {
				var b = 3;
				a += b;
			})();
			console.log(a);
			// 4
			console.log(b);
			// 2
		</script>
		
		<h3>注意:</h3>
		<p>JavaScript 允许以递归方式调用函数</p>
		<p>递归在处理树形结构（比如浏览器 DOM）时非常有用</p>
		<script>
			// 没有循环出来！！！！！
			function countChars(elm) {
				if (elm.nodeType == 3) {
					return elm.nodeType.length;
				}
				var count = 0;
				for (var i = 0, child; child = elm.childNodes[i]; i++) {
					count += countChars(child);
				}
				return count;
			}
			// var table = document.getElementsByTagName("table");
			// console.log(countChars(table));
			// 没有循环出来！！！！！
		</script>

		<p>10以内阶乘示例</p>
		<script>
			function fact(num){
				if(num <= 1) {
					return 1;
				}else{
					return num*fact(num-1);
				}
			}
			console.log(fact(5));
			// 120
			// 但是:
			var fact1 = fact;
			console.log(fact1);
			// function fact(num){
			// 	if(num <= 1) {
			// 		return 1;
			// 	}else{
			// 		return num*fact(num-1);
			// 	}
			// }
			fact = null;
			console.log(fact);
			// null
			console.log(fact1);
			// function fact(num){
			// 	if(num <= 1) {
			// 		return 1;
			// 	}else{
			// 		return num*fact(num-1);
			// 	}
			// }
			console.log(fact1(4));
			// fact is not a function
		</script>
		<h3>代码描述:</h3>
		<p>由于fact已经不是函数了，所以出错</p>
		<p>用arguments.callee可解决问题，这是一个指向正在执行的函数的指针</p>
		<script>
			function fact(num) {
				if(num <= 1) {
					return 1;
				}else{
					return num*arguments.callee(num-1);
				}
			}
			console.log(fact(5));
			// 120

			var fact1 = fact;
			fact = null;
			console.log(fact1(4));
			// 24
		</script>










		<h1>自定义对象</h1>
		<p>对象是指数据和在这些数据上进行的操作的集合</p>
		<p>JavaScript 是一种基于原型的编程语言，并没有 class 语句，而是把函数用作类</p>
		<script>
			function makePerson(first, last) {
				return {
					first: first,
					last: last
				}
			}

			function personFullName(person) {
				return person.first + " " + person.last;
			}

			function personFullNameReversed(person) {
				return person.last + "," + person.last;
			}

			s = makePerson("Simon", "Willison");
			console.log(s);
			// Object
				// first: "Simon"
				// last: "Willison"
				// __porto__:Object
			personFullName(s);
			console.log(personFullName(s));
			// Simon Willison
			console.log(s);
			// Object
				// first: "Simon"
				// last: "Willison"
				// __porto__:Object
			personFullNameReversed(s);
			console.log(personFullNameReversed(s));
			// Willison,Willison
			console.log(s);
			// Object
				// first: "Simon"
				// last: "Willison"
				// __porto__:Object
		</script>
		<h3>代码描述</h3>
		<p>因为需要在全局命名空间中写很多函数</p>
		<p>既然函数本身就是对象，如果需要使一个函数隶属于一个对象</p>
		<p>那么不难得到</p>
		<script>
			function makePerson(first, last) {
				return {
					first: first,
					last: last,
					fullName: function() {
						return this.first + " " + this.last;
					},
					fullNameReversed: function(){
						return this.last + "," + this.first;
					},
					rerurnthis: function(){
						return this;
					}
				}
			}

			s = makePerson("Simon", "Willison");
			console.log(s.rerurnthis());
			// Object {first: "Simon", last: "Willison"}
				// first: "Simon"
				// fullName: function () { return this.first + " " + this.last; }
				// fullNameReversed: function (){ return this.last + "," + this.first; }
				// last: "Willison"
				// rerurnthis: function (){ return this; }
				// __proto__:Object
			console.log(s);
			// Object {first: "Simon", last: "Willison"}
				// first: "Simon"
				// fullName: function () { return this.first + " " + this.last; }
				// fullNameReversed: function (){ return this.last + "," + this.first; }
				// last: "Willison"
				// rerurnthis: function (){ return this; }
				// __proto__:Object
			s.fullName();
			console.log(s.fullName());
			// Simon Willison
			console.log(s);
			// Object {first: "Simon", last: "Willison"}
				// first: "Simon"
				// fullName: function () { return this.first + " " + this.last; }
				// fullNameReversed: function (){ return this.last + "," + this.first; }
				// last: "Willison"
				// rerurnthis: function (){ return this; }
				// __proto__:Object
			s.fullNameReversed();
			console.log(s.fullNameReversed());
			// Willison,Simon
			console.log(s);
			// Object {first: "Simon", last: "Willison"}
				// first: "Simon"
				// fullName: function () { return this.first + " " + this.last; }
				// fullNameReversed: function (){ return this.last + "," + this.first; }
				// last: "Willison"
				// rerurnthis: function (){ return this; }
				// __proto__:Object
		</script>
		<h3>代码描述:</h3>
		<p>关键字 this。当使用在函数中时，this 指代当前的对象，也就是调用了函数的对象</p>
		<p>如果在一个对象上使用点或者花括号来访问属性或方法，这个对象就成了 this</p>
		<p>如果并没有使用“点”运算符调用某个对象，那么 this 将指向全局对象（global object）</p>
		<script>
			function makePerson(first, last) {
				return {
					first: first,
					last: last,
					fullName: function() {
						return this.first + " " + this.last;
					},
					fullNameReversed: function(){
						return this.last + "," + this.first;
					},
					rerurnthis: function(){
						return this;
					}
				}
			}

			var s = makePerson("simon", "Willison");
			var fullName = s.fullName;
			fullName();
			console.log(fullName());
			// undefined undefined
			console.log(fullName);
			// function () {
			// 	return this.first + " " + this.last;
			// }
		</script>
		<h3>代码描述:</h3>
		<p>调用 fullName() 时，this 实际上是指向全局对象的</p>
		<p>并没有名为 first 或 last 的全局变量</p>
		<p>所以它们两个的返回值都会是 undefined</p>

		<p>使用关键字 this 改进已有的 makePerson函数</p>
		<script>
			function Person(first, last) {
				this.first = first;
				this.last = last;
				this.fullName = function() {
					return this.first + " " + this.last;
				}
				this.fullNameReversed = function() {
					return this.last + ", " + this.first;
				}
				this.returnthis = function() {
					return this;
				}
			}
			var s = new Person("Simon", "Willison");
			var fullName = s.fullName;
			console.log(fullName);
			// function () {
			// 	return this.first + " " + this.last;
			// }
			console.log(fullName());
			// undefined undefined
			console.log(s);
			// Person {first: "Simon", last: "Willison"}
				// first: "Simon"
				// fullName: function () { return this.first + " " + this.last; }
				// fullNameReversed: function () { return this.last + ", " + this.first; }
				// last: "Willison"
				// returnthis: function () { return this; }
					// arguments: null
					// caller: null
					// length: 0
					// name: ""
					/*从这开始*/
					// prototype: Object
						// constructor: function () { return this; }
							// arguments: null
							// caller: null
							// length: 0
							// name: ""
							// prototype: Object
						// __proto__: Object(原型)
						// <function scope>
							// Global: Window(包含n多奇葩方法)
					/*到这结束操他妈的无限循环*/		
					// __proto__：function () {}(包含原型的一些基本方法)
					// <function scope>
					// Global: Window(包含n多奇葩方法)
				// __proto__: Object
					// constructor: 
						// function Person(first, last) { 
						// 	this.first = first; this.last = last; 
						// 	this.fullName = function() { return this.first + " " + this.last; } 
						// 	this.fullNameReversed = function() { return this.last + ", " + this.first; } 
						// }
					// __proto__: Object(原本的原型方法)
			console.log(s.fullName);
			// function() {
			// 	return this.first + " " + this.last;
			// }
			console.log(s.fullName());
			// Simon Willison
			console.log(s.fullNameReversed);
			// function{
			// 	return this.last + ", " + this.first;
			// }
			console.log(s.fullNameReversed());
			// Willison, Simon
		</script>
		<h3>注意:</h3>
		<p>引入了另外一个关键字：new，它和 this 密切相关</p>
		<p>它的作用是创建一个崭新的空对象，然后使用指向那个对象的 this 调用特定的函数</p>
		<h3>注意，含有 this 的特定函数不会返回任何值，只会修改 this 对象本身</h3>
		<p>new 关键字将生成的 this 对象返回给调用方，而被 new 调用的函数成为构造函数</p>
		<p>习惯的做法是将这些函数的首字母大写，这样用 new 调用他们的时候就容易识别了</p>
		
		<h3>改正</h3>
		<p>不过这个改进的函数还是和上一个例子一样，单独调用fullName() 时会产生相同的问题</p>

		<p>每次我们创建一个 Person 对象的时候，我们都在其中创建了两个新的函数对象——如果这个代码可以共享不是更好吗</p>
		<script>
			function personFullName() {
				return this.first + " " + this.last;
			}

			function personFullNameReversed() {
				return this.last + " , " + this.first;
			}

			function Person(first, last) {
				this.first = first;
				this.last = last;
				this.fullName = personFullName;
				this.fullNameReversed = personFullNameReversed;
			}
			var s = new Person("first", "last");
			var fullName = s.fullName;
			console.log(fullName());
			// undefined undefined
			console.log(fullName("first", "last"));
			// undefined undefined
			console.log(fullName);
			// personFullName() {
			// 	return this.first + " " + this.last;
			// }
			console.log(s);
			// Object {first: "first", last: "last"}
				// first: "first"
				// fullName: function personFullName() { return this.first + " " + this.last; }
				// fullNameReversed: function personFullNameReversed() { return this.last + " , " + this.first; }
				// last: "last"
				// rerurnthis: function (){ return this; }
				// __proto__:Object
		</script>

		<p>这种写法的好处是，我们只需要创建一次方法函数，在构造函数中引用它们</p>

		<script>
			function Person(first, last) {
				this.first = first;
				this.last = last;
			}

			Person.prototype.fullName = function() {
				return this.first + " " + this.last;
			}

			Person.prototype.fullNameReversed = function() {
				return this.last + " , " + this.first;
			}
			var s = new Person("first", "last");
			var fullName = s.fullName;
			console.log(fullName());
			// undefined undefined
			console.log(fullName("first", "last"));
			// undefined undefined
			console.log(fullName);
			// function () {
			// 	return this.first + " " + this.last;
			// }
			console.log(s);
			// Person {first: "first", last: "last"}
				// first: "first"
				// last: "last"
				// __proto__:Object
					// constructor: function Person(first, last) { this.first = first; this.last = last; }
					// fullName: function(){}
					// fullNameReversed: function(){}
					// __proto__:Object(原型方法)
			/*注意各个对象的方法中均包含__proto__的原型方法和实例化的拓展方法*/
		</script>
		<h3>代码描述</h3>
		<p>Person.prototype 是一个可以被Person的所有实例共享的对象</p>
		<p>它是一个名叫原型链（prototype chain）的查询链的一部分</p>
		<p>当你试图访问一个 Person 没有定义的属性时，解释器会首先检查这个 Person.prototype 来判断是否存在这样一个属性</p>
		<p>所以，任何分配给 Person.prototype 的东西对通过 this 对象构造的实例都是可用的</p>

		<h3>代码使用扩展</h3>
		<p>JavaScript 允许你在程序中的任何时候修改原型（prototype）中的一些东西</p>
		<p>也就是说你可以在运行时(runtime)给已存在的对象添加额外的方法</p>
		<script>
			function Person(first, last) {
				this.first = first;
				this.last = last;
			}

			Person.prototype.fullName = function() {
				return this.first + " " + this.last;
			}

			Person.prototype.fullNameReversed = function() {
				return this.last + " , " + this.first;
			}

			var s = new Person("Simon", "Willison");
			// s.firstNameCaps();
			// s.firstNameCaps is not a function

			Person.prototype.firstNameCaps = function() {
				return this.first.toUpperCase();
			}

			s.firstNameCaps();
			console.log(s.firstNameCaps());
			// SIMON
			var firstNameCaps = s.firstNameCaps;
			console.log(firstNameCaps);
			// function () {
			// 	return this.first.toUpperCase();
			// }
			console.log(firstNameCaps());
			// Uncaught TypeError: Cannot read property 'toUpperCase' of undefined
			var firstNameCaps1 = s.firstNameCaps();
			console.log(firstNameCaps1);
			// SIMON
		</script>

		<h3>扩展</h3>
		<p>还可以给 JavaScript 的内置函数原型（prototype）添加东西</p>
		<p>让我们给 String 添加一个方法用来返回逆序的字符串</p>
		<script>
			var s = "Simon";
			// s.reversed();
			// Uncaught TypeError: s.reversed is not a function

			String.prototype.reversed = function() {
				var r = "";
				for(var i = this.length - 1; i >= 0; i--) {
					r += this[i];
				}
				return r;
			}

			s.reversed();
			console.log(s.reversed());
			// nomiS

			/**
			*	定义新方法也可以在字符串字面量上用（string literal）
			*/
			"This can now be reversed".reversed();
			console.log("This can now be reversed".reversed());.
			// desrever eb won nac sihT
		</script>
		<h3>代码总结</h3>
		<p>正如我前面提到的，原型组成链的一部分</p>
		<p>那条链的根节点是 Object.prototype，它包括 toString() 方法——将对象转换成字符串时调用的方法</p>
		<p>对于调试我们的 Person 对象很有用</p>
		<script>
			var s = new Person("Simon", "Willison");
			s;
			console.log(s);
			// Person {first: "Simon", last: "Willison"}
				// first: "Simon"
				// last: "Willison"
				// __proto__: Object
				// constructor: function Person(first, last) { this.first = first; this.last = last; }
				// firstNameCaps: function () { return this.first.toUpperCase(); }
				// fullName: function () { return this.first + " " + this.last; }
				// fullNameReversed: function () { return this.last + " , " + this.first; }
				// __proto__:Object

			Person.prototype.toString = function() {
				return '<Person: ' + this.fullName() + '>';
			}

			s.toString();
			console.log(s.toString());
			// <Person: Simon Willison>
		</script>

		<p>之前我们说的 avg.apply() 中的第一个参数 null</p>
		<p>apply() 的第一个参数应该是一个被当作 this 来看待的对象</p>
		<p>下面是一个 new 方法的简单实现</p>
		<script>
			function trivialNew(constructor, ...args) {
				var o = {};	// 创建一个对象
				constructor.apply(o, args);
				return 0;
			}
			console.log(this);
			// Window {external: Object, chrome: Object, document: document, r: 10, d: 1…}
		</script>
		<h3>代码描述</h3>
		<p>这并不是 new 的完整实现，因为它没有创建原型（prototype）链</p>
		<p>说明 new 的实现有些困难</p>
		<p>在这一小段代码里，...args（包括省略号）叫作剩余参数（rest arguments）</p>
		<p>如名所示，这个东西包含了剩下的参数</p>
		<script>
			function trivialNew(constructor, ...args) {
				var o = {};	// 创建一个对象
				constructor.apply(o, args);
				return 0;
			}
			var bill = trivialNew(Person, "William", "Orange");
			console.log(bill);
			// 0
			console.log(bill());
			// Uncaught TypeError: bill is not a function
		</script>
		<p>等效于(但是没有成功！！！)</p>
		<script>
			var bill = new Person("Willison", "Orange");
			console.log(bill);
			// Person {first: "Willison", last: "Orange"}
		</script>
		
		<h3>拓展</h3>
		<p>apply() 有一个姐妹函数，名叫 call，它也可以允许你设置 this，但它带有一个扩展的参数列表而不是一个数组</p>
		<script>
			function lastNameCaps() {
				return this.last.toUpperCase();
			}

			var s = new Person("simon", "Willison");
			lastNameCaps.call(s);
			console.log(lastNameCaps);
			// function lastNameCaps() {
			// 	return this.last.toUpperCase();
			// }
			console.log(lastNameCaps.call);
			// function call() { [native code] }
			console.log(lastNameCaps.call());
			// Uncaught TypeError: Cannot read property 'toUpperCase' of undefined
			console.log(lastNameCaps.call(s));
			// WILLISON
			/*和以下方式等价*/
			s.lastNameCaps = lastNameCaps;
			console.log(s.lastNameCaps);
			// function lastNameCaps() {
			// 	return this.last.toUpperCase();
			// }
			s.lastNameCaps();
			console.log(s.lastNameCaps());
			// WILLISON
		</script>










		<h1>内部函数</h1>
		<p>JavaScript 允许在一个函数内部定义函数</p>
		<p>JavaScript 中的嵌套函数，一个很重要的细节是它们可以访问父函数作用域中的变量</p>
		<script>
			function betterExampleNeeded() {
				var a = 1;
				function oneMoreThanA() {
					return a + 1;
				}
				return oneMoreThanA();
			}
		</script>
		<h3>使用总结</h3>
		<p>如果某个函数依赖于其他的一两个函数，而这一两个函数对你其余的代码没有用处</p>
		<p>可以将它们嵌套在会被调用的那个函数内部</p>
		<p>这样做可以减少全局作用域下的函数的数量，这有利于编写易于维护的代码</p>

		<h3>概念总结</h3>
		<p>这也是一个减少使用全局变量的好方法</p>
		<p>当编写复杂代码时，程序员往往试图使用全局变量，将值共享给多个函数，但这样做会使代码很难维护</p>
		<p>内部函数可以共享父函数的变量，所以你可以使用这个特性把一些函数捆绑在一起</p>
		<p>这样可以有效地防止“污染”你的全局命名空间——你可以称它为“局部全局（local global）”</p>










		<h1>闭包</h1>
		<p> JavaScript 中必须提到的功能最强大的抽象概念之一：闭包</p>
		<script>
			function makeAdder(a) {
				return function(b) {
					return a + b;
				}
			}
			x = makeAdder(5);
			console.log(x);
			// function (b) {
			// 	return a + b;
			// }
			y = makeAdder(20);
			console.log(y);
			// function (b) {
			// 	return a + b;
			// }
			x(6);
			console.log(x(6));
			// 11
			y(7);
			console.log(y(7));
			// 7
		</script>
		<h3>代码描述</h3>
		<p>makeAdder 这个名字本身应该能说明函数是用来做什么的</p>
		<p>它创建了一个新的 adder 函数，这个函数自身带有一个参数</p>
		<p>它被调用的时候这个参数会被加在外层函数传进来的参数上</p>

		<h3>执行过程说明</h3>
		<p>这里发生的事情和前面介绍过的内嵌函数十分相似</p>
		<p>一个函数被定义在了另外一个函数的内部，内部函数可以访问外部函数的变量</p>
		<p>唯一的不同是，外部函数被返回了，那么常识告诉我们局部变量“应该”不再存在</p>
		<p>但是它们却仍然存在——否则 adder 函数将不能工作</p>
		<p>也就是说，这里存在 makeAdder 的局部变量的两个不同的“副本”——一个是 a 等于5，另一个是 a 等于20</p>

		<h3>原理描述</h3>
		<p>每当 JavaScript 执行一个函数时，都会创建一个作用域对象（scope object）</p>
		<p>用来保存在这个函数中创建的局部变量</p>
		<p>它和被传入函数的变量一起被初始化</p>
		<p>这与那些保存的所有全局变量和函数的全局对象（global object）类似，但仍有一些很重要的区别</p>
		<ul>
			<li>第一，每次函数被执行的时候，就会创建一个新的，特定的作用域对象</li>
			<li>第二，与全局对象（在浏览器里面是当做 window 对象来访问的）不同的是，你不能从 JavaScript 代码中直接访问作用域对象，也没有可以遍历当前的作用域对象里面属性的方法</li>
		</ul>

		<p>所以当调用 makeAdder 时，解释器创建了一个作用域对象</p>
		<p>它带有一个属性：a，这个属性被当作参数传入 makeAdder 函数</p>
		<p>然后 makeAdder 返回一个新创建的函数</p>
		<p>通常 JavaScript 的垃圾回收器会在这时回收 makeAdder 创建的作用域对象</p>
		<p>但是返回的函数却保留一个指向那个作用域对象的引用</p>
		<p>结果是这个作用域对象不会被垃圾回收器回收，直到指向 makeAdder 返回的那个函数对象的引用计数为零</p>


		<p>作用域对象组成了一个名为作用域链（scope chain）的链</p>
		<p>它类似于原形（prototype）链一样，被 JavaScript 的对象系统使用</p>
		<p>一个闭包就是一个函数和被创建的函数中的作用域对象的组合</p>
		<p>闭包允许你保存状态——所以它们通常可以代替对象来使用</p>




		<h2>内存泄露</h2>
		<p>使用闭包的一个坏处是，在 IE 浏览器中它会很容易导致内存泄露</p>
		<p>JavaScript 是一种具有垃圾回收机制的语言</p>
		<p>对象在被创建的时候分配内存，然后当指向这个对象的引用计数为零时，浏览器会回收内存</p>
		<p>宿主环境提供的对象都是按照这种方法被处理的</p>

		<p>浏览器主机需要处理大量的对象来描绘一个正在被展现的 HTML 页面——DOM 对象</p>
		<p>浏览器负责管理它们的内存分配和回收</p>

		<p>IE 浏览器有自己的一套垃圾回收机制，这套机制与 JavaScript 提供的垃圾回收机制进行交互时，可能会发生内存泄露</p>

		<h3>具体事例</h3>
		<p>在 IE 中，每当在一个 JavaScript 对象和一个本地对象之间形成循环引用时，就会发生内存泄露</p>
		<div id="el" style="width:100px; height: 100px;; background-color:blue;"></div>
		<script>
			function leakMemory() {
				var el = document.getElementById('el');
				var o = {'el': el};
				el.o = o;
			}
		</script>
		<h3>代码描述</h3>
		<p>这段代码的循环引用会导致内存泄露：IE 不会释放被 el 和 o 使用的内存，直到浏览器被彻底关闭并重启后</p>
		<p>不过一般也很少发生如此明显的内存泄露现象——通常泄露的数据结构有多层的引用(references)</p>
		<p>往往掩盖了循环引用的情况</p>

		<p>闭包很容易发生无意识的内存泄露</p>
		<script>
			function addHandler() {
				var el = document.getElementById('el');
				el.onclick = function() {
					el.style.backgroundColor = 'red';
					el.style.width = '20px';
					el.style.height = '30px';
				}
			}
		</script>
		<h3>代码描述</h3>
		<p>这段代码创建了一个元素，当它被点击的时候变红，但同时它也会发生内存泄露</p>
		<p>因为对 el 的引用不小心被放在一个匿名内部函数中</p>
		<p>这就在 JavaScript 对象（这个内部函数）和本地对象之间（el）创建了一个循环引用</p>

		<p>最简单的一种是不要使用 el 变量</p>
		<script>
			function addHandler() {
				document.getElementById('el').onclick = function() {
					this.style.backgroundColor = 'red';
				};
			}
		</script>

		<p>有趣的是，有一种窍门解决因闭包而引入的循环引用，是添加另外一个闭包</p>
		<div id="asd" style="width:100px;height: 100px;background-color:blue;"></div>
		<script>
			function addHandler() {
				var clickHandler = function() {
					this.style.backgroundColor = 'red';
				};
				(function() {
					var el = document.getElementById('asd');
					el.onclick = clickHandler;
				})();
			}
		</script>
		
		<p>内部函数被直接执行，并在 clickHandler 创建的闭包中隐藏了它的内容</p>

		<h3>注意:</h3>
		<p>外一种避免闭包的好方法是在 window.onunload 事件发生期间破坏循环引用</p>
		<p>注意这样做将使 Firefox 中的 bfcache 无法工作</p>
		<p>所以除非有其他必要的原因，最好不要在 Firefox 中注册一个unload 的监听器</p>










		<h1>通过网络了解闭包</h1>
		<p>变量的作用域无非就是两种：全局变量和局部变量</p>
		<p>Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量</p>
		<script>
			var n = 999;
			function f1() {
				console.log(n);
			}
			f1();
			// 999
		</script>

		<p>另一方面，在函数外部自然无法读取函数内的局部变量</p>
		<script>
			function f1() {
				n1=999;
			}
			// console.log(n1);
			// Uncaught ReferenceError: n1 is not defined
		</script>
		<h3>注意，函数内部声明变量的时候，一定要使用var命令</h3>
		<p>如果不用的话，你实际上声明了一个全局变量</p>
		<script>
			function f1() {
				n1=999;
			}
			// console.log(n1);
			// Uncaught ReferenceError: n1 is not defined
			f1();
			console.log(n1);
			// 999
		</script>


		<h2>从外部读取局部变量</h2>
		<p>有时候需要得到函数内的局部变量</p>
		<script>
			function f1() {
				n1=999;
				function f2() {
					console.log(n1);
				}
			}
		</script>
		<h3>代码描述</h3>
		<p>函数f2就被包括在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的</p>
		<p>但是反过来就不行，f2内部的局部变量，对f1 就是不可见的</p>
		<p>这就是Javascript语言特有的“链式作用域”结构</p>

		<p>子对象会一级一级地向上寻找所有父对象的变量</p>
		<p>所以，父对象的所有变量，对子对象都是可见的，反之则不成立</p>
		<p>既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，就可以在f1外部读取它的内部变量</p>
		<script>
			function f1() {
				n2=99999;
				function f2() {
					console.log(n2);
				}
				return f2;
			}
			var result = f1();
			console.log(f1());
			// function f2() {
			// 	console.log(n2);
			// }
			result();
			// 99999
		</script>

		<h3>概念总结</h3>
		<p>闭包就是能够读取其他函数内部变量的函数</p>
		<p>由于在Javascript语言中，只有函数内部的子函数才能读取局部变量</p>
		<p>因此可以把闭包简单理解成“定义在一个函数内部的函数”</p>
		<p>在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁</p>

		<h3>闭包的用途</h3>
		<ul>
			<li>一个是可以读取函数内部的变量</li>
			<li>另一个就是让这些变量的值始终保持在内存中</li>
		</ul>
		<script>
			function f1() {
				var n3 = 888;
				nAdd = function() {
					n3 += 112;
				}
				/*注意不能写成下面的格式否则无法调用下面的方法*/
				// function nAdd() {
				// 	n3 += 112;
				// }
				function f2() {
					console.log(n3);
				}
				return f2;
			}
			var result = f1();
			result();
			// 888
			nAdd();
			result();
			// 1000
		</script>
		<h3>代码描述</h3>
		<p>result实际上就是闭包f2函数</p>
		<p>它一共运行了两次，第一次的值是999，第二次的值是1000</p>
		<p>这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除</p>
		<p>原因就在于f1是f2的父函数，而f2被赋给了一个全局变量</p>
		<p>这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中</p>
		<p>不会在调用结束后，被垃圾回收机制（garbage collection）回收</p>

		<h3>注意:就是“nAdd=function(){n+=1}”这一行</h3>
		<p>首先在nAdd前面没有使用var关键字，因此 nAdd是一个全局变量，而不是局部变量</p>
		<p>其次，nAdd的值是一个匿名函数（anonymous function）</p>
		<p>而这个匿名函数本身也是一个闭包</p>
		<p>所以nAdd相当于是一个setter，可以在函数外部对函数内部的局部变量进行操作</p>

		<h2>使用闭包的注意点</h2>
		<ul>
			<li>
				<p>由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大</p>
				<p>所以不能滥用闭包，否则会造成网页的性能问题</p>
				<p>在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除</p>
			</li>
			<li>
				<p>闭包会在父函数外部，改变父函数内部变量的值</p>
				<p>所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method）</p>
				<p>把内部变量当作它的私有属性（private value），这时一定要小心</p>
			</li>
		</ul>
		<h2>运行机制</h2>
		<script>
			var name = "The Window";
			console.log(name);
			// The Window
			var object = {
				name: "my Object",
				getNameFunc: function() {
					return function() {
						return this.name;
					};
				}
			};
			console.log(object.getNameFunc()());
			// The Window
			console.log(object);
			// Object {name: "my Object"}
				// getNameFunc: function () { return function() { return this.name; }; }
					// arguments: null
					// caller: null
					// length: 0
					// name: ''
					// prototype: Object
						/*从这开始*/
						// constructor: function () { return function() { return this.name; }; }
							// arguments: null
							// caller: null
							// length: 0
							// name: ''
							// prototype: Object
								// constructor: function () { return function() { return this.name; }; }
								// __proto__: function() {}
							// __proto__:function() {}
							// <function scope>
						/*到这结束中间无限循环*/
						// __proto__: Object
					// __proto__: function() {}
					// <function scope>
				// name: "my Object"
				// __proto__:Object
			console.log(name);
			// The Window
			console.log(getNameFunc);
			// Uncaught ReferenceError: getNameFunc is not defined
			console.log(getNameFunc());
			// Uncaught ReferenceError: getNameFunc is not defined
		</script>

		<h3>一个错误的闭包栗子</h3>
		<script>
			function outerFun() {
				var a = 0;
				function innerFun() {
					a++;
					console.log(a);
				}
			}
			innerFun();
			// Uncaught ReferenceError: innerFun is not defined
		</script>
		<h4>代码描述</h4>
		<p>代码是错误的.innerFun()的作用域在outerFun()内部</p>
		<p>所在outerFun()外部调用它是错误的</p>
		<h3>改正</h3>
		<script>
			function outerFun() {
				var a = 0;
				function innerFun() {
					a++;
					console.log(a);
				}
				return innerFun;
			}

			var obj = outerFun();
			obj();
			// 1
			obj();
			// 2
			var obj2 = outerFun();
			obj2();
			// 1
			obj2();
			// 2
		</script>
		<h4>代码描述</h4>
		<p>当内部函数 在定义它的作用域 的外部 被引用时,就创建了该内部函数的闭包</p>
		<p>如果内部函数引用了位于外部函数的变量</p>
		<p>当外部函数调用完毕后,这些变量在内存不会被 释放,因为闭包需要它们</p>

		<h3>再来一个例子</h3>
		<script>
			function outerFun() {
				var a = 0;
				console.log(a);
			}
			var a = 4;
			outerFun();
			// 0
			console.log(a);
			// 4
		</script>
		<h3>代码描述:</h3>
		<p>因为在函数内部使用了var关键字 维护a的作用域在outFun()内部</p>

		<script>
			function outerFun() {
				a = 0;
				console.log(a);
			}
			var a = 4;
			outerFun();
			// 0
			console.log(a);
			// 0
		</script>
		<h3>代码描述</h3>
		<p>作用域链是描述一种路径的术语,沿着该路径可以确定变量的值</p>
		<p>当执行a=0时,因为没有使用var关键字</p>
		<p>因此赋值操作会沿着作用域链到var a=4;  并改变其值</p>










		<h1>js中遍历对象的属性和值</h1>
		<script>
			function allPrpos ( obj ) { 
				// 用来保存所有的属性名称和值 
				var props = "" ; 
				// 开始遍历 
				for ( var p in obj ){ // 方法 
					if ( typeof ( obj [ p ]) == " function " ){
						obj[p](); 
						} else { // p 为属性名称，obj[p]为对应属性的值 
						props += p + " = " + obj [ p ] + " /t " ; 
					}
				} // 最后显示所有的属性 
				alert ( props ) ;
			}
		</script>










		<h1>闭包详解</h1>
		<p>JavaScript中所有的function都是一个闭包</p>
		<p>嵌套的function所产生的闭包更为强大，也是大部分时候我们所谓的“闭包”</p>
		<script>

		</script>
	</body>
</html>
