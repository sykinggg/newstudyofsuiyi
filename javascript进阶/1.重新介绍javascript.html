<!doctype html>
<html>
	<head>
		<meta charset="">
	</head>
	<body>
		<h1>概览</h1>
		<p>javascript中包含的类型</p>
		<ul>
			<li>Number（数字）</li>
			<li>String（字符串）</li>
			<li>Boolean（布尔）</li>
			<li>Symbol（符号）（第六版新增）</li>
			<li>
				Object（对象）
				<ul>
					<li>Function（函数）</li>
					<li>Array（数组）</li>
					<li>Date（日期）</li>
					<li>RegExp（正则表达式）</li>
				</ul>
			</li>
			<li>Null（空）</li>
			<li>Undefined（未定义）</li>
		</ul>
		<p>JavaScript 还有一种内置Error（错误）类型</p>










		<h1>数字</h1>
		<p>JavaScript 采用“IEEE 754 标准定义的双精度64位格式”（"double-precision 64-bit format IEEE 754 values"）表示数字</p>
		<p>JavaScript 不区分整数值和浮点数值</p>
		<script>
			// 0.1 + 0.2 = 0.3000000000004;
			/*Uncaught ReferenceError: Invalid left-hand side in assignment*/
			// 0.4 = 0.1 + 0.3;
			console.log(0.1 + 0.2);
			/*0.30000000000000004*/
		</script>
		<p>JavaScript 支持标准的算术运算符，包括加法、减法、取模（或取余）</p>
		<p>内置对象 Math（数学对象），用以处理更多的高级数学函数和常数</p>
		<script>
			Math.sin(3.5);
			console.log(Math.sin(3.5));
			/*-0.35078322768961984*/
			var r = 10;
			var d = Math.PI*(r + r);
			console.log(d);
			/*62.83185307179586*/
		</script>

		<h2>parseInt()</h2>
		<p>可以使用内置函数 parseInt() 将字符串转换为整型</p>
		<p>该函数的第二个参数表示字符串所表示数字的基（进制）</p>
		<script>
			parseInt('123', 10);
			console.log(parseInt('123', 10));
			/*123*/
			parseInt('010', 2);
			console.log(parseInt('010', 2));
			/*2*/
			parseInt('010', 10);
			console.log(parseInt('010', 10));
			/*10*/
		</script>
		<p>如果调用时没有提供第二个参数（字符串所表示数字的基）</p>
		<p>2013 年以前的 JavaScript 实现会返回一个意外的结果</p>
		<script>
			parseInt('010');
			console.log(parseInt('010'));
			/*10*/
			parseInt('0x10');
			console.log(parseInt('0x10'));
			/*16*/
		</script>
		<p>字符串以数字 0 开头，parseInt()函数会把这样的字符串视作八进制数字</p>
		<p>0x开头的字符串则视为十六进制数字</p>
		<p>把一个二进制数字字符串转换成整数值，只要把第二个参数设置为 2 就可以了</p>
		<script>
			parseInt('11', 2);
			console.log(parseInt('11', 2));
			/*3*/
		</script>

		<h2>parseFolat()</h2>
		<p>parseFloat()只应用于解析十进制数字</p>
		<p>单元运算符 + 也可以把数字字符串转换成数值</p>
		<script>
			console.log(+"42");
			/*42*/
			console.log(+"010");
			/*10*/
			console.log(+"0x10");
			/*16*/
		</script>
		<p>如果给定的字符串不存在数值形式，函数会返回一个特殊的值 NaN（Not a Number 的缩写）</p>
		<script>
			parseInt("hello", 10);
			console.log(parseInt("hello", 10));
			/*NaN*/
		</script>
		<h3>注意:</h3>
		<p>要小心NaN：如果把 NaN 作为参数进行任何数学运算，结果也会是 NaN</p>
		<script>
			console.log(NaN + 5);
			/*NaN*/
		</script>
		<h3>解决方法</h3>
		<p>可以使用内置函数 isNaN() 来判断一个变量是否为 NaN</p>
		<script>
			console.log(isNaN(NaN));
			/*true*/
		</script>
		<p>JavaScript 还有两个特殊值：Infinity（正无穷）和 -Infinity（负无穷）</p>
		<script>
			1 / 0;
			console.log(1/0);
			/*Infinity*/
			-1 / 0;
			console.log(-1/0);
			/*-Infinity*/
		</script>
		<p>可以使用内置函数 isFinite() 来判断一个变量是否为 Infinity, -Infinity 或 NaN</p>
		<script>
			isFinite(1/0);
			console.log(isFinite(1/0));
			/*false*/
			isFinite(-Infinity);
			console.log(isFinite(-Infinity));
			/*false*/
			isFinite(Infinity);
			console.log(isFinite(Infinity));
			/*false*/
			isFinite(NaN);
			console.log(isFinite(NaN));
			/*false*/
			isFinite(54);
			console.log(isFinite(54));
			/*true*/
		</script>
		<h3>注意:</h3>
		<p>parseInt()和parseFloat()函数会尝试逐个解析字符串中的字符，直到遇上一个无法被解析成数字的字符，然后返回该字符前所有数字字符组成的数字</p>
		<p>使用运算符 "+" 将字符串转换成数字，只要字符串中含有无法被解析成数字的字符，该字符串都将被转换成 NaN</p>
		<script>
			console.log(parseInt("10.2abc"));
			/*10*/
			console.log(+("10.2abc"));
			/*NaN*/
		</script>










		<h1>字符串</h1>
		<p>JavaScript 中的字符串是一串Unicode 字符序列</p>
		<p>是一串UTF-16编码单元的序列，每一个编码单元由一个 16 位二进制数表示</p>
		<p>每一个Unicode字符由一个或两个编码单元来表示</p>

		<p>如果想表示一个单独的字符，只需使用长度为 1 的字符串</p>

		<p>通过访问字符串的  长度（编码单元的个数）属性可以得到它的长度</p>
		<script>
			console.log("hello".length);
			/*5*/
		</script>
		<p>字符串也有methods（方法）能让你操作字符串和获取字符串的信息</p>
		<script>
			"hello".charAt(0);
			console.log("hello".charAt(0));
			/*h*/
			"hello, World".replace("hello", "goodbye");
			console.log("hello, World".replace("hello", "goodbye"));
			/*goodbye, World*/
			"hello".toUpperCase();
			console.log("hello".toUpperCase());
			/*HELLO*/
			console.log("hello");
		</script>










		<h1>其他类型</h1>
		<p>JavaScript 中 null 和 undefined 是不同的</p>
		<p>前者表示一个空值（non-value），必须使用null关键字才能访问</p>
		<p>后者是“undefined（未定义）”类型的对象，表示一个未初始化的值，也就是还没有被分配的值</p>
		<h3>注意:</h3>
		<p>JavaScript 允许声明变量但不对其赋值，一个未被赋值的变量就是 undefined 类型</p>
		<p>undefined 实际上是一个不允许修改的常量</p>

		<p>JavaScript 包含布尔类型，这个类型的变量有两个可能的值，分别是 true 和 false（两者都是关键字）</p>
		<ul>
			<li>false、0、空字符串("")、NaN、null 和 undefined 被转换为 false</li>
			<li>所有其他值被转换为 true</li>
		</ul>
		<p>可以使用 Boolean() 函数进行显式转换</p>
		<script>
			Boolean(false);
			console.log(Boolean(false));
			/*false*/
			Boolean(undefined);
			console.log(Boolean(undefined));
			/*false*/
			Boolean(null);
			console.log(Boolean(null));
			/*false*/
			Boolean(" ");
			console.log(Boolean(" "));
			/*true*/
			Boolean(234);
			console.log(Boolean(234));
			/*true*/
		</script>
		<p>因为 JavaScript 会在需要一个布尔变量时隐式完成这个转换操作（比如在 if 条件语句中）</p>
		<span>有时我们可以把转换成布尔值后的变量分别称为 真值（true values）——即值为 true  和 假值（false values）——即值为 false；也可以分别称为“真的”（truthy）和“假的”（falsy）</span>
		<p>JavaScript 支持包括 &&（逻辑与）、|| （逻辑或）和!（逻辑非）在内的逻辑运算符</p>










		<h1>变量</h1>
		<p>在 JavaScript 中声明一个新变量的方法是使用关键字 var</p>
		<script>
			var a;
			console.log(a);
			/*undefined*/
		</script>
		<p>如果声明了一个变量却没有对其赋值，那么这个变量的类型就是 undefined</p>
		<h3>注意:</h3>
		<p>JavaScript 与其他语言的（如 Java）的重要区别是在 JavaScript 中语句块（blocks）是没有作用域的，只有函数有作用域</p>
		<p>因此如果在一个复合语句中（如 if 控制结构中）使用 var 声明一个变量，那么它的作用域是整个函数（复合语句在函数中）</p>
		<p>从 ECMAScript Edition 6 开始将有所不同的， let 和 const 关键字允许你创建块作用域的变量</p>










		<h1>运算符</h1>
		<p>JavaScript的算术操作符包括 +、-、*、/ 和 % ——求余（与模运算不同）</p>
		<p>赋值使用 = 运算符，此外还有一些复合运算符，如 += 和 -=，它们等价于 x = x op y</p>
		<script>
			var x = 0;
			x += 5;
			x = x + 5;
		</script>
		<p>可以使用 ++ 和 -- 分别实现变量的自增和自减</p>
		<h3>注意:</h3>
		<p>两者都可以作为前缀或后缀操作符使用但执行顺序不同</p>

		<p>+ 操作符还可以用来连接字符串</p>
		<script>
			'hello' + ' world';
			console.log('hello' + ' world');
			// hello world
		</script>

		<p>用一个字符串加上一个数字（或其他值），那么操作数都会被首先转换为字符串</p>
		<script>
			'3' + 4 + 5;
			console.log('3' + 4 + 5);
			// 345
			3 + 4 + '5';
			console.log(3 + 4 + '5');
			// 75
		</script>
		<h3>注意:</h3>
		<p>一个实用的技巧——通过与空字符串相加，可以将某个变量快速转换成字符串类型</p>

		<p>JavaScript 中的比较操作使用 <、>、<= 和 >=，这些运算符对于数字和字符串都通用</p>
		<p>由两个“=（等号）”组成的相等运算符有类型自适应的功能</p>
		<script>
			123 == '123';
			console.log(123 == '123');
			// true
			1 == true;
			// true
			console.log(1 == true);
		</script>
		<p>如果在比较前不需要自动类型转换，应该使用由三个“=（等号）”组成的相等运算符</p>
		<script>
			1 === 123;
			console.log(1 === 123);
			// false
			'123' === 123;
			console.log('123' === 123);
			// false
			123 + '' === 123;
			console.log(123 + '' === 123);
			// false
		</script>
		<p>JavaScript 还支持 != 和 !== 两种不等运算符，具体区别与两种相等运算符的区别类似</p>
		<h3>注意:</h3>
		<p>JavaScript 还提供了 位操作符</p><span>完全看不懂</span>










		<h1>控制结构</h1>
		<p>JavaScript 的控制结构与其他类 C 语言类似</p>
		<p>使用 if 和 else 来定义条件语句，还可以连起来使用</p>
		<script>
			var name = "kittens";
			if (name == "puppies") {
				name += '!';
			} else if (name == "kittens") {
				name += "!!";
			} else {
				name = "!" + name;
			}
			name == "kittens!!";
			console.log(name == "kittens!!");
			// true
		</script>

		<p>JavaScript 支持 while 循环和 do-while 循环</p>
		<h3>注意:</h3>
		<p>前者适合常见的基本循环操作，如果需要循环体至少被执行一次则可以使用 do-while</p>
		<script>
			// while (true) {
			// 	// 一个无限循环！
			// }

			var input;
			do {
				input = get_input();
			} while (inputIsNotValid(input))
		</script>

		<p>JavaScript 的 for 循环与 C 和 Java 中的相同，使用时可以在一行代码中提供控制信息</p>
		<script>
			for (var i = 0; i < 5; i++) {
				// 将会执行五次
			}
		</script>

		<p>&& 和 || 运算符使用短路逻辑（short-circuit logic），是否会执行第二个语句（操作数）取决于第一个操作数的结果</p>
		<h3>注意:</h3>
		<p>在需要访问某个对象的属性时，使用这个特性可以事先检测该对象是否为空</p>
		<script>
			var name = o && o.getName();
		</script>
		<p>或运算可以用来设置默认值</p>
		<script>
			var name = otherName || 'default';
		</script>
		<p>JavaScript 也有一个用于条件表达式的三元操作符</p>
		<script>
			var allowed = (age > 18) ? "yes" : "no";
		</script>
		<p>需要多重分支时可以使用  基于一个数字或字符串的switch 语句</p>
		<script>
			switch(action) {
				case 'draw':
					drawIt();
					break;
				case 'eat':
					edtIt();
					break;
				default:
					doNothing();
			}
		</script>
		<h3>概念说明:</h3>
		<p>如果你不使用 break 语句，JavaScript 解释器将会执行之后 case 中的代码</p>
		<p>除非是为了调试，一般你并不需要这个特性，所以大多数时候不要忘了加上 break</p>
		<script>
			switch(a) {
				case 1: // 继续向下
				case 2:
					edtIt();
					break;
				default:
					doNothing();
			}
		</script>
		<h3>详细说明</h3>
		<p>default 语句是可选的</p>
		<p>switch 和 case 都可以使用需要运算才能得到结果的表达式</p>
		<p>在 switch 的表达式和 case 的表达式是使用 === 严格相等运算符进行比较的</p>
		<script>
			switch(1 + 3) {
				case 2 + 2:
					yay();
					break;
				default:
					neverhappens();
			}
		</script>










		<h1>对象</h1>
		<p>JavaScript 中的对象可以简单理解成“名称-值”对</p>
		<ul>
			<li>Python 中的字典</li>
			<li>Perl 和 Ruby 中的散列（哈希）</li>
			<li>C/C++ 中的散列表</li>
			<li>Java 中的 HashMap</li>
			<li>PHP 中的关联数组</li>
		</ul>
		<h2>javascript的优势</h2>
		<span>正因为 JavaScript 中的一切（除了核心类型，core object）都是对象，所有 JavaScript 程序必然与大量的散列表查找操作有着千丝万缕的联系，而散列表擅长的正是高速查找</span>
		<p>“名称”部分是一个 JavaScript 字符串，“值”部分可以是任何 JavaScript 的数据类型——包括对象</p>
		<p>有两种简单方法可以创建一个空对象</p>
		<script>
			var obj1 = new Object();
			console.log(obj1);
			// Object__proto__: Object
			var obj2 = {};
			console.log(obj2);
			// Object__proto__: Object
		</script>
		<h3>代码描述:</h3>
		<p>这两种方法在语义上是相同的</p>
		<p>第二种更方便的方法叫作“对象字面量（object literal）”法</p>
		<p>这种也是 JSON 格式的核心语法，一般我们优先选择第二种方法</p>

		<p>“对象字面量”也可以用来在对象实例中定义一个对象</p>
		<script>
			var obj = {
				name: "Carrot",
				"for": "Max",
				details: {
					color: "orange",
					size: 12
				}
			}
			console.log(obj);
			// Object {name: "Carrot", for: "Max", details: Object}
		</script>
		<p>对象的属性可以通过链式（chain）表示方法进行访问</p>
		<script>
			var obj = {
				name: "Carrot",
				"for": "Max",
				details: {
					color: "orange",
					size: 12
				}
			}
			obj.details.color;
			console.log(obj.details.color);
			// orange
			obj["details"]["size"];
			console.log(obj["details"]["size"]);
			// 12
		</script>
		<p>创建一个对象原型，Person，和这个原型的实例，You</p>
		<script>
			function Person(name, age) {
				this.name = name;
				this.age = age;
			}

			// 定义一个对象
			var You = new Person("You", 24);
			// 创建一个新的 Person，名称是 "You"
			// ("You" 是第一个参数, 24 是第二个参数..)
		</script>
		<p>完成创建后，对象属性可以通过如下两种方式进行赋值和访问</p>
		<script>
			obj.name = "Simon1";
			var name = obj.name;
			console.log(name);
			// Simon1

			obj["name"] = "Simon2";
			var name = obj["name"];
			console.log(name);
			// Simon2
		</script>
		<h3>注意:</h3>
		<p>这两种方法在语义上也是相同的</p>
		<p>第二种方法的优点在于属性的名称被看作一个字符串，这就意味着它可以在运行时被计算</p>
		<p>缺点在于这样的代码有可能无法在后期被解释器优化</p>
		<p>也可以被用来访问某些以预留关键字作为名称的属性的值</p>
		<script>
			obj.for = "Simon";
			// 应该是报错的:语法错误，因为 for 是一个预留关键字
			// 但是没有报错
			// obj["for"] = "Simon";
			console.log(obj);
			// Object {name: "Simon2", for: "Simon", details: Object}
		</script>
		<h3>注意:</h3>
		<p>从 EcmaScript 5 开始，预留关键字可以作为对象的属性名</p>
		<p>这意味着当定义对象字面量时不需要用双引号了</p>
		<h3>关于对象和原型的详情参见： Object.prototype</h3>











		<h1>数组</h1>
		<p>JavaScript 中的数组是一种特殊的对象</p>
		<p>它的工作原理与普通对象类似（以数字为属性名，但只能通过[] 来访问），但数组还有一个特殊的属性——length（长度）属性</p>
		<p>这个属性的值通常比数组最大索引大 1</p>

		<p>创建数组的传统方法</p>
		<script>
			var a = new Array();
			a[0] = "dog";
			a[1] = "cat";
			a[2] = "hen";
			console.log(a.length);
			// 3
			a[10] = "wangde";
			console.log(a.length);
			// 11
		</script>

		<p>使用数组字面量（array literal）法更加方便</p>
		<script>
			var a = ["dog", "cat", "hen"];
			console.log(a.length);
			// 3
			console.log(a);
			// ["dog", "cat", "hen"]
		</script>

		<h3>注意，Array.length 并不总是等于数组中元素的个数</h3>
		<script>
			var a = ["dog", "cat", "hen"];
			a[100] = "fox";
			console.log(a.length);
			// 101
			console.log(a);
			// ["dog", "cat", "hen", 100: "fox"]
		</script>
		<h3>记住：数组的长度是比数组最大索引值多一的数</h3>

		<p>如果试图访问一个不存在的数组索引，会得到 undefined</p>
		<script>
			var a = ["dog", "cat", "hen"];
			console.log(a[90]);
			// undefined
			typeof(a[90]);
			console.log(typeof(a[90]));
			// undefined
		</script>

		<p>可以通过如下方式遍历一个数组</p>
		<script>
			var a = ["dog", "cat", "hen"];

			for(var i = 0; i < a.length; i++){
				console.log(a[i]);
			}
		</script>
		<h3>注意:</h3>
		<p>这么做效率不太好，因为每循环一次都要计算一次长度</p>
		<p>改进的版本</p>
		<script>
			var a = ["dog", "cat", "hen"];

			for(var i = 0, len=a.length; i < len; i++) {
				console.log(a[i]);
			}
		</script>
		<p>还有一种更简洁但是有使用局限的写法</p>
		<script type="text/javascript">
			for (var i = 0, item; item = a[i++]; ) {
				// Do something with item
			}
		</script>
		<h3>注意:</h3>
		<p>使用了两个变量</p>
		<p>for 循环中间部分的赋值表达式同时也用来判断是否为真——如果为真，那么循环继续</p>
		<p>因为 i 每次递增 1，这个数组的元素会被逐个传递给 item 变量</p>
		<p>当遇到一个假值元素（如 undefined ）时，循环结束</p>

		<h3>注意:</h3>
		<p>注意这个技巧只能在你知道数组中不含假值（例如对象或DOM节点的数组）时才可以使用</p>
		<p>如果想要遍历可能包含 0 或空字符串的数组，应该使用 i, len 的写法</p>

		<p>遍历数组的另一种方法是使用 for...in 循环</p>
		<h3>注意，如果有人向 Array.prototype 添加了新的属性，使用这样的循环这些属性也同样会被遍历</h3>
		<p>所以并不推荐这种方法</p>
		<script>
			for (var i in a) {
				// Do something with a[i]
			}
		</script>

		<p>ECMAScript 5 增加了遍历数组的另一个方法 forEach()</p>
		<script>
			["dog", "cat", "hen"].forEach(function(currentValue, index, array) {
				// Do something with currentValue or array[index]
			})
		</script>

		<p>如果想在数组后追加元素，只需要</p>
		<script>
			a.push(item);
		</script>

		<p>Array（数组）类自带了许多方法</p>
		<table>
			<thead>
				<tr>
					<td>方法名称</td><td>描述</td>
				</tr>
			</thead>
			<tbody>
				<tr>
					<td>a.toString()</td>
					<td>返回一个包含数组中所有元素的字符串，每个元素通过逗号分隔</td>
					<script>
						var a = ["dog", "cat", "hen"];
						var b = ["dog1", "cat1", "hen1"];
						console.log(a.toString());
						// dog,cat,hen
						console.log(a.toString(1));
						// dog,cat,hen
						a.toString();
						console.log(a);
						// ["dog", "cat", "hen"]
					</script>
				</tr>
				<tr>
					<td>a.toLocaleString()</td>
					<td>根据宿主环境的区域设置，返回一个包含数组中所有元素的字符串，每个元素通过逗号分隔</td>
					<script>
						var a = ["dog", "cat", "hen"];
						var b = ["dog1", "cat1", "hen1"];
						console.log(a.toLocaleString());
						// dog,cat,hen
						console.log(a.toLocaleString(1));
						// dog,cat,hen
						a.toLocaleString();
						console.log(a);
						// ["dog", "cat", "hen"]
					</script>
				</tr>
				<tr>
					<td>a.concat(item[, item[, ...[, itemN]]])</td>
					<td>返回一个数组，这个数组包含原先 a 和 item1、item2、……、itemN 中的所有元素</td>
					<script>
						var a = ["dog", "cat", "hen"];
						var b = ["dog1", "cat1", "hen1"];
						console.log(a.concat());
						// ["dog", "cat", "hen"]
						console.log(a.concat("dog"));
						// ["dog", "cat", "hen", "dog"]
						console.log(a.concat("dog"["cat"]));
						// ["dog", "cat", "hen", undefined]
						a.concat("dog");
						console.log(a);
						// ["dog", "cat", "hen"]
					</script>
				</tr>
				<tr>
					<td>a.join(sep)</td>
					<td>返回一个包含数组中所有元素的字符串，每个元素通过指定的 sep 分隔</td>
					<script>
						var a = ["dog", "cat", "hen"];
						var b = ["dog1", "cat1", "hen1"];
						console.log(a);
						// ["dog", "cat", "hen"]
						a.join(b);
						console.log(a);
						// ["dog", "cat", "hen"]
						console.log(a.join(b));
						// dogdog1,cat1,hen1catdog1,cat1,hen1hen
					</script>
				</tr>
				<tr>
					<td>a.pop()</td>
					<td>删除并返回数组中的最后一个元素</td>
					<script>
						var a = ["dog", "cat", "hen"];
						var b = ["dog1", "cat1", "hen1"];
						console.log(a.pop());
						// hen
						console.log(a);
						// ["dog", "cat"]
					</script>
				</tr>
				<tr>
					<td>a.push(item1, ..., itemN)</td>
					<td>将 item1、item2、……、itemN 追加至数组 a</td>
					<script>
						var a = ["dog", "cat", "hen"];
						var b = ["dog1", "cat1", "hen1"];
						var c = "fox";
						var d = 1;
						console.log(a.push(b));
						// 4
						console.log(a.push(c));
						// 5
						console.log(a.push(d));
						// 6
						a.push(b);
						console.log(a);
						// ["dog", "cat", "hen", Array[3], "fox", 1, Array[3]]
						a.push(c);
						console.log(a);
						// ["dog", "cat", "hen", Array[3], "fox", 1, Array[3], "fox"]
						a.push(d);
						console.log(a);
						// ["dog", "cat", "hen", Array[3], "fox", 1, Array[3], "fox", 1]
					</script>
				</tr>
				<tr>
					<td>a.reverse()</td>
					<td>数组逆序（会更改原数组 a）</td>
					<script>
						var a = ["dog", "cat", "hen"];
						console.log(a.reverse());
						// ["hen", "cat", "dog"]
						console.log(a);
						// ["hen", "cat", "dog"]
						a.reverse();
						console.log(a);
						// ["dog", "cat", "hen"]
					</script>
				</tr>
				<tr>
					<td>a.shift()</td>
					<td>删除并返回数组中第一个元素</td>
					<script>
						var a = ["dog", "cat", "hen"];
						console.log(a.shift());
						// dog
						console.log(a);
						// ["cat", "hen"]
						a.shift();
						console.log(a);
						// ["hen"]
					</script>
				</tr>
				<tr>
					<td>a.slice(start, end)</td>
					<td>返回子数组，以 a[start] 开头，以 a[end] 前一个元素结尾</td>
					<script>
						var a = ["dog", "cat", "hen"];
						console.log(a.slice(0, 1));
						// ["dog"]
						console.log(a.slice(a[0], a[1]));
						// []
						console.log(a.slice("dog", "cat"));
						// []
						console.log(a);
						// ["dog", "cat", "hen"]
						a.slice(0, 1);
						console.log(a);
						// ["dog", "cat", "hen"]
					</script>
				</tr>
				<tr>
					<td>a.sort([cmpfn])</td>
					<td>依据 cmpfn 返回的结果进行排序，如果未指定比较函数则按字符顺序比较（即使元素是数字）</td>
					<script>
						var a = ["dog", "cat", "hen"];
						console.log(a.sort());
						// ["cat", "dog", "hen"]
						console.log(a);
						// ["cat", "dog", "hen"]
					</script>
				</tr>
				<tr>
					<td>a.splice(start, delcount[, item1[, ...[, itemN]]])</td>
					<td>从 start 开始，删除 delcount 个元素，然后插入所有的 item</td>
					<script>
						var a = ["dog", "cat", "hen"];
						var b = ["dog1", "cat1", "hen1"];
						console.log(a.splice(0, 2, b));
						// ["dog", "cat"]
						console.log(a.splice(0, 1, ["dog1", "cat1", "hen1"]));
						// [Array[3]]
						console.log(a);
						// [Array[3], "hen"]
					</script>
				</tr>
				<tr>
					<td>a.unshift([item])</td>
					<td>将 item 插入数组头部，返回数组新长度（考虑 undefined）</td>
					<script>
						var a = ["dog", "cat", "hen"];
						var b = ["dog1", "cat1", "hen1"];
						console.log(a.unshift(b));
						// 4
						console.log(a);
						// [Array[3], "dog", "cat", "hen"]
					</script>
				</tr>
			</tbody>
		</table>










		<h1>函数</h1>
		<p>最重要的就是要理解对象和函数两个部分</p>
		<p>最简单的函数就像下面这个这么简单</p>
		<script>
			function add(x, y) {
				var total = x + y;
				return total;
			}
		</script>
		<h3>代码描述</h3>
		<p>一个 JavaScript 函数可以包含 0 个或多个已命名的变量</p>
		<p>函数体中的表达式数量也没有限制</p>
		<p>你可以声明函数自己的局部变量</p>
		<p>return 语句在返回一个值并结束函数</p>
		<p>如果没有使用 return 语句，或者一个没有值的 return 语句，JavaScript 会返回 undefined</p>

		<p>已命名的参数更像是一个指示而没有其他作用</p>
		<p>如果调用函数时没有提供足够的参数，缺少的参数会被 undefined 替代</p>
		<script>
			add(); //NaN
			// 不能在 undefined 对象上进行加法操作
			console.log(add());
			// NaN
			var add = function(){}
			console.log(add());
			// undefined
		</script>

		<p>还可以传入多于函数本身需要参数个数的参数</p>
		<script>
			function add(x, y) {
				var total = +x + +y;
				return total;
			}
			add(2, 3, 4);
			console.log(add(2, 3, 4));
			// 5
		</script>
		<h3>代码解析</h3>
		<p>函数实际上是访问了函数体中一个名为 arguments 的内部对象</p>
		<p>这个对象就如同一个类似于数组的对象一样，包括了所有被传入的参数</p>
		<p>重写一下上面的函数，使它可以接收任意个数的参数</p>
		<script>
			function add() {
				var sum = 0;
				for(var i = 0, j = arguments.length; i < j; i++) {
					sum += +arguments[i];
				}
				return sum;
			}
			console.log(add(1, 2, 3, 4, 5, 6, 7, 8, 9));
			// 45
		</script>
		<p>跟直接写成 2 + 3 + 4 + 5 也没什么区别</p>

		<p>接下来创建一个求平均数的函数</p>
		<script>
			function avg() {
				var sum = 0;
				for(var i = 0, j = arguments.length; i < j; i++) {
					sum += +arguments[i];
				}
				return sum / arguments.length;
			}
			console.log(avg(1, 2, 3, 4, 5, 6, 7, 8, 9));
			// 5
		</script>
		<p>avg() 函数处理一个由逗号连接的变量串</p>

		<p>如果想得到一个数组的平均值</p>
		<script>
			function avgArray(arr) {
				var sum = 0;
				for(var i = 0, j = arr.length; i < j; i++) {
					sum += arr[i];
				}
				return sum / arr.length;
			}
			console.log(avgArray([2, 3, 4, 5, 6, 7, 8, 9]));
			// 5.5
		</script>

		<h3>注意:</h3>
		<p> JavaScript 允许使用任意函数对象的apply() 方法来调用该函数，并传递给它一个包含了参数的数组</p>
		<script>
			avg.apply(null, [2, 3, 4, 5]);
			console.log(avg.apply(null, [2, 3, 4, 5]));
			// 3.5
		</script>

		<p>JavaScript 允许创建匿名函数</p>
		<script>
			var avg = function() {
				var sum = 0;
				for (var i = 0, j = arguments.length; i < j; i++) {
					sum += +arguments[i];
				}
				return sum / arguments.length;
			}
		</script>
		<h3>代码描述:</h3>
		<p>这个函数在语义上与 function avg() 相同。你可以在代码中的任何地方定义这个函数，就像写普通的表达式一样</p>

		<p>基于这个特性，有人发明出一些有趣的技巧。与 C 中的块级作用域类似，下面这个例子隐藏了局部变量</p>
		<script>
			var a = 1;
			var b = 2;
			console.log(a);
			// 1
			console.log(b);
			// 2
			(function() {
				var b = 3;
				a += b;
			})();
			console.log(a);
			// 4
			console.log(b);
			// 2
		</script>
		
		<h3>注意:</h3>
		<p>JavaScript 允许以递归方式调用函数</p>
		<p>递归在处理树形结构（比如浏览器 DOM）时非常有用</p>
		<script>
			// 没有循环出来！！！！！
			function countChars(elm) {
				if (elm.nodeType == 3) {
					return elm.nodeType.length;
				}
				var count = 0;
				for (var i = 0, child; child = elm.childNodes[i]; i++) {
					count += countChars(child);
				}
				return count;
			}
			// var table = document.getElementsByTagName("table");
			// console.log(countChars(table));
			// 没有循环出来！！！！！
		</script>

		<p>10以内阶乘示例</p>
		<script>
			function fact(num){
				if(num <= 1) {
					return 1;
				}else{
					return num*fact(num-1);
				}
			}
			console.log(fact(5));
			// 120
			// 但是:
			var fact1 = fact;
			console.log(fact1);
			// function fact(num){
			// 	if(num <= 1) {
			// 		return 1;
			// 	}else{
			// 		return num*fact(num-1);
			// 	}
			// }
			fact = null;
			console.log(fact);
			// null
			console.log(fact1);
			// function fact(num){
			// 	if(num <= 1) {
			// 		return 1;
			// 	}else{
			// 		return num*fact(num-1);
			// 	}
			// }
			console.log(fact1(4));
			// fact is not a function
		</script>
		<h3>代码描述:</h3>
		<p>由于fact已经不是函数了，所以出错</p>
		<p>用arguments.callee可解决问题，这是一个指向正在执行的函数的指针</p>
		<script>
			function fact(num) {
				if(num <= 1) {
					return 1;
				}else{
					return num*arguments.callee(num-1);
				}
			}
			console.log(fact(5));
			// 120

			var fact1 = fact;
			fact = null;
			console.log(fact1(4));
			// 24
		</script>










		<h1>自定义对象</h1>
		<p>对象是指数据和在这些数据上进行的操作的集合</p>
		<p>JavaScript 是一种基于原型的编程语言，并没有 class 语句，而是把函数用作类</p>
		<script>
			function makePerson(first, last) {
				return {
					first: first,
					last: last
				}
			}

			function personFullName(person) {
				return person.first + " " + person.last;
			}

			function personFullNameReversed(person) {
				return person.last + "," + person.last;
			}

			s = makePerson("Simon", "Willison");
			console.log(s);
			// Object
			// first: "Simon"
			// last: "Willison"
			// __porto__:Object
			personFullName(s);
			console.log(personFullName(s));
			// Simon Willison
			console.log(s);
			// Object
			// first: "Simon"
			// last: "Willison"
			// __porto__:Object
			personFullNameReversed(s);
			console.log(personFullNameReversed(s));
			// Willison,Willison
			console.log(s);
			// Object
			// first: "Simon"
			// last: "Willison"
			// __porto__:Object
		</script>
		<h3>代码描述</h3>
		<p>因为需要在全局命名空间中写很多函数</p>
		<p>既然函数本身就是对象，如果需要使一个函数隶属于一个对象</p>
		<p>那么不难得到</p>
		<script>
			function makePerson(first, last) {
				return {
					first: first,
					last: last,
					fullName: function() {
						return this.first + " " + this.last;
					},
					fullNameReversed: function(){
						return this.last + "," + this.first;
					},
					rerurnthis: function(){
						return this;
					}
				}
			}

			s = makePerson("Simon", "Willison");
			console.log(s.rerurnthis());
			// Object {first: "Simon", last: "Willison"}
			console.log(s);
			s.fullName();
			console.log(s.fullName());
			console.log(s);
			s.fullNameReversed();
			console.log(s.fullNameReversed());
			console.log(s);
		</script>
	</body>
</html>
