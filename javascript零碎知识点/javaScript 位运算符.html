<!doctype html>
<html>
    <head>
        <meta charset="utf-8">
        <title>javascript 位运算符</title>
    </head>
    <body>
        <h1>按位与(&)</h1>
        
        <p>和&&运算符一样——&只有两个数的值为1时，才返回1</p>
        
        <pre>
                0001
            &   0011
            ——————————
                0001
        </pre>
        只有对应的数为1时，结果才为1，其他都为0
        <h2>实例</h2>
        判断一个数是奇数还是偶数

        <p>常规做法</p>
        <pre>
            function assert(n) {
                if(n % 2 === 1) {
                    console.log("n是奇数");
                }else{
                    console.log("n是奇数");
                }
            }
        </pre>
        <p>优化做法</p>
        <pre>
            function assert(n) {
                if(n & 1) {
                    console.log("n是奇数");
                }else{
                    console.log("n是奇数");
                }
            }
        </pre>
        <p>说明</p>
        <pre>
            奇数的二进制码的最后一位数肯定是1，而1只有最后一位为1，按位&操作之后，结果肯定只有最后一位数为1；
            偶数的二进制表示的最后一位数是0，和1进行按位&操作，结果所有位数都为0
        </pre>

        <h2>按位或(|)</h2>
        <p>|与||操作符的道理也是一样的，只要两个数中有一个数为1，结果就为1，其他则为</p>

        <pre>
                0001
            |   0011
            ——————————
                0011
        </pre>

        <h2>实例</h2>
        <p>对浮点数向下求整</p>

        <p>常规做法</p>
        <pre>
            var num = Math.floor(1.1);
        </pre>

        <p>优化做法</p>
        <pre>
            var num = 1.1 | 0;
        </pre>

        <p>说明</p>
        <pre>
            其实浮点数是不支持位运算的，所以会先把1.1转成整数1再进行位运算，就好像是对浮点数向下求整
            所以1|0的结果就是1
        </pre>


        <h1>按位非(~)</h1>
        <p>按位非就是求二进制的反码</p>
        <pre>
            var num = 1; // 二进制 00000000000000000000000000000001
            var num1 = ~num; // 二进制 11111111111111111111111111111110
        </pre>
        
        <p>说明</p>
        <pre>
            最高位为1代表负数，负数的二进制转化为十进制
            符号位不变，其他位取反加1
            取反之后为10000000000000000000000000000001，
            加1之后为10000000000000000000000000000010，十进制为-2
        </pre>


        <h1>按位异或(^)</h1>
        <p>按位异或是两个数中只有一个1时返回1，其他情况返回0</p>


        <pre>
                0001
            ^   0011
            ——————————
                0010
        </pre>



        <p>实例</p>
        <p>调换两个数字的值</p>


        <p>常规做法</p>
        <pre>
            var num1 = 1, num2 = 2, temp;
            temp = num1;
            num1 = num2; // 2
            num2 = temp; // 1
        </pre>

        <p>优化做法</p>
        <pre>
            var num1 = 1, num2 = 2;
            num1 = [num2, num2 = num1][0];
            console.log(num1); // 2
            console.log(num2); // 1
        </pre>

        <p>在优化一步</p>
        <pre>
            var num1 = 1, num2 = 2;
            num1 ^= num2; // num1 = num1 ^ num2 = 1 ^ 2 = 3
            num2 ^= num1; // num2 = num2 ^ (num1 ^ num2) = 2 ^ (1 ^ 2) = 1
            num1 ^= num2; // num1 = num1 ^ num2 = 3 ^ 1 = 2
            console.log(num1); // 2
            console.log(num2); // 1
        </pre>



        <h1>有符号左移(<<)</h1>
        <p>有符号左移会将32位二进制数的所有位向左移动指定位数</p>

        <pre>
            var num = 2; // 二进制10
            num = num << 5; // 二进制1000000，十进制64
        </pre>


        <p>如果要求2的n次方</p>
        <pre>
            function power(n) {
                return 1 << n;
            }
            
            power(5); // 32
        </pre>

        <p>说明</p>
        <p>1的二进制是01，左移5位就是0100000，十进制就是2的5次方32</p>



        <h1>有符号右移(>>)</h1>
        <p>有符号右移会将32位二进制数的所有位向右移动指定位数</p>

        <pre>
            var num = 64; // 二进制1000000
            num = num >> 5; // 二进制10，十进制2
        </pre>

        <h2>实例</h2>
        <p>求一个数的二分之一</p>


        <p>优化做法</p>
        <pre>
            var num = 64 >> 1; // 32
        </pre>

        <h2>注意:有符号左移与右移不会影响符号位</h2>


        <h1>无符号右移(>>>)</h1>
        <p>正数的无符号右移与有符号右移结果是一样的</p>
        <p>负数的无符号右移会把符号位也一起移动，而且无符号右移会把负数的二进制码当成正数的二进制码</p>

        <pre>
            var num = -64; // 11111111111111111111111111000000
            num = num >>> 5; // 134217726
        </pre>


        <h2>使用</h2>
        <p>可以利用无符号右移来判断一个数的正负</p>

        <pre>
            function isPos(n) {
                return (n === (n >>> 0)) ? true : false;    
            }
            
            isPos(-1); // false
            isPos(1); // true
        </pre>

        <p>-1>>>0虽然没有向右移动位数，但-1的二进制码已经变成了正数的二进制码</p>

        <pre>
            11111111111111111111111111111111 
        </pre>

        所以-1>>>0的值为4294967295。
    </body>
    <script>
        var n = Math.random() * 100;
        console.log(n % 2);
        console.log(n & 2);
    </script>
</html>