<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<title>索引集合类</title>
	</head>
	<body>
		<h1>数组对象(Array object)</h1>
		<p>数组(array)是一个有序的数据集合，我们可以通过数组名称(name)和索引(index)进行访问</p>

		<h2>示例说明</h2>
		<p>例如，我们定义了一个数组emp，数组中的每个元素包含了一个雇员的名字以及其作为索引的员工号</p>
		<p>那么emp[1]将会代表1号员工，emp[2]将会代表2号员工，以此类推</p>

		<h2>JavaScript中没有明确的数组数据类型</h2>
		<p>可以通过使用内置Array对象和它的方法对数组进行操作</p>
		<p>Array对象有很多操作数组的方法，比如合并、反转、排序等</p>
		<p>数组对象有一个决定数组长度和使用正则表达式操作其他属性的属性</p>






		<h2>创建数组(creating an array)</h2>
		<p>语句创建等效的数组</p>
		<script>
			// var arr = new Array(element0, element1, ..., elementN);
			// var arr = Array(elechuangjmet0, element1, ..., elementN);
			// var arr = [element0, element1, ..., elementN];
		</script>
		<h3>注意:</h3>
		<script>
			var arr = [4];
			console.log(arr);
			/*声明数组元素*/
			// Array[1]
			var arrer = new Array(4);
			console.log(arrer);
			// Array[4]
			/*声明数组长度*/
		</script>
		<script>
			/**
			*	创建一个长度不为0,但又没有任何元素的数组
			*/
			// var arr = new Array(arrayLength);
			// console.log(arr);
			// var arr = Array(arrayLength);
			// console.log(arr);

			/*有同样的效果*/
			// var arr = [];
			// arr.length = arrayLength;
			// console.log(arr);
		</script>

		<h3>代码描述</h3>
		<p>以上代码中，数组长度(arrayLength)必须为一个数字(Number)</p>
		<p>其他情况下，将创建一个单元素的数组</p>
		<p>调用 arr.length 将返回数组长度，但是数组实际上包含了空(未定义undefined)的元素</p>
		<p>在数组上运行 for...in 循环，将会返回数组元素的节点</p>

		<h3>除了如上所示创建新定义的变量，数组(array)也可以作为一个属性(property)分配给一个新的或者已存在的对象(object)</h3>
		<script>
			var obj = {};
			// ...
			obj.prop = [element0, element1, ..., elementN];

			// OR
			var obj = {prop:[element0, element1, ..., elementN]}
		</script>

		<h3>使用注意</h3>
		<p>希望用单个元素初始化一个数组，而这个元素恰好又是数字(Number)，那么你必须使用括号语法</p>
		<p>当单个的数字(Number)传递给Array()构造函数时，将会被解释为数组长度，并非单个元素</p>
		<script>
			var arr = [42];
			var arr = new Array(42);
			var arr = [];
			arr.length = 42;
		</script>
		<h3>注意:</h3>
		<p>如果N不是一个整数，调用Array(N)将会报RangeError错误</p>
		<script>
			var arr = Array(9.3);
			console.log(arr);
			// RangeError: Invalid array length
		</script>









		<h1>填充数组(populating an array)</h1>
		<p>可以通过给元素赋值来填充数组</p>
		<script>
			var emp = [];
			emp[0] = "Casey Jones";
			emp[1] = "Phil Lesh";
			emp[2] = "August West";
			console.log(emp);
			// ["Casey Jones", "Phil Lesh", "August West"]
		</script>


		<h3>注意:</h3>
		<p>如果你在以上代码中给数组操作符的是一个非整形数值，那么将作为一个代表数组的对象的属性(property)创建，而非作为数组的元素</p>

		<script>
			var arr = [];
			arr[3.4] = "Oranges";
			console.log(arr);
			// [3.4: "Oranges"]
			console.log(arr.length);
			// 0
			console.log(arr.hasOwnProperty(3.4));
			// true
		</script>

		<p>可以在创建数组的时候去填充它</p>

		<script>
			var myVar = "World";
			var myArray = new Array("Hello", myVar, 3.14159);
			console.log(myArray);
			// ["Hello", "World", 3.14159]
			var myArray = ["Mango", "Apple", "Orange"];
			console.log(myArray);
			// ["Mango", "Apple", "Orange"]
		</script>










		<h1>引用数组元素(referring to array elements)</h1>
		<p>可以通过数组元素的序号去引用这个元素</p>
		<script>
			var myArray = ["wind", "Rain", "fire"];
		</script>
		<p>可以用 myArray[0]引用第一个元素，myArray[1]引用第二个元素。元素的索引是从0开始的</p>

		<h3>注意:</h3>
		<p>数组操作符（方括号 [ ]）也可以用来访问数组的属性(在JavaScript中，数组也是对象)</p>
		<script>
			var arr = ["one", "two", "three"];
			arr[2];
			console.log(arr[2]);
			/*three*/
			arr["length"];
			console.log(arr["length"]);
			/*3*/
		</script>










		<h1>理解length</h1>
		<p>在实施层面， JavaScript实际上是将元素作为标准的对象属性来存储，把数组索引作为属性名</p>
		<p>长度属性是特殊的，它总是返回最后一个元素的索引值加1(下例中， Dusty 的索引是30，所以cats.length 返回 30 + 1)</p>
		<p>记住， JavaScript 数组索引是基于0的: 他们从0开始，而不是1</p>
		<p>这意味着数组长度属性将比最大的索引值大1</p>
		<script>
			var cats = [];
			cats[30] = ['Dusty'];
			console.log(cats.length);
			/*31*/
		</script>

		<p>可以分配length属性</p>
		<span>写一个小于数组元素数量的值会缩短数组，写0会彻底清空数组</span>

		<script>
			var cats = ["Dusty", "Misty", "Twiggy"];
			console.log(cats.length);
			/*3*/

			cats.length = 2;
			console.log(cats);
			/*["Dusty", "Misty"]*/

			cats.length = 0;
			console.log(cats);
			/*[]*/

			cats.length = 3;
			console.log(cats);
			/*[]*/
		</script>










		<h1>遍历数组(interating over array)</h1>
		<p>遍历数组元素并以某种方式处理每个元素是一个常见的操作</p>
		<script>
			var color = ['red', 'green', 'blue'];
			for (var i = 0; i < colors.length; i++) {
				console.log(colors[i]);
			}
		</script>

		<p>如果你确定数组中没有一个元素的求值是false —— 如果你的数组只包含DOM节点</p>

		<script>
			var divs = document.getElementByTagName('div');
			for (var i = 0, div; div = divs[i]; i++){
				/*命令行写入*/
			}
		</script>

		<h3>优点:</h3>
		<p>这样避免了检测数组长度的开销，额外的好处是确保了div变量当前在每次循环中都被重新赋值为当前项</p>

		<h2>forEach() 方法提供乐遍历数组元素的其他方法</h2>

		<script>
			var colors = ["red", "green", "blue"];
			colors.forEach(function(color) {
				console.log(color);
				/*red*/
				/*green*/
				/*blue*/
			});
		</script>

		<h2>代码描述</h2>
		<p>被传递给forEach的函数会在数组的每个元素像上执行一次，元素作为参数传递给该函数</p>
		<p>未赋值的值不会在forEach循环迭代</p>

		<h3>注意:</h3>
		<p>在数组定义时省略的元素不会在forEach遍历时被列出</p>
		<p>手动赋值为undefined的元素是会被列出的</p>

		<script>
			var array = ["first", "second", "fourth"];
			array.forEach(function(element) {
				console.log(element);
				/*first*/
				/*second*/
				/*fourth*/
			})

			if(array[3] == undefined) {
				console.log('array[2] is undefined');
			}

			var array = ["first", "second", undefined, "fourth"];

			array.forEach(function (element) {
				console.log(element);
				/*first*/
				/*second*/
				/*undefined*/
				/*fourth*/
			})
		</script>

		<h3>注意:</h3>
		<p>一旦 JavaScript 元素被保存为标准的对象属性，通过for...in 循环来迭代迭代将变得不明智，因为正常元素和所有可枚举的属性都会被列出</p>










		<h1>数组的方法(array methods)</h1>
		<p>Array 对象具有下列方法</p>

		<h2>concat()链接两个数组并返回一个新数组</h2>
		<script>
			var myArray = new Array("1", "2", "3");
			console.log(myArray);
			/*["1", "2", "3"]*/
			myArray = myArray.concat("a", "b", "c");
			console.log(myArray);
			/*["1", "2", "3", "a", "b", "c"]*/
		</script>
		<h3>注意:已改变该数组</h3>




		<h2>join(deliminator = ",")讲述组所有的元素连成一个字符串</h2>
		<script>
			var myArray = new Array("wind", "Rain", "Fire");
			console.log(myArray);
			/*["wind", "Rain", "Fire"]*/
			var list = myArray.join(" - ");
			console.log(list);
			/*wind - Rain - Fire*/
			console.log(myArray);
		</script>




		<h2>push()在数组末尾添加一个或多个元素,并返回数组操作后的长度</h2>
		<script>
			var myArray = new Array("1", "2");
			console.log(myArray);
			/*["1", "2"]*/
			myArray.push("3");
			console.log(myArray);
			/*["1", "2", "3"]*/
		</script>
		<h3>注意:已改变该数组</h3>




		<h2>pop()重数组中移除最后一个元素,并返回该元素</h2>
		<script>
			var myArray = new Array("1", "2", "3");
			console.log(myArray);
			/*["1", "2", "3"]*/
			var last = myArray.pop();
			console.log(last);
			/*3*/
			console.log(myArray);
			/*["1", "2"]*/
		</script>
		<h3>注意:已改变该数组</h3>




		<h2>shift()从数组移出第一个元素,并返回该元素</h2>
		<script>
			var myArray = new Array("1", "2", "3");
			console.log(myArray);
			/*["1", "2", "3"]*/
			var first = myArray.shift();
			console.log(first);
			/*1*/
			console.log(myArray);
			/*["2", "3"]*/
		</script>
		<h3>注意:已改变该数组</h3>




		<h2>unshift()在数组开头添加一个或多个元素，并返回数组的新长度</h2>
		<script>
			var myArray = new Array ("1", "2", "3");
			console.log(myArray);
			/*["1", "2", "3"]*/
			myArray.unshift("4", "5");
			console.log(myArray);
			/*["4", "5", "1", "2", "3"]*/
		</script>
		<h3>注意:已改变该数组</h3>



		<h2>slice(start_index, upto_index)从数组提取一个片段，并作为一个新数组返回</h2>
		<script>
			var myArray = new Array("a", "b", "c", "d", "e");
			console.log(myArray);
			/*["a", "b", "c", "d", "e"]*/
			myArray = myArray.slice(1, 4);
			console.log(myArray);
			/*["b", "c", "d"]*/
		</script>
		<h3>注意:已改变数组;并从一开始</h3>



		<h2>splice(index, count_to_remove, addElement1, addElement2, ...)从数组移出一些元素(可选:并替换他们)</h2>
		<script>
			var myArray = new Array ("1", "2", "3", "4", "5");
			console.log(myArray);
			["1", "2", "3", "4", "5"]
			myArray.splice(1, 3, "a", "b", "c", "d");
			console.log(myArray);
			["1", "a", "b", "c", "d", "5"]
		</script>
		<h3>注意:已改变数组;并从一开始 替换方法等同于置换</h3>



		<h2>reverse()颠倒数组元素的顺序:第一个变成最后一个，最后一个变成第一个</h2>
		<script>
			var myArray = new Array("1", "2", "3");
			console.log(myArray);
			/*["1", "2", "3"]*/
			myArray.reverse();
			console.log("myArray.reverse" + myArray.reverse());
			/*["1", "2", "3"]*/
			console.log(myArray);
			/*["1", "2", "3"]*/
		</script>
		<h3>似乎是要执行的但是既没报错又没执行(似乎是)</h3>
		


		<h2>sort()给数组元素排序</h2>
		<script>
			var myArray = new Array ("wind", "Rain", "Fire");
			console.log(myArray);
			/*["wind", "Rain", "Fire"]*/
			myArray.sort();
			console.log(myArray.sort());
			/*["Fire", "Rain", "wind"]*/
			console.log(myArray);
			/*["Fire", "Rain", "wind"]*/
			var testArray = new Array ("一", "二", "三");
			console.log(testArray);
			/*["一", "二", "三"]*/
			testArray.sort();
			console.log(testArray.sort());
			/*["一", "三", "二"]*/
			console.log(testArray);
			/*["一", "三", "二"]*/
		</script>
		<h3>注意:确实改变了应该是按首字母排序</h3>

		<script>
			/*sort() 也可以带一个回调函数来决定怎么比较数组元素*/
			/*代码通过字符串的最后一个字母进行排序*/
			var sortFn = function(a, b) {
				if (a[a.length - 1] < b[b.length - 1]) return -1;
				if (a[a.length - 1] > b[b.length - 1]) return 1;
				if (a[a.length - 1] == b[b.length - 1]) return 0;
			}
			myArray.sort(sortFn);
		</script>

		<h3>代码描述</h3>
		<ul>
			<li>如果 a 小于 b ，返回 -1(或任何负数)</li>
			<li>如果 a 大于 b ，返回 1 (或任何正数)</li>
			<li>如果 a 和 b 相等，返回 0</li>
		</ul>




		<h2>indexOf(searchElement,[formIndex])在数组中搜索searchElement 并返回第一个匹配的索引</h2>
		<script>
			var a = ["a", "b", "a", "b", "a"];
			console.log(a);
			/*["a", "b", "a", "b", "a"]*/
			a.indexOf("b", 2);
			console.log(a.indexOf("b", 2));
			/*3*/
			console.log(a.indexOf("b", 1));
			/*1*/
			console.log(a.indexOf("b"));
			/*默认只找一个并只找第一次*/
			/*1*/
			a.indexOf("z");
			console.log(a.indexOf("z"));
			/*-1 代表没找到	*/
			console.log(a);
			/*["a", "b", "a", "b", "a"]*/
		</script>
		<h3>注意:fromIndex代表搜索范围</h3>




		<h2>lastIndexOf(searchElement,[fromIndex])和indexOf差不多，但是是从结尾开始，并且是反向搜索</h2>
		<script>
			var a = ['a', 'b', 'c', 'd', 'a', 'b'];
			console.log(a.lastIndexOf('b'));
			/*5*/
			console.log(a.lastIndexOf('b', 2));
			/*1*/
			console.log(a.lastIndexOf('z'));
			/*-1 代表没找到*/
		</script>
		<h3>注意:formIndex代表搜索范围</h3>




		<h2>forEach(callback,[thisObject])在数组每个元素项上执行callback</h2>
		<script>
			var a = ['a', 'b', 'c'];
			a.forEach(function(element) {
				console.log(element);
				/*a*/
				/*b*/
				/*c*/
			})
		</script>




		<h2>map(callback, thisObject)在数组的每个单元项上执行callback函数，并把返回包含回调函数返回值的新数组</h2>
		<p>也就是遍历数组，并通过callback对数组元素进行操作，并将所有操作结果放入数组中并返回该数组</p>
		<script>
			var a1 = ['a', 'b', 'c'];
			console.log(a1);
			/*["a", "b", "c"]*/
			var a2 = a1.map(function(item) {
				return item.toUpperCase();
			})
			console.log(a2);
			/*["A", "B", "C"]*/
			console.log(a1);
			/*["a", "b", "c"]*/
		</script>




		<h2>filter(callback, [thisObject])返回一个包含所有在回调函数上返回为true的元素的新数组</h2>
		<h3>注意描述</h3>
		<p>callback在这里担任的是过滤器的角色，当元素符合条件，过滤器就返回true，而filter则会返回所有符合过滤条件的元素</p>
		<script>
			var a1 = ['a', 10, 'b', 20, 'c', 30];
			console.log(a1);
			/*["a", 10, "b", 20, "c", 30]*/
			var a2 = a1.filter(function(item) {
				return typeof item == 'number';
			});
			console.log(a2);
			/*[10, 20, 30]*/
		</script>




		<h2>every(callback,[thisObject])当数组中每一个元素在callback上被返回true时就返回true</h2>
		<h3>注意描述</h3>
		<p>同上，every其实类似filter，只不过它的功能是判断是不是数组中的所有元素都符合条件，并且返回的是bool值</p>
		<script>
			function isNumber(value) {
				return typeof value == 'number';
			}
			var a1 = [1, 2, 3];
			console.log(a1.every(isNumber));
			/*true*/
			var a2 = [1, '2', 3];
			console.log(a2.every(isNumber));
			/*false*/
		</script>




		<h2>some(callback, [thisObject])只要数组中有一项在callback上被返回true，就返回true</h2>
		<h3>注意:</h3>
		<p>同上，类似every，不过前者要求都符合筛选条件才返回true，后者只要有符合条件的就返回true</p>
		<script>
			function isNumber(value) {
				return typeof value == 'number';
			}
			var a1 = [1, 2, 3];
			console.log(a1.some(isNumber));
			var a2 = [1, '2', 3];
			console.log(a2.some(isNumber));
			var a3 = ['1', '2', '3'];
			console.log(a3.some(isNumber))
		</script>


		<h3>详细描述</h3>
		<p>以上方法都带一个被称为迭代方法的的回调函数，因为他们以某种方式迭代整个数组</p>
		<p>都有一个可选的第二参数 thisObject，如果提供了这个参数，thisObject 变成回调函数内部的 this 关键字的值</p>
		<p>如果没有提供，例如函数在一个显示的对象上下文外被调用时，this 将引用全局对象(window)</p>

		<h3>实际上在调用回调函数时传入了3个参数</h3>
		<ul>
			<li>第一个是当前元素项的值</li>
			<li>第二个是它在数组中的索引</li>
			<li>第三个是数组本身的一个引用</li>
		</ul>
		<p>JavaScript 函数忽略任何没有在参数列表中命名的参数，因此提供一个只有一个参数的回调函数是安全的</p>




		<h2>reduce(callback, [initialValue])应用回调减少项目到一个单一的值列表</h2>
		<script>
			var a = [10, 20, 30];
			var total = a.reduce(function(first, second) {
				return first + second;
			}, 0);
			console.log(total);
			/*60*/
			console.log(a);
			/*[10, 20, 30]*/
		</script>




		<h3>reduceRight(callback,[initalvalue])和reduce相似,但reduceRight是从最后一个元素开始的</h3>
		<p>reduceRight(callback,[initalvalue])和reduce是最明显的迭代阵列方法</p>
		<p>被用于以减少的序列到单个值递归结合两个值的算法</p>










		<h1>多位数组(multi-dimensional arrays)</h1>
	</body>
</html>