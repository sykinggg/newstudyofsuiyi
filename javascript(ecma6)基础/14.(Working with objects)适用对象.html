<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<title>使用对象</title>
	</head>
	<h1>使用对象</h1>
	<h2>简介</h2>
	<p>JavaScript 采用了简单的基于对象的范型</p>
	<p>一个对象就是一系列属性的集合，一个属性包含一个名字和一个值</p>
	<p>一个属性的值可以是函数，这种情况下属性也被称为方法</p>
	<p>除了浏览器里面预定义的那些对象之外，你也可以定义你自己的对象</p>
	<h1>本章描述了怎样使用对象，属性，函数和方法，以及怎样创建你自己的对象</h1>










	<h1>对象和属性</h1>
	<p>一个 javascript 对象有很多属性</p>
	<p>一个对象的属性可以被解释成一个附加到对象上的变量</p>
	<p>对象的属性和普通的 javascript 变量基本没什么区别，仅仅是属性属于某个对象</p>
	<h2>使用:可以通过点符号来访问一个对象的属性</h2>
	<script>
		/*objectName.propertyName*/
	</script>
	<p>和其他 javascript 变量一样，对象的名字(可以是普通的变量)和属性的名字都是大小写敏感的。你可以在定义一个属性的时候就给它赋值</p>

	<script>
		/*创建一个myCar的对象然后给他三个属性，make，model，year*/
		var myCar = new Object();
		console.log(myCar);
		/*Object {}*/
		myCar.make = "Ford";
		console.log(myCar.make);
		/*Ford*/
		console.log(myCar);
		/*Object {make: "Ford"}*/
		myCar.model = "Mustang";
		console.log(myCar.model);
		/*Mustang*/
		console.log(myCar);
		/*Object {make: "Ford", model: "Mustang"}*/
		myCar.year = 1969;
		console.log(myCar.year);
		/*1969*/
		console.log(myCar);
		/*Object {make: "Ford", model: "Mustang", year: 1969}*/
	</script>

	<p>JavaScript 对象的属性也可以通过方括号访问. 对象有时也被叫作关联数组, 因为每个属性都有一个用于访问它的字符串值</p>

	<script>
		var myCar = new Object();
		console.log(myCar);
		/*Object {}*/
		myCar["make"] = "Ford";
		console.log(myCar.make);
		/*Ford*/
		console.log(myCar);
		/*Object {make: "Ford"}*/
		myCar["model"] = "mustang";
		console.log(myCar.model);
		/*mustang*/
		console.log(myCar);
		/*Object {make: "Ford", model: "mustang"}*/
		myCar["year"] = 1969
		console.log(myCar.year);
		/*1969*/
		console.log(myCar);
		/*Object {make: "Ford", model: "mustang", year: 1969}*/
	</script>

	<h3>注意:</h3>
	<p>一个对象的属性名可以是任何有效的 JavaScript 字符串,，或者可以被转换为字符串的任何东西，包括空字符串</p>
	<p>一个属性的名称如果不是一个有效的 JavaScript 标识符（例如，一个有空格或短横线，或者以数字开头的属性名），就只能通过方括号标记访问</p>
	<h3>这个标记法在属性名称是动态判定（属性名只有到运行时才能判定）时非常有用</h3>

	<script>
		var myObj = new Object();
				str = "myString",
				rand = Math.random(),
				obj = new Object();

		myObj.type 						= "Dot syntax";
		console.log(myObj);
		/*Object {type: "Dot syntax"}*/
		myObj["date created"] = "String with space";
		console.log(myObj);
		/*Object {type: "Dot syntax", date created: "String with space"}*/
		myObj[str]						= "String value";
		console.log(myObj);
		/*Object {type: "Dot syntax", date created: "String with space", myString: "String value"}*/
		myObj[rand]						=	"Random Number";
		console.log(myObj);
		/*Object {type: "Dot syntax", date created: "String with space", myString: "String value", 0.15392144008662245: "Random Number"}*/
		myObj[obj]						=	"Object";
		console.log(myObj);
		/*Object {type: "Dot syntax", date created: "String with space", myString: "String value", 0.15392144008662245: "Random Number", [object Object]: "Object"}*/
		myObj[""]							=	"Even an empty string";
		console.log(myObj);
		/*Object {type: "Dot syntax", date created: "String with space", myString: "String value", 0.15392144008662245: "Random Number", [object Object]: "Object"…}*/
	</script>

	<p>也可以通过存储在变量中的字符串来访问属性</p>

	<script type="text/javascript">
		var myCar = new Object();
		var propertyName = "make";
		myCar[propertyName] = "Ford";
		console.log(myCar);
		/*Object {make: "Ford"}*/

		propertyName = "model";
		myCar[propertyName] = "Mustang";
		console.log(myCar);
		/*Object {make: "Ford", model: "Mustang"}*/
	</script>

	<p>可以在  for...in 语句中使用方括号标记以枚举一个对象的所有属性</p>

	<script type="text/javascript">
		/*当你将对象及其名称作为参数传入时，显示对象的属性*/
		function showProps(obj, objName) {
			var result = "";
			for (var i in obj) {
				if (obj.hasOwnProperty(i)) {
					result += objName + "." + i + " = " + obj[i] + "\n";
				}
			}
			return result;
		}
	</script>

	<p>对于函数调用 showProps(myCar, "myCar") 将返回以下值</p>

	<script type="text/javascript">
		myCar.make = Ford;
		myCar.model = Mustang;
		myCar.year = 1969;
	</script>

	<h3>重点:对象即全部</h3>
	<h3>所有的原生类型除了 null 与 undefined 之外都被当作对象</h3>
	<h3>它们可以被赋予属性（某些类型的被赋予的属性不能被持久化），并且它们都有对象的全部特征</h3>










	<h1>枚举一个对象的所有属性</h1>
	<p>从 ECMAScript 5 开始，有三种原生的方法用于列出或枚举对象的属性</p>



	<h1>for...in循环</h1>
	<p>该方法依次访问一个对象及其原型链中所有可枚举的属性</p>



	<h1>Object.keys(o)</h1>
	<p>该方法返回一个对象的o自身包含（不包括原型中）的所有属性的名称的数组</p>




	<h1>Object.getOwnPropropertyName(o)</h1>
	<p>该方法返回一个数组，它包含了对象 o 所有拥有的属性（无论是否可枚举）的名称</p>


	<p>在 ECMAScript 5 中，没有原生的方法枚举一个对象的所有属性</p>

	<script type="text/javascript">
		function  listAllProperties(o) {
			var objectToInspect;
			var result = [];

			for(objectToInspect = 0; objectToInspect !== null; objectToInspect = Object.getPropertypeof(objectToInspect)) {
				result = result.concat(Object.getOwnPropertyName(objectToInspect));
			}

			return result;
		}
	</script>

	<h3>注意:</h3>
	<p>展示 “隐藏”（在原型中的不能通过对象访问的属性，因为另一个同名的属性存在于原型链的早期）的属性时很有用</p>
	<p>可以通过在数组中去除同名元素即可轻松地列出访问的属性</p>










	<h1>创建隐藏对象</h1>
	<p>从  JavaScript 1.2 之后，你可以通过对象初始化器（Object Initializer）创建对象</p>
	<p>可以创建一个构造函数并使用该函数和 new 操作符初始化对象</p>



	<h2>使用对象初始化</h2>
	<p>除了通过构造函数创建对象之外，你也可以通过对象初始化器创建对象</p>
	<p>使用对象初始化器也被称作通过字面值创建对象</p>
	<h2>对象初始化器创建对象的语法</h2>
	<script type="text/javascript">
		// var obj = {
		// 		property_1: 	value_1,
		// 		2: 						value_2,
		// 		"property n": value_n
		// }；
	</script>
	<h2>语法解析:</h2>
	<p>这里 obj 是新对象的名称</p>
	<p>每一个 property_i 是一个标识符（可以是一个名称、数字或字符串字面量），并且每个 value_i 是一个其值将被赋予 property_i 的表达式</p>
	<p>obj 与赋值是可选的</p>
	<p>如果你不需要在其他地方引用对象，你就不需要将它赋给一个变量</p>
	<h3>注意在接受一条语句的地方，你可能需要将对象字面量括在括号里，从而避免将字面量与块语句相混淆</h3>


	<p>如果一个对象是通过在顶级脚本的对象初始化器创建的，则 JavaScript 在每次遇到包含该对象字面量的表达式时都会创建对象</p>
	<p>同样的，在函数中的初始化器在每次函数调用时也会被创建</p>

	<script type="text/javascript">
		/*当 cond 表达式的值为 true 时创建对象并将其赋给变量 x*/
		if(cond) var x = {hi: 'there'};
	</script>

	<script type="text/javascript">
		/*创建了有三个属性的 myHonda 对象。注意它的 engine 属性也是一个拥有自己属性的对象*/
		var myHonda = {
			color: 	"red",
			wheels: 4,
			engine: {
				cylinders:	 4,
				size: 			2.2,
			}
		};
	</script>
	<h1>也可以用对象初始化器来创建数组</h1>

	<p>在 JavaScript 1.1 及更早版本中，你不能使用对象初始化器。你只能通过使用构造函数或其他对象的函数来创建对象</p>










	<h1>使用构造函数</h1>
	<p>可以通过两步来创建对象</p>
	<ul>
		<li>通过创建一个构造函数来定义对象的类型。首字母大写是非常普遍而且很恰当的惯用法</li>
		<li>通过 new 创建对象实例</li>
	</ul>

	<p>为了定义对象类型，为对象类型创建一个函数以声明类型的名称、属性和方法</p>

	<script type="text/javascript">
		function Car(make, model, year) {
			this.make = make;
			this.model = model;
			this.year = year;
		}
	</script>

	<h3>注意:通过使用 this 将传入函数的值赋给对象的属性</h3>
	<p>可以创建一个 mycar 对象</p>
	<script type="text/javascript">
		var mycar = new Car("Eagle", "Talon TSi", 1993);
		console.log(mycar);
		/*Car {make: "Eagle", model: "Talon TSi", year: 1993}*/
	</script>
	<h3>代码描述</h3>
	<p>一个对象的属性值可以是另一个对象</p>
	<script type="text/javascript">
		function Person(name, age, sex) {
			this.name = name;
			this.age = age;
			this.sex = sex;
		}

		/*按如下方式创建了两个 person 实例*/
		var rand = new Person("Rand Mckinnon", 33, "M");
		var key = new Person("Key Jones", 39, "M");

		/*可以重写 car 的定义以包含一个拥有它的 owner 属性*/
		function Car(make, model, year, owner) {
			this.make = make;
			this.model = model;
			this.year = year;
			this.owner = owner;
		}
		// console.log(car());
		/*Uncaught ReferenceError: car is not defined*/
		// console.log(car);
		/*Uncaught ReferenceError: car is not defined*/
		/*可以按如下方式创建新对象*/
		var car1 = new Car("Eagle", "Talon TSi", 1993, 'rand');
		var car2 = new Car("Nissan", "300ZX", 1992, 'ken');
		console.log(car1);
		/*Car {make: "Eagle", model: "Talon TSi", year: 1993, owner: "rand"}*/
		console.log(car2);
		/*Car {make: "Nissan", model: "300ZX", year: 1992, owner: "ken"}*/
		/**
		*		注意在创建新对象时，上面的语句将 rand 和 ken 作为 owner 的参数值，而不是传入字符串字面量或整数值
		*		如果想找出 car2 的拥有者的姓名，可以访问如下属性
		*/

		car2.owner.name;
		console.log(car2.owner.name);
		/*undefined*/

		/**
		*		注意你总是可以为之前定义的对象增加新的属性
		*/
		car1.color = "black";
		/**
		*		为 car1 增加了 color 属性，并将其值设为 "black."
		*		这并不影响其他的对象。想要为某个类型的所有对象增加新属性，你必须将属性加入到 car 对象类型的定义中
		*/
	</script>










	<h1>使用Object.create 的方法</h1>
	<p>对象也可以用 Object.create 方法创建</p>
	<p>允许你为创建的对象选择其原型对象，而不用定义一个构造函数</p>



	<h2>继承</h2>
	<p>所有的 JavaScript 对象继承于至少一个对象</p>
	<p>被继承的对象被称作原型，并且继承的属性可能通过构造函数的 prototype 对象找到</p>



	<h2>对象属性索引</h2>
	<p>在 JavaScript 1.0 中，你可以通过名称或序号访问一个属性</p>
	<p>在 JavaScript 1.1 及之后版本中，如果你最初使用名称定义了一个属性，则你必须通过名称来访问它</p>
	<p>如果你最初使用序号来定义一个属性，则你必须通过索引来访问它</p>

	<h3>对象属性索引的访问限制</h3>
	<p>这个限制发生在你通过构造函数创建一个对象和它的属性（就象我们之前通过 Car 对象类型所做的那样）并且显式地定义了单独的属性（如 myCar.color = "red"）</p>
	<p>如果你最初使用索引定义了一个对象属性，例如 myCar[5] = "25"，则你只可能通过 myCar[5] 引用它</p>

	<h3>对象属性索引的访问限制的例外</h3>
	<p>这条规则的例外是从与HTML对应的对象，例如 forms 数组</p>
	<p>对于这些数组的元素，你总是既可以通过其序号（依据其在文档中出现的顺序），也可以按照其名称（如果有的话）访问它</p>
	<p>如果文档中的第二个 <form> 标签有一个 NAME 属性且值为 "myForm"，访问该 form 的方式可以是 document.forms[1]，document.forms["myForm"]或 document.myForm</p>



	<h2>对象类型定义属性</h2>
	<p>可以通过 prototype 属性为之前定义的对象类型增加属性</p>
	<p>为该类型的所有对象，而不是仅仅一个对象增加了一个属性</p>
	<p>下面的代码为所有类型为 car 的对象增加了 color 属性，然后为对象 car1 的 color 属性赋值</p>
	<script type="text/javascript">
		Car.prototype.color = null;
		car1.color = "black";
	</script>



	<h2>定义方法</h2>
	<h3>一个方法 是关联到某个对象的函数</h3>
	<p>一个方法是一个值为某个函数的对象属性</p>
	<p>定义方法就象定义普通的函数，除了它们必须被赋给对象的某个属性</p>
	<script type="text/javascript">
		objectName.methodname = function_name;
		var myObj = {
			myMethod: function(params) {
				// ...do something
			}
		};
	</script>

	<h2>代码描述</h2>
	<p> objectName 是一个已经存在的函数，methodname 是方法的名称，而 function_name 是函数的名称</p>

	<h2>使用示例:</h2>
	<script type="text/javascript">
		/*可以在对象的上下文中象这样调用方法*/
		object.methodname(params);
		/*可以在对象的构造函数中包含方法定义来为某个对象类型定义方法*/
		function displayCar() {
			var result = "A Beautiful" + this.year + " " + this.make + " " + this.model;
			pretty_print(result);
		}
		/*这里 pretty_print 是一个显示横线和一个字符串的函数*/
		/*注意使用 this 指代方法所属的对象*/

		/*可以在对象定义中通过增加下述语句将这个函数变成 car 的方法*/

		this.displayCar = displayCar;

		/*car 的完整定义*/
		function Car(make, model, year, owner) {
			this.make = make;
			this.model = model;
			this.year = year;
			this.owner = owner;
			this.displayCar = displayCar;
		}

		/*可以按如下方式为每个对象调用 displayCar 方法*/
		car1.displayCar();
		car2.displayCar();
	</script>










	<h1>通过this引用对象</h1>
	<p>JavaScript 有一个特殊的关键字 this，它可以在方法中使用以指代当前对象</p>

	<script>
		/*假设你有一个名为 validate 的函数，它根据给出的最大与最小值检查某个对象的 value 属性*/
		function validate(obj, lowval, hival) {
			if((obj.value < lowval) || (obj.value > hival))
				alert("Invalid Value");
		}
	</script>

	<p>可以在每个元素的 onchange 事件处理器中调用 validate，并通过 this 传入相应元素</p>

	<input type="text" name="age" size="3" onChange="validate(this, 18, 99)">
	
	<p>this 在一个方法中指调用的对象</p>

	<p>与 form 属性一起使用时，this 可以指代当前对象的父窗体</p>
	

	<h1>this使用示例</h1>
	<p>窗体 myForm 包含一个 Text 对象和一个按钮，当用户点击按键，Text 对象的值被设为窗体的名称</p>
	<p>按钮的 onclick 事件处理器使用 this.form 以指代其父窗体，即 myForm</p>
	
	<form name="myForm">
		<p><label>Form name: <input type="text" name="text1" value="Beluga"></label></p>
		<p><input type="button" name="button1" value="Show Form Name" onclick="this.form.text1.value = this.form.button1.value"></p>
	</form>
	










	<h1>定义getter与setter</h1>
	<p>一个 getter 是一个获取某个特定属性的值的方法</p>
	<p>一个 setter 是一个设定某个属性的值的方法</p>
	<p>可以为预定义的或用户定义的对象定义 getter 和 setter 以支持新增的属性</p>
	<p>定义 getter 和 setter 的语法采用对象字面量语法</p>

	<h3>注意:</h3>
	<p>在JavaScript中1.8.1开始，制定者没有对象和数组的初始化设置属性时不再调用</p>

	<script>
		/*下面的  JS shell 语句描述了getters 和 setters 是如何为用户定义的对象 o 工作的*/
		/* JS shell 是一个应用程序，允许开发者以批处理或交互的方法测试 JavaScript*/
		/*在 Firefox 中，你可以通过Ctrl+Shift+K 组合按键调用 JS shell*/
		js > var o = {a: 7, get b() {return this.a + 1;}, set c(x) {this.a = x / 2}};
		[Object Object]
		js > o.a;
		3
		js > o.b;
		8
		js > o.c = 50;
		js > o.a;
		25
	</script>
	<h3>代码描述</h3>
	<p>o 对象的属性</p>
	<ul>
		<li>o.a -- 数字</li>
		<li>o.b -- 返回o.a + 1 的 getter</li>
		<li>o.c -- 由  o.c 的值所设置 o.a 值的 setter</li>
	</ul>

	<p>这个JavaScript shell会话说明了如何getter和setter方法​​可以延长日期原型一年属性添加到预定的日期类的所有实例</p>
	<p>它使用Date类的现有和getFullYear和调用setFullYear方法以支持时间对象的getter和setter</p>

	<script>
		/*定义了时间的事件*/
		js> var d = Date.prototype;
		js> d.__defineGetter__("year", function() {return this.getFullYear(); });
		js> d.__defineGetter__("year", function(y) {this.setFullYear(y); });

		/*这些语句使用getter和setter Date对象*/
		js> var now = new Date;
		js> print(now.year);
		2000
		js> now.year = 2001;
		987617605170
		js> print(now);
		Wed Apr 18 11:13:25 GMT-0700 (Pacific Daylight Time) 2001
	</script>
	<h3>注意:getter和setter Date对象已经过时</h3>










	<h1>删除属性</h1>
	<p>可以用 delete 操作符删除一个不是继承而来的属性</p>
	<script>
		/*删除一个属性*/

		/*创建一个新对象，MyObj中，具有两个属性，a和b*/
		var myobj = new Object;
		console.log(myobj);
		/*Object {}*/
		myobj.a = 5;
		myobj.b = 12;
		console.log(myobj);
		/*Object {a: 5, b: 12}*/

		/*移除属性，留下MyObj中只有b属性*/
		delete myobj.a;
		console.log(myobj);
		/*Object {b: 12}*/
	</script>

	<h3>如果一个全局变量不是用 var 关键字声明的话，你也可以用 delete 删除它</h3>
	<script>
		g = 17;
		console.log(g);
		/*17*/
		delete g;
		console.log(delete g);
		/*true*/
	</script>










	<h1>比较对象</h1>
	<p>在 JavaScript 中 objects 是一个引用类型</p>
	<p>将两个引用相同的对象想比较会返回 true; 将两个方法和属性相同的对象相比较，会返回 false</p>

	<script>
		var fruit = {
			name: 'apple'
		};
		console.log(fruit);
		/*Object {name: "apple"}*/

		var fruitbear = {
			name: "apple"
		};
		console.log(fruitbear);
		/*Object {name: "apple"}*/

		fruit == fruitbear;
		console.log(fruit == fruitbear);
		/*false*/

		fruit === fruitbear;
		console.log(fruit === fruitbear);
		/*false*/

		fruit.name == fruitbear.name;
		console.log(fruit.name == fruitbear.name);
		/*true*/

		fruit.name === fruitbear.name;
		console.log(fruit.name === fruitbear.name);
		/*true*/
	</script>
	<h3>注意:"===" 运算符用来检查数值是否相等: 1 === "1" </h3>

	<script>
		var fruit = {name: "apple"};
		console.log(fruit);
		/*Object {name: "apple"}*/

		var fruitbear = fruit;
		console.log(fruitbear);
		/*Object {name: "apple"}*/

		fruit == fruitbear;
		console.log(fruit == fruitbear);
		/*true*/

		fruit === fruitbear;
		console.log(fruit === fruitbear);
		/*true*/
	</script>
</html>
