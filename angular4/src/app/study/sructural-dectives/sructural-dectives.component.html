<h1>Structural Directives</h1>
<dt>描述</dt>
<dd>结构指令来操作DOM</dd>
<a href="{{onLineHref}}" target="{{targetType}}">在线实例</a>
<span>|</span>
<a href="{{downloadHref}}" target="{{targetType}}">实例下载</a>

<h2>What are structural directives?</h2>
<dt>描述</dt>
<dd>结构指令负责HTML布局</dd>
<dd>通常通过添加，删除或操纵元素来塑造或重塑DOM的结构</dd>
<dd>与其他指令一样，您将结构指令应用于根元素</dd>
<dd>然后这个指令做任何它应该做的根元素及其后代</dd>
<dd>结构指令很容易识别。在此示例中，星号（*）在指令属性名称前面</dd>
<pre>
    &#60;div *ngIf="hero" class="name">&#123;&#123;hero.name&#125; &#125;&#60;/div>
</pre>
<dt>描述</dt>
<dd>只是* ngIf设置为一个字符串</dd>
<dd>星号（*）是一种便利的表示法，字符串是一种微型语法，而不是通常的模板表达式</dd>
<dd>Angular把这个表示法解释成一个围绕主元素及其后代的标记的&#60;ng-template></dd>
<pre>
    &#60;div *ngIf="hero" class="name">&#123; &#123;hero.name&#125;&#125;&#60;/div>
    
    &#60;ul>
        &#60;li *ngFor="let hero of heroes">&#123; &#123;hero.name&#125;&#125;&#60;/li>
    &#60;/ul>
    
    &#60;div [ngSwitch]="hero?.emotion">
        &#60;app-happy-hero    *ngSwitchCase="'happy'"    [hero]="hero">&#60;/app-happy-hero>
        &#60;app-sad-hero      *ngSwitchCase="'sad'"      [hero]="hero">&#60;/app-sad-hero>
        &#60;app-confused-hero *ngSwitchCase="'app-confused'" [hero]="hero">&#60;/app-confused-hero>
        &#60;app-unknown-hero  *ngSwitchDefault           [hero]="hero">&#60;/app-unknown-hero>
    &#60;/div>
</pre>
<dt>描述</dt>
<dd>NgIf指的是指令类;</dd>
<dd>ngIf引用指令的属性名称</dd>

<dt>组件|属性指令</dt>
<dd>组件以本地HTML元素的方式管理HTML区域</dd>
<dd>从技术上讲，这是一个模板指令。属性指令改变元素，组件或其他指令的外观或行为</dd>
<dd>内置的NgStyle指令可以同时改变多个元素样式</dd>
<dd>可以将许多属性指令应用于一个根元素</dd>
<dd>只能将一个结构指令应用于根元素</dd>

<h3>NgIf case study</h3>
<dt>描述</dt>
<dd>需要一个布尔表达式，并使DOM的整个块出现或消失</dd>
<pre>
    &#60;p *ngIf="true">
        Expression is true and ngIf is true.
        This paragraph is in the DOM.
    &#60;/p>
    &#60;p *ngIf="false">
        Expression is false and ngIf is false.
        This paragraph is not in the DOM.
    &#60;/p>
</pre>
<dt>描述</dt>
<dd>ngIf指令不会隐藏CSS的元素。它从DOM中物理地添加和删除它们</dd>
<pre>
    &#60;p [style.display]="'block'">
        Expression sets display to "block".
        This paragraph is visible.
    &#60;/p>
    &#60;p [style.display]="'none'">
        Expression sets display to "none".
        This paragraph is hidden but still in the DOM.
    &#60;/p>
</pre>
<dt>描述</dt>
<dd>组件及其所有后代组件都占用了资源</dd>
<dd>ng-show的优点就是再次显示元素是快速的</dd>
<dd>组件的以前的状态被保存并准备显示</dd>
<dd>该组件不会重新初始化</dd>
<dd>NgIf这样的结构指令来恢复未使用的资源</dd>


<h3>The asterisk (*) prefix</h3>
<pre>
    &#60;div *ngIf="hero" class="name">&#123; &#123;hero.name&#125;&#125;&#60;/div>

    Angular把* ngIf属性翻译成一个围绕根元素的&#60;ng-template>元素

    &#60;ng-template [ngIf]="hero">
        &#60;div class="name">&#123; &#123;hero.name&#125;&#125;&#60;/div>
    &#60;/ng-template>
</pre>
<dt>描述</dt>
<dd>* ngIf指令移动到&#60;ng-template>元素，在那里它成为一个属性绑定，[ngIf]</dd>
<dd>其余的&#60;div>，包括它的类属性，移动到&#60;ng-template>元素中</dd>

<dt>angular渲染模式</dt>
<dd>Angular在实际渲染过程中消耗了&#60;ng-template>内容， 并用诊断注释替换了&#60;ng-template>&#60;/ng-template>
</dd>
<dd>NgFor和NgSwitch ...指令遵循相同的模式</dd>



<h3>Inside *ngFor</h3>
<dt>描述</dt>
<dd>Angular以类似的方式将* ngFor转换为从星号（*）语法到&#60;ng-template>元素。</dd>

<pre>
    &#60;div *ngFor="let hero of heroes; let i=index; let odd=odd; trackBy: trackById" [class.odd]="odd">
        (&#123; &#123;i&#125;&#125;) &#123; &#123;hero.name&#125;&#125;
    &#60;/div>
              
    &#60;ng-template ngFor let-hero [ngForOf]="heroes" let-i="index" let-odd="odd" [ngForTrackBy]="trackById">
        &#60;div [class.odd]="odd">(&#123; &#123;i&#125;&#125;) &#123; &#123;hero.name&#125;&#125;&#60;/div>
    &#60;/ng-template>
</pre>
<dt>描述</dt>
<dd>至少NgFor需要一个循环变量和一个列表</dd>
<dd>可以在分配给ngFor的字符串中启用这些功能</dd>
<dd>这是在Angular的microsyntax中编写的</dd>

<dt>外部父元素与其的影响</dt>
<dd>ngFor字符串外的所有东西都保留在主元素（&#60;div>）中，因为它在&#60;ng-template>中移动</dd>
<dd>在这个例子中，[ngClass] =“odd”停留在&#60;div>上</dd>


<h3>Microsyntax</h3>
<dt>描述</dt>
<dd>Angular microsyntax允许您以紧凑友好的字符串配置指令</dd>
<dd>microsyntax解析器将该字符串转换为&#60;ng-template>上的属性</dd>
<ul>
    <li>let关键字声明了在模板中引用的模板输入变量</li>
    <li>
        <dd>microsyntax解析器使用和trackBy，title-cases（of-> Of，trackBy-> TrackBy），并用指令的属性名称（ngFor）作为前缀，产生名称ngForOf和ngForTrackBy</dd>
        <dd>这些是两个NgFor输入属性的名称</dd>
        <dd>跟踪功能是trackById</dd>
    </li>
    <li>
        <dd>由于NgFor指令循环遍历列表，它设置和重置自己的上下文对象的属性。</dd>
        <dd>这些属性包括索引和奇数，以及一个名为$ implicit的特殊属性。</dd>
    </li>
    <li>
        <dd>let-i和let-odd变量被定义为let i = index并且让odd = odd。</dd>
        <dd>Angular将它们设置为上下文索引和奇数属性的当前值。</dd>
    </li>
    <li>
        <dd>没有指定let-hero的上下文属性。它的来源是隐含的。</dd>
        <dd>Angular将let-hero设置为NgFor已经用当前迭代的英雄初始化的上下文的$隐式属性的值</dd>
    </li>
    <li>API指南描述了额外的NgFor指令属性和上下文属性</li>
    <li>NgFor是由NgForOf指令实现的</li>
</ul>
<dt>使用注意:</dt>
<dd>当编写自己的结构指令时，可以使用这些微观语法机制。</dd>


<h3>Template input variable</h3>
<dt>描述</dt>
<dd>模板输入变量是一个变量，其值可以在模板的单个实例中引用。</dd>
<dd>在这个例子中有几个这样的变量：hero，i和odd。所有前面都有关键字let</dd>
<dd>模板输入变量与模板引用变量不相同，既不是语义也不是语法。</dd>
<dd>
    使用let关键字（let hero）声明模板输入变量。
    变量的作用域限于重复模板的单个实例。
    可以在其他结构指令的定义中再次使用相同的变量名称。
    通过在变量名前添加前缀来声明模板引用变量
</dd>

<h3>One structural directive per host element(结构指令的根元素)</h3>
<dt>描述</dt>
<ul>
    <li>重复一个HTML块，但只有当特定的条件是显示的</li>
    <li>尝试将* ngFor和* ngIf放在同一根元素上但是angular会报错</li>
    <li>可以只应用一个结构指令给一个元素。</li>
    <li>结构指令可以与宿主元素及其后代做复杂的事情</li>
    <li>
        <dd>当两个指令声明相同的根元素，哪一个优先？</dd>
        <dd>NgIf还是NgFor呢？</dd>
    </li>
    <li>一个简单的解决方案：将* ngIf放在包装* ngFor元素的容器元素上。</li>
    <li>一个或两个元素可以是一个ng容器，所以你不必引入额外的HTML级别。 </li>
</ul>

<h3>Inside NgSwitch directives</h3>
<dt>描述</dt>
<dd>Angular NgSwitch实际上是一组合作指令：NgSwitch，NgSwitchCase和NgSwitchDefault</dd>
<pre>
    &#60;div [ngSwitch]="hero?.emotion">
        &#60;app-happy-hero    *ngSwitchCase="'happy'"    [hero]="hero">&#60;/app-happy-hero>
        &#60;app-sad-hero      *ngSwitchCase="'sad'"      [hero]="hero">&#60;/app-sad-hero>
        &#60;app-confused-hero *ngSwitchCase="'app-confused'" [hero]="hero">&#60;/app-confused-hero>
        &#60;app-unknown-hero  *ngSwitchDefault           [hero]="hero">&#60;/app-unknown-hero>
    &#60;/div>
</pre>
<dt>描述</dt>
<dd>分配给NgSwitch（hero.emotion）的开关值确定显示开关情况下</dd>
<dd>NgSwitch本身不是一个结构性的指令。这是一个属性指令，控制另外两个switch指令的行为。</dd>
<dd>这就是为什么你写[ngSwitch]，从不* ngSwitch</dd>
<dd>NgSwitchCase和NgSwitchDefault是结构指令。</dd>
<dd>使用星号（*）前缀表示法将它们附加到元素。</dd>
<dd>当NgSwitchCase的值与交换机的值匹配时，显示它的根元素。</dd>
<dd>NgSwitchDefault在没有同级NgSwitchCase匹配交换机值时显示根元素。</dd>

<dt>
    应用指令的元素是其根元素。
    &#60;happy-hero>是happy * ngSwitchCase的根元素。
    &#60;unknown-hero>是* ngSwitchDefault的根元素。
</dt>
<dd>和其他结构指令一样，NgSwitchCase和NgSwitchDefault可以被解析成&#60;ng-template>元素的形式。</dd>
<pre>
    &#60;div [ngSwitch]="hero?.emotion">
        &#60;ng-template [ngSwitchCase]="'happy'">
            &#60;app-happy-hero [hero]="hero">&#60;/app-happy-hero>
        &#60;/ng-template>
        &#60;ng-template [ngSwitchCase]="'sad'">
            &#60;app-sad-hero [hero]="hero">&#60;/app-sad-hero>
        &#60;/ng-template>
        &#60;ng-template [ngSwitchCase]="'confused'">
            &#60;app-confused-hero [hero]="hero">&#60;/app-confused-hero>
        &#60;/ng-template >
        &#60;ng-template ngSwitchDefault>
            &#60;app-unknown-hero [hero]="hero">&#60;/app-unknown-hero>
        &#60;/ng-template>
    &#60;/div>
</pre>

<h3>Prefer the asterisk (*) syntax.(星号语法)</h3>
<dt>描述</dt>
<dd>星号（*）语法比desugared形式更清晰</dd>
<dd>当没有单个元素来存放指令时，使用&#60;ng-container></dd>
<dd>
    虽然在模板属性或元素表单中应用结构指令的原因很少，
    但了解Angular创建&#60;ng-template>并了解其工作原理仍然很重要。
</dd>
<dd>当编写你自己的结构指令时，你会参考&#60;ng-template></dd>

<h3>The &#60;ng-template></h3>
<dt>描述</dt>
<dd>&#60;ng-template>是一个用于呈现HTML的Angular元素。它从不直接显示</dd>
<dd>在呈现视图之前，Angular用注释替换了&#60;ng-template>及其内容。</dd>
<dd>如果没有结构指令，而只是在&#60;ng-template>中包含一些元素，那么这些元素就会消失</dd>
<pre>
    &#60;p>Hip!&#60;/p>
    &#60;ng-template>
        &#60;p>Hip!&#60;/p>
    &#60;/ng-template>
    &#60;p>Hooray!&#60;/p>
</pre>
<dt>结构指令使得&#60;ng-template>可以在您编写自己的结构指令时看到</dt>

<h3>Group sibling elements with &#60;ng-container>(结构组建分组)</h3>

<dt>实例</dt>
<dd>通常有一个根本元素可以并且应该主持结构指示。列表元素（&#60;li>）是一个典型的NgFor中继器的主机元素。</dd>
<pre>
    &#60;li *ngFor="let hero of heroes">&#123; &#123;hero.name&#125;&#125;&#60;/li>
</pre>
<dt>描述</dt>
<dd>如果没有主机元素，通常可以将内容包装在HTML容器元素（如&#60;div>）中，然后将该指令附加到该包装器。</dd>
<pre>
    &#60;div *ngIf="hero" class="name">&#123; &#123;hero.name&#125;&#125;&#60;/div>
</pre>
<dt>使用描述</dt>
<dd>引入另一个容器元素（通常是&#60;span>或&#60;div>）将单个元素归入单个根目录通常是无害的</dd>
<pre>
    &#60;p>
        I turned the corner
        &#60;span *ngIf="hero">
            and saw &#123; &#123;hero.name&#125;&#125;. I waved
        &#60;/span>
        and continued on my way.
    &#60;/p>
</pre>

<h3>&#60;ng-container> to the rescue新解决方案</h3>
<dt>描述</dt>
<dd>Angular &#60;ng-container>是一个分组元素，不会干扰样式或布局，因为Angular不会将其放在DOM中。</dd>
<pre>
    &#60;p>
        I turned the corner
        &#60;ng-container *ngIf="hero">
            and saw &#123; &#123;hero.name&#125;&#125;. I waved
        &#60;/ng-container>
        and continued on my way.
    &#60;/p>
</pre>

<dt>现在有条件地用&#60;ng-container>排除一个select &#60;option>选项</dt>
<pre>
    &#60;div>
        Pick your favorite hero
        (&#60;label>&#60;input type="checkbox" checked (change)="showSad = !showSad">show sad&#60;/label>)
    &#60;/div>
    &#60;select [(ngModel)]="hero">
        &#60;ng-container *ngFor="let h of heroes">
            &#60;ng-container *ngIf="showSad || h.emotion !== 'sad'">
                &#60;option [ngValue]="h">&#123; &#123;h.name&#125;&#125; (&#123; &#123;h.emotion&#125;&#125;)&#60;/option>
            &#60;/ng-container>
        &#60;/ng-container>
    &#60;/select>
</pre>
<dd>&#60;ng-container>是Angular解析器识别的语法元素。这不是指令，组件，类或接口。</dd>
<dd>是一个JavaScript if-block中的花括号</dd>
<pre>
    if (someCondition) &#123;
        statement1;
        statement2;
        statement3;
    &#125;
</pre>
<dd>如果没有这些大括号，JavaScript只会在您打算将所有这些条件作为一个块进行有条件执行时才执行第一条语句。</dd>
<dd>&#60;ng-container>满足Angular模板中类似的需求。</dd>

<h3>Write a structural directive</h3>
<pre>
    &#60;p *appUnless="condition">Show this sentence unless the condition is true.&#60;/p>
</pre>

<dt>创建指令与创建组件类似</dt>
<ul>
    <li>
        <dd>Import the Directive decorator (instead of the Component decorator).</dd>
        <dd>导入指令装饰器（而不是组件装饰器）。</dd>
    </li>
    <li>
        <dd>Import the Input, TemplateRef, and ViewContainerRef symbols; you'll need them for any structural directive</dd>
        <dd>导入Input，TemplateRef和ViewContainerRef符号;你会需要他们的任何结构指令。</dd>
    </li>
    <li>
        <dd>Apply the decorator to the directive class.</dd>
        <dd>将装饰器应用于指令类。</dd>
    </li>
    <li>
        <dd>Set the CSS attribute selector that identifies the directive when applied to an element in a template.</dd>
        <dd>设置应用于模板中的元素时标识指令的CSS属性选择器。</dd>
    </li>
</ul>
<pre>
    import &#123; Directive, Input, TemplateRef, ViewContainerRef &#125; from '@angular/core';
    
    @Directive(&#123; selector: '[appUnless]'&#125;)
        export class UnlessDirective &#123;
    &#125;
</pre>
<dt>描述</dt>
<dd>该指令的选择器通常是指令的方括号中的属性名称，[appUnless]。</dd>
<dd>括号定义了一个CSS属性选择器。指令属性名称应拼写在lowerCamelCase中，并以前缀开头。</dd>
<dd>不要使用ng。该前缀属于Angular。</dd>

<h4>TemplateRef and ViewContainerRef</h4>
<dt>描述</dt>
<dd>这样的一个简单的结构指令从Angular生成的&#60;ng-template>中创建一个嵌入式视图，并将该视图插入与指令的原始&#60;p>主机元素相邻的视图容器中。</dd>
<dd>通过TemplateRef获取&#60;ng-template>内容，并通过ViewContainerRef访问视图容器。你在指令构造函数中注入这两个类的私有变量</dd>
<pre>
    constructor(
        private templateRef: TemplateRef&#60;any>,
        private viewContainer: ViewContainerRef) &#123; &#125;)
</pre>

<h4>The appUnless property</h4>
<dt>描述</dt>
<dd>指令期望将真/假条件绑定到[appUnless]。这意味着该指令需要一个appUnless属性，用@Input装饰</dd>
<pre>
    @Input() set appUnless(condition: boolean) &#123;
        if (!condition && !this.hasView) &#123;
            this.viewContainer.createEmbeddedView(this.templateRef);
            this.hasView = true;
        &#125; else if (condition && this.hasView) &#123;
            this.viewContainer.clear();
            this.hasView = false;
        &#125;
    &#125;
</pre>
<dt>描述</dt>
<dd>只要条件的值发生变化，Angular就会设置appUnless属性。</dd>
<dd>因为appUnless属性确实有效，所以需要一个setter。</dd>
<dt>使用结构</dt>
<ul>
    <li>如果条件是假的，并且视图尚未创建，请告诉视图容器从模板创建嵌入的视图</li>
    <li>如果条件是真的，并且当前显示视图，清除也破坏视图的容器。</li>
</ul>
<dd>没有人读取appUnless属性，所以它不需要一个getter。</dd>
<pre>
    import &#123; Directive, Input, TemplateRef, ViewContainerRef &#125; from '@angular/core';
    
    /**
      * Add the template content to the DOM unless the condition is true.
      */
    @Directive(&#123; selector: '[appUnless]'&#125;)
    export class UnlessDirective &#123;
        private hasView = false;
    
        constructor(
        private templateRef: TemplateRef&#60;any>,
        private viewContainer: ViewContainerRef) &#123; &#125;
    
        @Input() set appUnless(condition: boolean) &#123;
            if (!condition && !this.hasView) &#123;
                this.viewContainer.createEmbeddedView(this.templateRef);
                this.hasView = true;
            &#125; else if (condition && this.hasView) &#123;
                this.viewContainer.clear();
                this.hasView = false;
            &#125;
        &#125;
    &#125;
</pre>
<dd>将此指令添加到AppModule的声明数组中</dd>
<pre>
    &#60;p *appUnless="condition" class="unless a">
        (A) This paragraph is displayed because the condition is false.
    &#60;/p>
    
    &#60;p *appUnless="!condition" class="unless b">
        (B) Although the condition is true,
        this paragraph is displayed because appUnless is set to false.
    &#60;/p>
</pre>

<h2>Summary</h2>
<pre>
    app.component.ts

    import &#123; Component &#125; from '@angular/core';
    
    import &#123; Hero, heroes &#125; from './hero';
    
    @Component(&#123;
        selector: 'app-root',
        templateUrl: './app.component.html',
        styleUrls: [ './app.component.css' ]
    &#125;)
    export class AppComponent &#123;
        heroes = heroes;
        hero = this.heroes[0];
        
        condition = false;
        logs: string[] = [];
        showSad = true;
        status = 'ready';
        
        trackById(index: number, hero: Hero): number &#123; return hero.id; &#125;
    &#125;

    app.component.html

    &#60;h1>Structural Directives&#60;/h1>
    
    &#60;p>Conditional display of hero&#60;/p>
    
    &#60;blockquote>
        &#60;div *ngIf="hero" class="name">&#123; &#123;hero.name&#125;&#125;&#60;/div>
    &#60;/blockquote>
    
    &#60;p>List of heroes&#60;/p>
    
    &#60;ul>
        &#60;li *ngFor="let hero of heroes">&#123; &#123;hero.name&#125;&#125;&#60;/li>
    &#60;/ul>
    
    
    &#60;hr>
    
    &#60;h2 id="ngIf">NgIf&#60;/h2>
    
    &#60;p *ngIf="true">
        Expression is true and ngIf is true.
        This paragraph is in the DOM.
    &#60;/p>
    &#60;p *ngIf="false">
        Expression is false and ngIf is false.
        This paragraph is not in the DOM.
    &#60;/p>
    
    &#60;p [style.display]="'block'">
        Expression sets display to "block".
        This paragraph is visible.
    &#60;/p>
    &#60;p [style.display]="'none'">
        Expression sets display to "none".
        This paragraph is hidden but still in the DOM.
    &#60;/p>
    
    &#60;h4>NgIf with template&#60;/h4>
    &#60;p>&lt;ng-template&gt; element&#60;/p>
    &#60;ng-template [ngIf]="hero">
        &#60;div class="name">&#123; &#123;hero.name&#125;&#125;&#60;/div>
    &#60;/ng-template>
    
    &#60;hr>
    
    &#60;h2 id="ng-container">&lt;ng-container&gt;&#60;/h2>
    
    &#60;h4>*ngIf with a &lt;ng-container&gt;&#60;/h4>
    
    &#60;button (click)="hero = hero ? null : heroes[0]">Toggle hero&#60;/button>
    
    &#60;p>
        I turned the corner
        &#60;ng-container *ngIf="hero">
            and saw &#123; &#123;hero.name&#125;&#125;. I waved
        &#60;/ng-container>
        and continued on my way.
    &#60;/p>
    &#60;p>
        I turned the corner
        &#60;span *ngIf="hero">
            and saw &#123; &#123;hero.name&#125;&#125;. I waved
        &#60;/span>
        and continued on my way.
    &#60;/p>
    
    &#60;p>&#60;i>&lt;select&gt; with &lt;span&gt;&#60;/i>&#60;/p>
    &#60;div>
        Pick your favorite hero
        (&#60;label>&#60;input type="checkbox" checked (change)="showSad = !showSad">show sad&#60;/label>)
    &#60;/div>
    &#60;select [(ngModel)]="hero">
        &#60;span *ngFor="let h of heroes">
            &#60;span *ngIf="showSad || h.emotion !== 'sad'">
                &#60;option [ngValue]="h">&#123; &#123;h.name&#125;&#125; (&#123; &#123;h.emotion&#125;&#125;)&#60;/option>
            &#60;/span>
        &#60;/span>
    &#60;/select>
    
    &#60;p>&#60;i>&lt;select&gt; with &lt;ng-container&gt;&#60;/i>&#60;/p>
    &#60;div>
        Pick your favorite hero
        (&#60;label>&#60;input type="checkbox" checked (change)="showSad = !showSad">show sad&#60;/label>)
    &#60;/div>
    &#60;select [(ngModel)]="hero">
        &#60;ng-container *ngFor="let h of heroes">
            &#60;ng-container *ngIf="showSad || h.emotion !== 'sad'">
                &#60;option [ngValue]="h">&#123; &#123;h.name&#125;&#125; (&#123; &#123;h.emotion&#125;&#125;)&#60;/option>
            &#60;/ng-container>
        &#60;/ng-container>
    &#60;/select>
    &#60;br>&#60;br>
    
    &#60;hr>
    
    &#60;h2 id="ngFor">NgFor&#60;/h2>
    
    &#60;div class="box">
    
    &#60;p class="code">&lt;div *ngFor="let hero of heroes; let i=index; let odd=odd; trackBy: trackById" [class.odd]="odd"&gt;&#60;/p>
    &#60;div *ngFor="let hero of heroes; let i=index; let odd=odd; trackBy: trackById" [class.odd]="odd">
        (&#123; &#123;i&#125;&#125;) &#123; &#123;hero.name&#125;&#125;
    &#60;/div>
    
    &#60;p class="code">&lt;ng-template ngFor let-hero [ngForOf]="heroes" let-i="index" let-odd="odd" [ngForTrackBy]="trackById"/&gt;&#60;/p>
    &#60;ng-template ngFor let-hero [ngForOf]="heroes" let-i="index" let-odd="odd" [ngForTrackBy]="trackById">
        &#60;div [class.odd]="odd">(&#123; &#123;i&#125;&#125;) &#123; &#123;hero.name&#125;&#125;&#60;/div>
    &#60;/ng-template>
    
    &#60;/div>
    &#60;hr>
    
    &#60;h2 id="ngSwitch">NgSwitch&#60;/h2>
    
    &#60;div>Pick your favorite hero&#60;/div>
    &#60;p>
        &#60;label *ngFor="let h of heroes">
            &#60;input type="radio" name="heroes" [(ngModel)]="hero" [value]="h">&#123; &#123;h.name&#125;&#125;
        &#60;/label>
        &#60;label>&#60;input type="radio" name="heroes" (click)="hero = null">None of the above&#60;/label>
    &#60;/p>
    
    &#60;h4>NgSwitch&#60;/h4>
    
    &#60;div [ngSwitch]="hero?.emotion">
        &#60;app-happy-hero    *ngSwitchCase="'happy'"    [hero]="hero">&#60;/app-happy-hero>
        &#60;app-sad-hero      *ngSwitchCase="'sad'"      [hero]="hero">&#60;/app-sad-hero>
        &#60;app-confused-hero *ngSwitchCase="'app-confused'" [hero]="hero">&#60;/app-confused-hero>
        &#60;app-unknown-hero  *ngSwitchDefault           [hero]="hero">&#60;/app-unknown-hero>
    &#60;/div>
    
    &#60;h4>NgSwitch with &lt;ng-template&gt;&#60;/h4>
    &#60;div [ngSwitch]="hero?.emotion">
        &#60;ng-template [ngSwitchCase]="'happy'">
            &#60;app-happy-hero [hero]="hero">&#60;/app-happy-hero>
        &#60;/ng-template>
        &#60;ng-template [ngSwitchCase]="'sad'">
            &#60;app-sad-hero [hero]="hero">&#60;/app-sad-hero>
        &#60;/ng-template>
        &#60;ng-template [ngSwitchCase]="'confused'">
            &#60;app-confused-hero [hero]="hero">&#60;/app-confused-hero>
        &#60;/ng-template >
        &#60;ng-template ngSwitchDefault>
            &#60;app-unknown-hero [hero]="hero">&#60;/app-unknown-hero>
        &#60;/ng-template>
    &#60;/div>
    
    &#60;hr>
    
    &#60;h2>&lt;ng-template&gt;&#60;/h2>
    &#60;p>Hip!&#60;/p>
    &#60;ng-template>
        &#60;p>Hip!&#60;/p>
    &#60;/ng-template>
    &#60;p>Hooray!&#60;/p>
    
    &#60;hr>
    
    &#60;h2 id="appUnless">UnlessDirective&#60;/h2>
    &#60;p>
        The condition is currently
        &#60;span [ngClass]="&#123; 'a': !condition, 'b': condition, 'unless': true &#125;">&#123; &#123;condition&#125;&#125;&#60;/span>.
        &#60;button
            (click)="condition = !condition"
            [ngClass] = "&#123; 'a': condition, 'b': !condition &#125;" >
            Toggle condition to &#123; &#123;condition ? 'false' : 'true'&#125;&#125;
        &#60;/button>
    &#60;/p>
    &#60;p *appUnless="condition" class="unless a">
        (A) This paragraph is displayed because the condition is false.
    &#60;/p>
    
    &#60;p *appUnless="!condition" class="unless b">
        (B) Although the condition is true,
        this paragraph is displayed because appUnless is set to false.
    &#60;/p>
    
    
    &#60;h4>UnlessDirective with template&#60;/h4>
    
    &#60;p *appUnless="condition">Show this sentence unless the condition is true.&#60;/p>
    
    &#60;p *appUnless="condition" class="code unless">
        (A) &lt;p *appUnless="condition" class="code unless"&gt;
    &#60;/p>
    
    &#60;ng-template [appUnless]="condition">
        &#60;p class="code unless">
            (A) &lt;ng-template [appUnless]="condition"&gt;
        &#60;/p>
    &#60;/ng-template>

    app.module.ts

    import &#123; NgModule &#125;      from '@angular/core';
    import &#123; FormsModule &#125;   from '@angular/forms';
    import &#123; BrowserModule &#125; from '@angular/platform-browser';
    
    import &#123; AppComponent &#125;         from './app.component';
    import &#123; heroSwitchComponents &#125; from './hero-switch.components';
    import &#123; UnlessDirective &#125;    from './unless.directive';
    
    @NgModule(&#123;
      imports: [ BrowserModule, FormsModule ],
      declarations: [
        AppComponent,
        heroSwitchComponents,
        UnlessDirective
      ],
      bootstrap: [ AppComponent ]
    &#125;)
    export class AppModule &#123; &#125;

    hero.ts

    export class Hero &#123;
        id: number;
        name: string;
        emotion?: string;
    &#125;
    
    export const heroes: Hero[] = [
        &#123; id: 1, name: 'Mr. Nice',  emotion: 'happy'&#125;,
        &#123; id: 2, name: 'Narco',     emotion: 'sad' &#125;,
        &#123; id: 3, name: 'Windstorm', emotion: 'confused' &#125;,
        &#123; id: 4, name: 'Magneta'&#125;
    ];

    hero-switch.component.ts

    import &#123; Component, Input &#125; from '@angular/core';
    import &#123; Hero &#125; from './hero';
    
    @Component(&#123;
      selector: 'app-happy-hero',
      template: `Wow. You like &#123; &#123;hero.name&#125;&#125;. What a happy hero ... just like you.`
      &#125;)
    export class HappyHeroComponent &#123;
      @Input() hero: Hero;
      &#125;
    
    @Component(&#123;
      selector: 'app-sad-hero',
      template: `You like &#123; &#123;hero.name&#125;&#125;? Such a sad hero. Are you sad too?`
    &#125;)
    export class SadHeroComponent &#123;
      @Input() hero: Hero;
    &#125;
    
    @Component(&#123;
      selector: 'app-confused-hero',
      template: `Are you as confused as &#123; &#123;hero.name&#125;&#125;?`
    &#125;)
    export class ConfusedHeroComponent &#123;
      @Input() hero: Hero;
    &#125;
    
    @Component(&#123;
      selector: 'app-unknown-hero',
      template: `&#123; &#123;message&#125;&#125;`
      &#125;)
    export class UnknownHeroComponent &#123;
      @Input() hero: Hero;
      get message() &#123;
        return this.hero && this.hero.name ?
          `$&#123;this.hero.name&#125; is strange and mysterious.` :
          'Are you feeling indecisive?';
      &#125;
    &#125;
    
    export const heroSwitchComponents =
      [ HappyHeroComponent, SadHeroComponent, ConfusedHeroComponent, UnknownHeroComponent ];

    unless.directive.ts

    import &#123; Directive, Input, TemplateRef, ViewContainerRef &#125; from '@angular/core';
    
    /**
     * Add the template content to the DOM unless the condition is true.
     *
     * If the expression assigned to `appUnless` evaluates to a truthy value
     * then the templated elements are removed removed from the DOM,
     * the templated elements are (re)inserted into the DOM.
     *
     * &#60;div *ngUnless="errorCount" class="success">
     *   Congrats! Everything is great!
     * &#60;/div>
     *
     * ### Syntax
     *
     * - `&#60;div *appUnless="condition">...&#60;/div>`
     * - `&#60;ng-template [appUnless]="condition">&#60;div>...&#60;/div>&#60;/ng-template>`
     *
     */
    @Directive(&#123; selector: '[appUnless]'&#125;)
    export class UnlessDirective &#123;
      private hasView = false;
    
      constructor(
        private templateRef: TemplateRef&#60;any>,
        private viewContainer: ViewContainerRef) &#123; &#125;
    
      @Input() set appUnless(condition: boolean) &#123;
        if (!condition && !this.hasView) &#123;
          this.viewContainer.createEmbeddedView(this.templateRef);
          this.hasView = true;
        &#125; else if (condition && this.hasView) &#123;
          this.viewContainer.clear();
          this.hasView = false;
        &#125;
      &#125;
    &#125;
</pre>