<h1 class="text-center">Animations</h1>

<h4>Overview</h4>
<dt>描述</dt>
<dd>angular的动画系统可以让你构建动画，运行纯CSS动画中的同类本地性能</dd>
<a href="{{onLineHref}}" target="{{targetType}}">在线实例</a>
<span>|</span>
<a href="{{downloadHref}}" target="{{targetType}}">实例下载</a>

<h3>Setup</h3>
<dt>描述</dt>
<dd>在向应用程序添加动画之前，需要将一些动画特定的模块和函数导入到根应用程序模块</dd>
<pre>
    app.module.ts

    import &#123; BrowserModule &#125; from '@angular/platform-browser';
    import &#123; BrowserAnimationsModule &#125; from '@angular/platform-browser/animations';
    
    @NgModule(&#123;
        imports: [ BrowserModule, BrowserAnimationsModule ],
        // ... more stuff ...
    &#125;)
    export class AppModule &#123; &#125;
</pre>

<h4>Example basics</h4>
<dt>动画示例为hero列表添加了动画</dt>
<pre>
    hero.service.ts

    export class Hero &#123;
        constructor(public name: string, public state = 'inactive') &#123; &#125;
        
        toggleState() &#123;
            this.state = this.state === 'active' ? 'inactive' : 'active';
        &#125;
    &#125;
</pre>
<dd>按钮触发器将更改为所有示例组件同时看到的列表</dd>

<h4>Transitioning between two states</h4>
<dt>描述</dt>
<dd>可以构建一个简单的动画，在由模型属性驱动的两个状态之间转换元素</dd>
<dd>动画可以在@component元数据中定义</dd>
<img src="https://angular.io/generated/images/guide/animations/animation_basic_click.gif">
<pre>
    hero-list-basic.component.ts

    import &#123;
        Component,
        Input
    &#125; from '@angular/core';
    import &#123;
        trigger,
        state,
        style,
        animate,
        transition
    &#125; from '@angular/animations';
</pre>
<dt>描述</dt>
<dd>通过这些，可以在组件元数据中定义一个名为herostate的动画触发器</dd>
<dd>它使用动画在两种状态之间转换：活动和不活动</dd>
<dd>当处于激活状态时，该元素会以较大的尺寸和较浅的颜色出现</dd>
<pre>
    hero-list-basic.component.ts

    animations: [
        trigger('heroState', [
        state('inactive', style(&#123;
            backgroundColor: '#eee',
            transform: 'scale(1)'
        &#125;)),
        state('active',   style(&#123;
            backgroundColor: '#cfd8dc',
            transform: 'scale(1.1)'
        &#125;)),
        transition('inactive => active', animate('100ms ease-in')),
        transition('active => inactive', animate('100ms ease-out'))
        ])
    ]
</pre>
<dt>描述</dt>
<dd>在动画元数据中内联定义动画样式（颜色和变换）</dd>
<dd>使用[@triggername]语法，将刚刚定义的动画附加到组件模板中的一个或多个元素</dd>
<pre>
    template: `
        &#60;ul>
            &#60;li *ngFor="let hero of heroes"
                [@heroState]="hero.state"
                (click)="hero.toggleState()">
                &#123; &#123;hero.name&#125; &#125;
            &#60;/li>
        &#60;/ul>
    `,
</pre>
<dt>描述</dt>
<dd>动画触发器适用于由ngfor重复的每个元素</dd>
<dd>每个重复的元素独立动画</dd>
<dd>该属性的值绑定到表达式hero.state并始终处于活动状态或不活动状态</dd>
<dd>使用这个设置，只要英雄对象改变状态，就会出现一个动画转换</dd>
<pre>
    hero-list-basic.component.ts

    import &#123;
        Component,
        Input
    &#125; from '@angular/core';
    import &#123;
        trigger,
        state,
        style,
        animate,
        transition
    &#125; from '@angular/animations';
    
    import &#123; Hero &#125; from './hero.service';
    
    @Component(&#123;
        selector: 'app-hero-list-basic',
        template: `
        &#60;ul>
            &#60;li *ngFor="let hero of heroes"
                [@heroState]="hero.state"
                (click)="hero.toggleState()">
            &#123; &#123;hero.name}}
            &#60;/li>
        &#60;/ul>
        `,
        styleUrls: ['./hero-list.component.css'],
        animations: [
        trigger('heroState', [
            state('inactive', style(&#123;
            backgroundColor: '#eee',
            transform: 'scale(1)'
            &#125;)),
            state('active',   style(&#123;
            backgroundColor: '#cfd8dc',
            transform: 'scale(1.1)'
            &#125;)),
            transition('inactive => active', animate('100ms ease-in')),
            transition('active => inactive', animate('100ms ease-out'))
        ])
        ]
    &#125;)
    export class HeroListBasicComponent &#123;
        @Input() heroes: Hero[];
    &#125;
</pre>

<h4>States and transitions</h4>
<dt>描述</dt>
<dd>angular动画被定义为逻辑状态和状态之间的转换</dd>
<dd>动画状态是在应用程序代码中定义的字符串值</dd>
<dd>在上面的例子中，状态“主动”和“不活动”是基于英雄对象的逻辑状态</dd>
<dd>状态的来源可以是一个简单的对象属性，就像在这种情况下一样，或者它可以是一个方法中计算的值</dd>
<dd>可以将它读入组件的模板</dd>
<pre>
    src/app/hero-list-basic.component.ts

    state('inactive', style(&#123;
        backgroundColor: '#eee',
        transform: 'scale(1)'
    &#125;)),
    state('active',   style(&#123;
        backgroundColor: '#cfd8dc',
        transform: 'scale(1.1)'
    &#125;)),
</pre>
<dt>描述</dt>
<dd>这些状态定义指定每个状态的结束样式</dd>
<dd>一旦它转换到那个状态，它就被应用到这个元素上，并保持它在这个状态下的状态</dd>
<dd>正在定义元素在不同状态下的风格</dd>
<dd>在定义状态之后，可以定义状态之间的转换</dd>
<dd>每个转换控制一组样式之间切换的时间和下一个</dd>
<pre>
    src/app/hero-list-basic.component.ts

    transition('inactive => active', animate('100ms ease-in')),
    transition('active => inactive', animate('100ms ease-out'))
</pre>
<img class="max-width-50p" src="https://angular.io/generated/images/guide/animations/ng_animate_transitions_inactive_active.png">
<dd>如果多个转换具有相同的定时配置，则可以将它们组合到相同的转换定义中</dd>
<pre>
    transition('inactive => active, active => inactive',
    animate('100ms ease-out'))

    当一个转换的两个方向具有相同的时间时，可以使用简写语法<=>

    transition('inactive <=> active', animate('100ms ease-out'))
</pre>
<dt>描述</dt>
<dd>也可以在动画中应用样式，但在动画完成后不能保留它</dd>
<dd>可以在转换中内联定义这种样式。 在这个例子中，元素立即接收一组样式，然后动画到下一个</dd>
<dd>当转换完成时，这些样式都不会被保留，因为它们没有在状态中定义</dd>
<pre>
    src/app/hero-list-inline-styles.component.ts

    transition('inactive => active', [
        style(&#123;
            backgroundColor: '#cfd8dc',
            transform: 'scale(1.3)'
        &#125;),
        animate('80ms ease-in', style(&#123;
            backgroundColor: '#eee',
            transform: 'scale(1)'
        &#125;))
    ]),
</pre>

<h4>The wildcard state *</h4>
<dt>描述</dt>
<dd>*（“wildcard|通配符”）状态匹配任何动画状态</dd>
<dd>这对定义适用的样式和转换非常有用，无论动画处于哪种状态</dd>
<ul>
    <li>当元素的状态从活动状态变为其他状态时，应用active => * transition</li>
    <li>当两个状态之间发生任何变化时，将应用* => *转换</li>
</ul>
<img class="max-width-50p" src="https://angular.io/generated/images/guide/animations/ng_animate_transitions_inactive_active_wildcards.png">

<h4>The void state</h4>
<dt>描述</dt>
<dd>被称为void的特殊状态可以适用于任何动画</dd>
<dd>适用于元素未附加到视图时，可能是因为它尚未添加或因为它已被删除</dd>
<dd>虚空状态对于定义进入和离开动画是有用的</dd>
<dt>注意:当元素离开视图时，不管它在离开之前处于什么状态，都应用* => void转换</dt>
<img src="https://angular.io/generated/images/guide/animations/ng_animate_transitions_void_in.png" class="max-width-50p">
<dd>通配符状态*也匹配void</dd>

<h4>Example: Entering and leaving</h4>
<dt>描述</dt>
<dd>使用void和*状态可以定义动画元素进入和离开的转换</dd>
<ul>
    <li>Enter: void => *</li>
    <li>Leave: * => void</li>
</ul>
<img src="https://angular.io/generated/images/guide/animations/animation_enter_leave.gif" class="max-width-50p">
<dd>在下面的动画数组中，有两个使用void =>和* => void语法的元素来为视图内外的元素设置动画</dd>
<pre>
    hero-list-enter-leave.component.ts

    animations: [
        trigger('flyInOut', [
        state('in', style(&#123;transform: 'translateX(0)'&#125;)),
        transition('void => *', [
            style(&#123;transform: 'translateX(-100%)'&#125;),
            animate(100)
        ]),
        transition('* => void', [
            animate(100, style(&#123;transform: 'translateX(100%)'&#125;))
        ])
        ])
    ]
</pre>
<dt>描述</dt>
<dd>请注意，在这种情况下，样式直接在转换定义中应用于空状态，而不是在单独的状态（void）定义中应用</dd>
<dd>因此，进入和离开的转换是不同的：元素从左边进入，从右边进入</dd>
<pre>
    transition(':enter', [ ... ]); // void => *
    transition(':leave', [ ... ]); // * => void
</pre>