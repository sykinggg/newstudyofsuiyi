<h1 class="text-center">Animations</h1>

<h4>Overview</h4>
<dt>描述</dt>
<dd>angular的动画系统可以让你构建动画，运行纯CSS动画中的同类本地性能</dd>
<a href="&#123;&#123;onLineHref&#125;&#125;" target="&#123;&#123;targetType&#125;&#125;">在线实例</a>
<span>|</span>
<a href="&#123;&#123;downloadHref&#125;&#125;" target="&#123;&#123;targetType&#125;&#125;">实例下载</a>

<h3>Setup</h3>
<dt>描述</dt>
<dd>在向应用程序添加动画之前，需要将一些动画特定的模块和函数导入到根应用程序模块</dd>
<pre>
    app.module.ts

    import &#123; BrowserModule &#125; from '@angular/platform-browser';
    import &#123; BrowserAnimationsModule &#125; from '@angular/platform-browser/animations';
    
    @NgModule(&#123;
        imports: [ BrowserModule, BrowserAnimationsModule ],
        // ... more stuff ...
    &#125;)
    export class AppModule &#123; &#125;
</pre>

<h4>Example basics</h4>
<dt>动画示例为hero列表添加了动画</dt>
<pre>
    hero.service.ts

    export class Hero &#123;
        constructor(public name: string, public state = 'inactive') &#123; &#125;
        
        toggleState() &#123;
            this.state = this.state === 'active' ? 'inactive' : 'active';
        &#125;
    &#125;
</pre>
<dd>按钮触发器将更改为所有示例组件同时看到的列表</dd>

<h4>Transitioning between two states</h4>
<dt>描述</dt>
<dd>可以构建一个简单的动画，在由模型属性驱动的两个状态之间转换元素</dd>
<dd>动画可以在@component元数据中定义</dd>
<img src="https://angular.io/generated/images/guide/animations/animation_basic_click.gif">
<pre>
    hero-list-basic.component.ts

    import &#123;
        Component,
        Input
    &#125; from '@angular/core';
    import &#123;
        trigger,
        state,
        style,
        animate,
        transition
    &#125; from '@angular/animations';
</pre>
<dt>描述</dt>
<dd>通过这些，可以在组件元数据中定义一个名为herostate的动画触发器</dd>
<dd>它使用动画在两种状态之间转换：活动和不活动</dd>
<dd>当处于激活状态时，该元素会以较大的尺寸和较浅的颜色出现</dd>
<pre>
    hero-list-basic.component.ts

    animations: [
        trigger('heroState', [
        state('inactive', style(&#123;
            backgroundColor: '#eee',
            transform: 'scale(1)'
        &#125;)),
        state('active',   style(&#123;
            backgroundColor: '#cfd8dc',
            transform: 'scale(1.1)'
        &#125;)),
        transition('inactive => active', animate('100ms ease-in')),
        transition('active => inactive', animate('100ms ease-out'))
        ])
    ]
</pre>
<dt>描述</dt>
<dd>在动画元数据中内联定义动画样式（颜色和变换）</dd>
<dd>使用[@triggername]语法，将刚刚定义的动画附加到组件模板中的一个或多个元素</dd>
<pre>
    template: `
        &#60;ul>
            &#60;li *ngFor="let hero of heroes"
                [@heroState]="hero.state"
                (click)="hero.toggleState()">
                &#123; &#123;hero.name&#125; &#125;
            &#60;/li>
        &#60;/ul>
    `,
</pre>
<dt>描述</dt>
<dd>动画触发器适用于由ngfor重复的每个元素</dd>
<dd>每个重复的元素独立动画</dd>
<dd>该属性的值绑定到表达式hero.state并始终处于活动状态或不活动状态</dd>
<dd>使用这个设置，只要数据对象改变状态，就会出现一个动画转换</dd>
<pre>
    hero-list-basic.component.ts

    import &#123;
        Component,
        Input
    &#125; from '@angular/core';
    import &#123;
        trigger,
        state,
        style,
        animate,
        transition
    &#125; from '@angular/animations';
    
    import &#123; Hero &#125; from './hero.service';
    
    @Component(&#123;
        selector: 'app-hero-list-basic',
        template: `
        &#60;ul>
            &#60;li *ngFor="let hero of heroes"
                [@heroState]="hero.state"
                (click)="hero.toggleState()">
            &#123; &#123;hero.name&#125;&#125;
            &#60;/li>
        &#60;/ul>
        `,
        styleUrls: ['./hero-list.component.css'],
        animations: [
        trigger('heroState', [
            state('inactive', style(&#123;
            backgroundColor: '#eee',
            transform: 'scale(1)'
            &#125;)),
            state('active',   style(&#123;
            backgroundColor: '#cfd8dc',
            transform: 'scale(1.1)'
            &#125;)),
            transition('inactive => active', animate('100ms ease-in')),
            transition('active => inactive', animate('100ms ease-out'))
        ])
        ]
    &#125;)
    export class HeroListBasicComponent &#123;
        @Input() heroes: Hero[];
    &#125;
</pre>

<h4>States and transitions</h4>
<dt>描述</dt>
<dd>angular动画被定义为逻辑状态和状态之间的转换</dd>
<dd>动画状态是在应用程序代码中定义的字符串值</dd>
<dd>在上面的例子中，状态“主动”和“不活动”是基于数据对象的逻辑状态</dd>
<dd>状态的来源可以是一个简单的对象属性，就像在这种情况下一样，或者它可以是一个方法中计算的值</dd>
<dd>可以将它读入组件的模板</dd>
<pre>
    src/app/hero-list-basic.component.ts

    state('inactive', style(&#123;
        backgroundColor: '#eee',
        transform: 'scale(1)'
    &#125;)),
    state('active',   style(&#123;
        backgroundColor: '#cfd8dc',
        transform: 'scale(1.1)'
    &#125;)),
</pre>
<dt>描述</dt>
<dd>这些状态定义指定每个状态的结束样式</dd>
<dd>一旦它转换到那个状态，它就被应用到这个元素上，并保持它在这个状态下的状态</dd>
<dd>正在定义元素在不同状态下的风格</dd>
<dd>在定义状态之后，可以定义状态之间的转换</dd>
<dd>每个转换控制一组样式之间切换的时间和下一个</dd>
<pre>
    src/app/hero-list-basic.component.ts

    transition('inactive => active', animate('100ms ease-in')),
    transition('active => inactive', animate('100ms ease-out'))
</pre>
<img class="max-width-50p" src="https://angular.io/generated/images/guide/animations/ng_animate_transitions_inactive_active.png">
<dd>如果多个转换具有相同的定时配置，则可以将它们组合到相同的转换定义中</dd>
<pre>
    transition('inactive => active, active => inactive',
    animate('100ms ease-out'))

    当一个转换的两个方向具有相同的时间时，可以使用简写语法<=>

    transition('inactive <=> active', animate('100ms ease-out'))
</pre>
<dt>描述</dt>
<dd>也可以在动画中应用样式，但在动画完成后不能保留它</dd>
<dd>可以在转换中内联定义这种样式。 在这个例子中，元素立即接收一组样式，然后动画到下一个</dd>
<dd>当转换完成时，这些样式都不会被保留，因为它们没有在状态中定义</dd>
<pre>
    src/app/hero-list-inline-styles.component.ts

    transition('inactive => active', [
        style(&#123;
            backgroundColor: '#cfd8dc',
            transform: 'scale(1.3)'
        &#125;),
        animate('80ms ease-in', style(&#123;
            backgroundColor: '#eee',
            transform: 'scale(1)'
        &#125;))
    ]),
</pre>

<h4>The wildcard state *</h4>
<dt>描述</dt>
<dd>*（“wildcard|通配符”）状态匹配任何动画状态</dd>
<dd>这对定义适用的样式和转换非常有用，无论动画处于哪种状态</dd>
<ul>
    <li>当元素的状态从活动状态变为其他状态时，应用active => * transition</li>
    <li>当两个状态之间发生任何变化时，将应用* => *转换</li>
</ul>
<img class="max-width-50p" src="https://angular.io/generated/images/guide/animations/ng_animate_transitions_inactive_active_wildcards.png">

<h4>The void state</h4>
<dt>描述</dt>
<dd>被称为void的特殊状态可以适用于任何动画</dd>
<dd>适用于元素未附加到视图时，可能是因为它尚未添加或因为它已被删除</dd>
<dd>虚空状态对于定义进入和离开动画是有用的</dd>
<dt>注意:当元素离开视图时，不管它在离开之前处于什么状态，都应用* => void转换</dt>
<img src="https://angular.io/generated/images/guide/animations/ng_animate_transitions_void_in.png" class="max-width-50p">
<dd>通配符状态*也匹配void</dd>

<h4>Example: Entering and leaving</h4>
<dt>描述</dt>
<dd>使用void和*状态可以定义动画元素进入和离开的转换</dd>
<ul>
    <li>Enter: void => *</li>
    <li>Leave: * => void</li>
</ul>
<img src="https://angular.io/generated/images/guide/animations/animation_enter_leave.gif" class="max-width-50p">
<dd>在下面的动画数组中，有两个使用void =>和* => void语法的元素来为视图内外的元素设置动画</dd>
<pre>
    hero-list-enter-leave.component.ts

    animations: [
        trigger('flyInOut', [
        state('in', style(&#123;transform: 'translateX(0)'&#125;)),
        transition('void => *', [
            style(&#123;transform: 'translateX(-100%)'&#125;),
            animate(100)
        ]),
        transition('* => void', [
            animate(100, style(&#123;transform: 'translateX(100%)'&#125;))
        ])
        ])
    ]
</pre>
<dt>描述</dt>
<dd>请注意，在这种情况下，样式直接在转换定义中应用于空状态，而不是在单独的状态（void）定义中应用</dd>
<dd>因此，进入和离开的转换是不同的：元素从左边进入，从右边进入</dd>
<pre>
    transition&#40;':enter', [ ... ]); // void => *
    transition&#40;':leave', [ ... ]); // * => void
</pre>

<h4>Example: Entering and leaving from different states</h4>
<dt>描述</dt>
<dd>还可以使用数据状态作为动画状态，将此动画与较早的状态转换动画组合在一起</dd>
<dd>可以让你根据数据的状态配置不同的进入和离开转换</dd>
<ul>
    <li>不活跃的数据输入：void => inactive</li>
    <li>主动数据进入：void => active</li>
    <li>不活跃的数据假期：inactive => void</li>
    <li>主动数据离开：active => void</li>
</ul>
<img src="https://angular.io/generated/images/guide/animations/animation_enter_leave_states.gif" class="max-width-50p">
<dt>每个转换的详细控制</dt>
<img src="https://angular.io/generated/images/guide/animations/ng_animate_transitions_inactive_active_void.png" class="max-width-50p">
<pre>
    hero-list-enter-leave.component.ts

    animations: [
        trigger('heroState', [
        state('inactive', style(&#123;transform: 'translateX(0) scale(1)'&#125;)),
        state('active',   style(&#123;transform: 'translateX(0) scale(1.1)'&#125;)),
        transition('inactive => active', animate('100ms ease-in')),
        transition('active => inactive', animate('100ms ease-out')),
        transition('void => inactive', [
            style(&#123;transform: 'translateX(-100%) scale(1)'&#125;),
            animate(100)
        ]),
        transition('inactive => void', [
            animate(100, style(&#123;transform: 'translateX(100%) scale(1)'&#125;))
        ]),
        transition('void => active', [
            style(&#123;transform: 'translateX(0) scale(0)'&#125;),
            animate(200)
        ]),
        transition('active => void', [
            animate(200, style(&#123;transform: 'translateX(0) scale(0)'&#125;))
        ])
        ])
    ]
</pre>

<h4>Animatable properties and units(属性和单位)</h4>
<dt>描述</dt>
<dd>angular动画支持建立在网页动画之上，因此可以为浏览器考虑动画的任何属性设置动画</dd>
<dd>这包括位置，大小，变换，颜色，边框等等</dd>
<dt>
    w3c
    <a href="&#123;&#123;listAnimation&#125;&#125;" target="&#123;&#123;targetType&#125;&#125;">动画属性列表</a>
    |
    <a href="&#123;&#123;cssChange&#125;&#125;" target="&#123;&#123;targetType&#125;&#125;">CSS转换页面</a>
</dt>
<dd>对于具有数值的位置属性，可以通过将该值作为具有适当后缀的字符串来定义单位</dd>
<ul>
    <li>'50px'</li>
    <li>'3em'</li>
    <li>'100%'</li>
</ul>
<dt>注意:如果在指定维度时未提供单位，则angular将假定为px的默认值</dt>
<dd>50和“50px”一样</dd>

<h4>Automatic property calculation(自动属性计算)</h4>
<dt>描述</dt>
<dd>有时候直到运行时才会知道维度样式属性的值</dd>
<dd>例如，元素通常具有取决于其内容和屏幕大小的宽度和高度。</dd>
<dd>在这些情况下，可以使用特殊的*属性值，以便在运行时计算属性的值，然后插入到动画中</dd>
<dd>在这个例子中，离开动画在元素离开之前需要任何高度，并从该高度动画到零：</dd>
<img src="https://angular.io/generated/images/guide/animations/animation_auto.gif" class="max-width-50p">
<pre>
    src/app/hero-list-auto.component.ts
    animations: [
        trigger('shrinkOut', [
        state('in', style(&#123;height: '*'&#125;)),
        transition('* => void', [
            style(&#123;height: '*'&#125;),
            animate(250, style(&#123;height: 0&#125;))
        ])
        ])
    ]
</pre>

<h3>Animation timing</h3>
<dt>描述</dt>
<dd>可以为每个动画过渡调整三个定时属性：持续时间，延迟和缓动功能。 它们全部组合成单个转换时间字符串。</dd>

<h4>Duration(持续时间)</h4>
<dt>描述</dt>
<dd>持续时间控制动画从开始到结束运行的时间</dd>
<ul>
    <li>作为一个简单的数字，以毫秒为单位：100</li>
    <li>在一个字符串中，毫秒：“100ms”</li>
    <li>在一个字符串中，如秒：'0.1s'</li>
</ul>
<dt>缓动功能控制动画在运行期间如何加速和减速</dt>
<dd>缓入功能使得动画开始相对缓慢，但随着其进行而提高速度</dd>
<dd>可以通过在持续时间和延迟后的字符串中将其作为第三个值添加来控制宽松（或作为没有延迟的第二个值）</dd>
<ul>
    <li>等待100ms，然后运行200ms，缓动：“0.2s 100ms异步执行”</li>
    <li>运行200ms，缓解：“0.2s缓进”</li>
</ul>
<img src="https://angular.io/generated/images/guide/animations/animation_timings.gif" class="max-width-50p">

<h4>Example</h4>
<dt>描述</dt>
<dd>这里有几个定制的时间在行动。两者都进入和离开最后200毫秒，即0.2秒，但它们有不同的缓冲</dd>
<dd>在“0.2s 10缓解”中指定的10毫秒稍微延迟之后开始异步执行</dd>
<pre>
    hero-list-timings.component.ts

    animations: [
        trigger('flyInOut', [
        state('in', style(&#123;opacity: 1, transform: 'translateX(0)'&#125;)),
        transition('void => *', [
                style(&#123;
                    opacity: 0,
                    transform: 'translateX(-100%)'
                &#125;),
                animate('0.2s ease-in')
            ]),
            transition('* => void', [
                animate('0.2s 0.1s ease-out', style(&#123;
                    opacity: 0,
                    transform: 'translateX(100%)'
                &#125;))
            ])
        ])
    ]
</pre>

<h3>Multi-step animations with keyframes(多关键帧动画)</h3>
<dt>描述</dt>
<dd>动画关键帧超越了简单的过渡到更复杂的动画，在两组样式之间进行过渡时，会经历一个或多个中间样式。</dd>
<dd>对于每个关键帧，可以指定一个偏移量，该偏移量定义关键帧适用的动画中的哪个点。</dd>
<dd>偏移量是标记动画开始的零和标记结束的一个之间的数字。</dd>
<img src="https://angular.io/generated/images/guide/animations/animation_multistep.gif" class="max-width-50p">
<pre>
    hero-list-multistep.component.ts

    animations: [
        trigger('flyInOut', [
        state('in', style(&#123;transform: 'translateX(0)'&#125;)),
        transition('void => *', [
                animate(300, keyframes([
                style(&#123;opacity: 0, transform: 'translateX(-100%)', offset: 0&#125;),
                style(&#123;opacity: 1, transform: 'translateX(15px)',  offset: 0.3&#125;),
                style(&#123;opacity: 1, transform: 'translateX(0)',     offset: 1.0&#125;)
                ]))
            ]),
            transition('* => void', [
                animate(300, keyframes([
                style(&#123;opacity: 1, transform: 'translateX(0)',     offset: 0&#125;),
                style(&#123;opacity: 1, transform: 'translateX(-15px)', offset: 0.7&#125;),
                style(&#123;opacity: 0, transform: 'translateX(100%)',  offset: 1.0&#125;)
                ]))
            ])
        ])
    ]
</pre>
<dt>描述</dt>
<dd>请注意，偏移不是根据绝对时间来定义的</dd>
<dd>动画的最终时间轴是基于关键帧偏移，持续时间，延迟和缓动的组合。定义关键帧的偏移量是可选的</dd>
<dd>如果省略它们，则会自动分配均匀间距的偏移量。</dd>
<dd>例如，没有预定义偏移量的三个关键帧接收偏移量0,0.5和1</dd>

<h4>Parallel(平行) animation groups</h4>
<dt>描述</dt>
<dd>如何同时动画多个样式属性：只需将它们全部放入相同的style（）定义中即可</dd>
<dd>并行发生的动画配置不同的时间</dd>
<dd>在进入和离开时使用组允许两种不同的定时配置</dd>
<dd>两者都并行应用于相同的元素，但是彼此独立运行</dd>
<pre>
    hero-list-groups.component.ts

    animations: [
        trigger('flyInOut', [
        state('in', style(&#123;width: 120, transform: 'translateX(0)', opacity: 1&#125;)),
        transition('void => *', [
            style(&#123;width: 10, transform: 'translateX(50px)', opacity: 0&#125;),
            group([
                animate('0.3s 0.1s ease', style(&#123;
                    transform: 'translateX(0)',
                    width: 120
                &#125;)),
                animate('0.3s ease', style(&#123;
                    opacity: 1
                &#125;))
                ])
            ]),
            transition('* => void', [
                group([
                animate('0.3s ease', style(&#123;
                    transform: 'translateX(50px)',
                    width: 10
                &#125;)),
                animate('0.3s 0.2s ease', style(&#123;
                    opacity: 0
                &#125;))
                ])
            ])
        ])
    ]
</pre>
<dt>描述</dt>
<dd>一组动画元素变换和宽度;另一组激活不透明度</dd>

<h4>Animation callbacks</h4>
<dt>动画开始时以及完成时会触发回调</dt>
<dd>在关键帧示例中，您有一个名为@flyinout的触发器。可以像这样挂钩回调：</dd>
<pre>
    hero-list-multistep.component.ts

    template: `
        &#60;ul>
            &#60;li *ngFor="let hero of heroes"
                (@flyInOut.start)="animationStarted($event)"
                (@flyInOut.done)="animationDone($event)"
                [@flyInOut]="'in'">
                &#125; &#125;hero.name&#125; &#125;
            &#60;/li>
        &#60;/ul>
    `,
</pre>
<dd>回调会收到一个动画事件，其中包含有用的属性，例如fromstate，tostate和totaltime。</dd>
<dd>回调将触发动画是否被执行完毕</dd>